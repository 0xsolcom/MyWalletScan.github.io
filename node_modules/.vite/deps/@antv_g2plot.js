import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-MDCLYK3V.js";

// node_modules/size-sensor/lib/id.js
var require_id = __commonJS({
  "node_modules/size-sensor/lib/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var id = 1;
    var _default = function _default2() {
      return "".concat(id++);
    };
    exports2["default"] = _default;
  }
});

// node_modules/size-sensor/lib/debounce.js
var require_debounce = __commonJS({
  "node_modules/size-sensor/lib/debounce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _default = function _default2(fn) {
      var delay2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
      var timer2 = null;
      return function() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        clearTimeout(timer2);
        timer2 = setTimeout(function() {
          fn.apply(_this, args);
        }, delay2);
      };
    };
    exports2["default"] = _default;
  }
});

// node_modules/size-sensor/lib/constant.js
var require_constant = __commonJS({
  "node_modules/size-sensor/lib/constant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SensorTabIndex = exports2.SensorClassName = exports2.SizeSensorId = void 0;
    var SizeSensorId = "size-sensor-id";
    exports2.SizeSensorId = SizeSensorId;
    var SensorClassName = "size-sensor-object";
    exports2.SensorClassName = SensorClassName;
    var SensorTabIndex = "-1";
    exports2.SensorTabIndex = SensorTabIndex;
  }
});

// node_modules/size-sensor/lib/sensors/object.js
var require_object = __commonJS({
  "node_modules/size-sensor/lib/sensors/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSensor = void 0;
    var _debounce = _interopRequireDefault(require_debounce());
    var _constant = require_constant();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var createSensor = function createSensor2(element) {
      var sensor = void 0;
      var listeners = [];
      var newSensor = function newSensor2() {
        if (getComputedStyle(element).position === "static") {
          element.style.position = "relative";
        }
        var obj = document.createElement("object");
        obj.onload = function() {
          obj.contentDocument.defaultView.addEventListener("resize", resizeListener);
          resizeListener();
        };
        obj.style.display = "block";
        obj.style.position = "absolute";
        obj.style.top = "0";
        obj.style.left = "0";
        obj.style.height = "100%";
        obj.style.width = "100%";
        obj.style.overflow = "hidden";
        obj.style.pointerEvents = "none";
        obj.style.zIndex = "-1";
        obj.style.opacity = "0";
        obj.setAttribute("class", _constant.SensorClassName);
        obj.setAttribute("tabindex", _constant.SensorTabIndex);
        obj.type = "text/html";
        element.appendChild(obj);
        obj.data = "about:blank";
        return obj;
      };
      var resizeListener = (0, _debounce["default"])(function() {
        listeners.forEach(function(listener) {
          listener(element);
        });
      });
      var bind3 = function bind4(cb) {
        if (!sensor) {
          sensor = newSensor();
        }
        if (listeners.indexOf(cb) === -1) {
          listeners.push(cb);
        }
      };
      var destroy = function destroy2() {
        if (sensor && sensor.parentNode) {
          if (sensor.contentDocument) {
            sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener);
          }
          sensor.parentNode.removeChild(sensor);
          sensor = void 0;
          listeners = [];
        }
      };
      var unbind = function unbind2(cb) {
        var idx = listeners.indexOf(cb);
        if (idx !== -1) {
          listeners.splice(idx, 1);
        }
        if (listeners.length === 0 && sensor) {
          destroy();
        }
      };
      return {
        element,
        bind: bind3,
        destroy,
        unbind
      };
    };
    exports2.createSensor = createSensor;
  }
});

// node_modules/size-sensor/lib/sensors/resizeObserver.js
var require_resizeObserver = __commonJS({
  "node_modules/size-sensor/lib/sensors/resizeObserver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSensor = void 0;
    var _debounce = _interopRequireDefault(require_debounce());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var createSensor = function createSensor2(element) {
      var sensor = void 0;
      var listeners = [];
      var resizeListener = (0, _debounce["default"])(function() {
        listeners.forEach(function(listener) {
          listener(element);
        });
      });
      var newSensor = function newSensor2() {
        var s = new ResizeObserver(resizeListener);
        s.observe(element);
        resizeListener();
        return s;
      };
      var bind3 = function bind4(cb) {
        if (!sensor) {
          sensor = newSensor();
        }
        if (listeners.indexOf(cb) === -1) {
          listeners.push(cb);
        }
      };
      var destroy = function destroy2() {
        sensor.disconnect();
        listeners = [];
        sensor = void 0;
      };
      var unbind = function unbind2(cb) {
        var idx = listeners.indexOf(cb);
        if (idx !== -1) {
          listeners.splice(idx, 1);
        }
        if (listeners.length === 0 && sensor) {
          destroy();
        }
      };
      return {
        element,
        bind: bind3,
        destroy,
        unbind
      };
    };
    exports2.createSensor = createSensor;
  }
});

// node_modules/size-sensor/lib/sensors/index.js
var require_sensors = __commonJS({
  "node_modules/size-sensor/lib/sensors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSensor = void 0;
    var _object = require_object();
    var _resizeObserver = require_resizeObserver();
    var createSensor = typeof ResizeObserver !== "undefined" ? _resizeObserver.createSensor : _object.createSensor;
    exports2.createSensor = createSensor;
  }
});

// node_modules/size-sensor/lib/sensorPool.js
var require_sensorPool = __commonJS({
  "node_modules/size-sensor/lib/sensorPool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.removeSensor = exports2.getSensor = void 0;
    var _id = _interopRequireDefault(require_id());
    var _sensors = require_sensors();
    var _constant = require_constant();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Sensors = {};
    var getSensor = function getSensor2(element) {
      var sensorId = element.getAttribute(_constant.SizeSensorId);
      if (sensorId && Sensors[sensorId]) {
        return Sensors[sensorId];
      }
      var newId = (0, _id["default"])();
      element.setAttribute(_constant.SizeSensorId, newId);
      var sensor = (0, _sensors.createSensor)(element);
      Sensors[newId] = sensor;
      return sensor;
    };
    exports2.getSensor = getSensor;
    var removeSensor = function removeSensor2(sensor) {
      var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
      sensor.element.removeAttribute(_constant.SizeSensorId);
      sensor.destroy();
      if (sensorId && Sensors[sensorId]) {
        delete Sensors[sensorId];
      }
    };
    exports2.removeSensor = removeSensor;
  }
});

// node_modules/size-sensor/lib/index.js
var require_lib = __commonJS({
  "node_modules/size-sensor/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ver = exports2.clear = exports2.bind = void 0;
    var _sensorPool = require_sensorPool();
    var bind3 = function bind4(element, cb) {
      var sensor = (0, _sensorPool.getSensor)(element);
      sensor.bind(cb);
      return function() {
        sensor.unbind(cb);
      };
    };
    exports2.bind = bind3;
    var clear = function clear2(element) {
      var sensor = (0, _sensorPool.getSensor)(element);
      (0, _sensorPool.removeSensor)(sensor);
    };
    exports2.clear = clear;
    var ver = "1.0.1";
    exports2.ver = ver;
  }
});

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports2, module2) {
    "use strict";
    var self2 = module2.exports;
    module2.exports.isNumber = function(x) {
      return typeof x === "number";
    };
    module2.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, arr[i]);
      }
      return curr;
    };
    module2.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, arr[i]);
      }
      return curr;
    };
    module2.exports.findMinMulti = function(arr) {
      var curr = self2.findMin(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, self2.findMin(arr[i]));
      }
      return curr;
    };
    module2.exports.findMaxMulti = function(arr) {
      var curr = self2.findMax(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, self2.findMax(arr[i]));
      }
      return curr;
    };
    module2.exports.inside = function(min5, max5, x) {
      return min5 <= x && x <= max5;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports2, module2) {
    "use strict";
    var DEFAULT_SIZE2 = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self2 = module2.exports;
    var helper = require_helper();
    function kernel(x) {
      return 1 - Math.abs(x);
    }
    module2.exports.getUnifiedMinMax = function(arr, options) {
      return self2.getUnifiedMinMaxMulti([arr], options);
    };
    module2.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
      var min5 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max5 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range2 = max5 - min5;
      var step = range2 / (size3 - 1);
      if (relaxMin) {
        min5 = min5 - 2 * width * step;
      }
      if (relaxMax) {
        max5 = max5 + 2 * width * step;
      }
      return {
        min: min5,
        max: max5
      };
    };
    module2.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self2.getUnifiedMinMax(arr, {
        size: size3,
        width,
        min: options.min,
        max: options.max
      });
      var min5 = normalizedMinMax.min;
      var max5 = normalizedMinMax.max;
      var range2 = max5 - min5;
      var step = range2 / (size3 - 1);
      if (range2 === 0) {
        return [{ x: min5, y: 1 }];
      }
      var buckets = [];
      for (var i = 0; i < size3; i++) {
        buckets.push({
          x: min5 + i * step,
          y: 0
        });
      }
      var xToBucket = function(x) {
        return Math.floor((x - min5) / step);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x) {
        var bucket = xToBucket(x);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight * (leftBlockCount - 1) * c;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight * 1 * c;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight * 2 * c;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight * 1 * c;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i = -width; i <= width; i++) {
        accumulator += kernel2(i / width);
        partialAreas[i] = accumulator;
      }
      return partialAreas;
    }
    module2.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module2.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last3 = 0;
      for (var i = 0; i < pdf2.length; i++) {
        last3 = i;
        accumulator += pdf2[i].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last3].x;
    };
    module2.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln = Math.log(obj.y);
        if (isFinite(ln)) {
          entropy += obj.y * ln;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  Action: () => base_default12,
  BRUSH_FILTER_EVENTS: () => EVENTS3,
  Chart: () => chart_default,
  ComponentController: () => Controller,
  Coordinate: () => base_default7,
  DIRECTION: () => DIRECTION,
  ELEMENT_RANGE_HIGHLIGHT_EVENTS: () => EVENTS2,
  Element: () => element_default2,
  Event: () => event_default,
  Facet: () => Facet,
  Geometry: () => base_default13,
  GeometryLabel: () => base_default14,
  Interaction: () => interaction_default,
  InteractionAction: () => base_default12,
  LAYER: () => LAYER,
  Scale: () => base_default4,
  TooltipController: () => tooltip_default,
  Util: () => Util,
  VERSION: () => VERSION,
  VIEW_LIFE_CIRCLE: () => VIEW_LIFE_CIRCLE,
  View: () => view_default,
  getActionClass: () => getActionClass,
  getAnimation: () => getAnimation,
  getEngine: () => getEngine,
  getFacet: () => getFacet,
  getGeometryLabel: () => getGeometryLabel,
  getGeometryLabelLayout: () => getGeometryLabelLayout,
  getInteraction: () => getInteraction,
  getShapeFactory: () => getShapeFactory,
  getTheme: () => getTheme,
  registerAction: () => registerAction,
  registerAnimation: () => registerAnimation,
  registerComponentController: () => registerComponentController,
  registerEngine: () => registerEngine,
  registerFacet: () => registerFacet,
  registerGeometry: () => registerGeometry,
  registerGeometryLabel: () => registerGeometryLabel,
  registerGeometryLabelLayout: () => registerGeometryLabelLayout,
  registerInteraction: () => registerInteraction,
  registerShape: () => registerShape,
  registerShapeFactory: () => registerShapeFactory,
  registerTheme: () => registerTheme
});

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (Object.prototype.hasOwnProperty.call(b10, p))
        d2[p] = b10[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@antv/util/esm/is-array-like.js
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/contains.js
var contains = function(arr, value2) {
  if (!is_array_like_default(arr)) {
    return false;
  }
  return arr.indexOf(value2) > -1;
};
var contains_default = contains;

// node_modules/@antv/util/esm/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result2 = [];
  for (var index = 0; index < arr.length; index++) {
    var value2 = arr[index];
    if (func(value2, index)) {
      result2.push(value2);
    }
  }
  return result2;
};
var filter_default = filter;

// node_modules/@antv/util/esm/difference.js
var difference = function(arr, values3) {
  if (values3 === void 0) {
    values3 = [];
  }
  return filter_default(arr, function(value2) {
    return !contains_default(values3, value2);
  });
};
var difference_default = difference;

// node_modules/@antv/util/esm/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value2) {
  return is_type_default(value2, "Function");
};

// node_modules/@antv/util/esm/is-nil.js
var isNil = function(value2) {
  return value2 === null || value2 === void 0;
};
var is_nil_default = isNil;

// node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default(value2, "Array");
};

// node_modules/@antv/util/esm/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len3 = elements.length; i < len3; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result2 = [];
  each_default(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result2.push(key);
    }
  });
  return result2;
};
var keys_default = keys;

// node_modules/@antv/util/esm/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (is_nil_default(obj))
    return !length5;
  for (var i = 0; i < length5; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default = isMatch;

// node_modules/@antv/util/esm/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/find.js
function find(arr, predicate) {
  if (!is_array_default(arr))
    return null;
  var _predicate;
  if (is_function_default(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a) {
      return is_match_default(a, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
var find_default = find;

// node_modules/@antv/util/esm/find-index.js
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i = fromIndex; i < arr.length; i++) {
    if (predicate(arr[i], i)) {
      return i;
    }
  }
  return -1;
}
var find_index_default = findIndex;

// node_modules/@antv/util/esm/first-value.js
var firstValue = function(data3, name) {
  var rst = null;
  for (var i = 0; i < data3.length; i++) {
    var obj = data3[i];
    var value2 = obj[name];
    if (!is_nil_default(value2)) {
      if (is_array_default(value2)) {
        rst = value2[0];
      } else {
        rst = value2;
      }
      break;
    }
  }
  return rst;
};
var first_value_default = firstValue;

// node_modules/@antv/util/esm/flatten.js
var flatten = function(arr) {
  if (!is_array_default(arr)) {
    return [];
  }
  var rst = [];
  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }
  return rst;
};
var flatten_default = flatten;

// node_modules/@antv/util/esm/max.js
var max_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/min.js
var min_default = function(arr) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/get-range.js
var getRange = function(values3) {
  var filterValues = values3.filter(function(v) {
    return !isNaN(v);
  });
  if (!filterValues.length) {
    return {
      min: 0,
      max: 0
    };
  }
  if (is_array_default(values3[0])) {
    var tmp = [];
    for (var i = 0; i < values3.length; i++) {
      tmp = tmp.concat(values3[i]);
    }
    filterValues = tmp;
  }
  var max5 = max_default(filterValues);
  var min5 = min_default(filterValues);
  return {
    min: min5,
    max: max5
  };
};
var get_range_default = getRange;

// node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/pull-at.js
var splice2 = Array.prototype.splice;
var pullAt = function pullAt2(arr, indexes) {
  if (!is_array_like_default(arr)) {
    return [];
  }
  var length5 = arr ? indexes.length : 0;
  var last3 = length5 - 1;
  while (length5--) {
    var previous = void 0;
    var index = indexes[length5];
    if (length5 === last3 || index !== previous) {
      previous = index;
      splice2.call(arr, index, 1);
    }
  }
  return arr;
};
var pull_at_default = pullAt;

// node_modules/@antv/util/esm/reduce.js
var reduce = function(arr, fn, init) {
  if (!is_array_default(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result2 = init;
  each_default(arr, function(data3, i) {
    result2 = fn(result2, data3, i);
  });
  return result2;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/remove.js
var remove = function(arr, predicate) {
  var result2 = [];
  if (!is_array_like_default(arr)) {
    return result2;
  }
  var i = -1;
  var indexes = [];
  var length5 = arr.length;
  while (++i < length5) {
    var value2 = arr[i];
    if (predicate(value2, i, arr)) {
      result2.push(value2);
      indexes.push(i);
    }
  }
  pull_at_default(arr, indexes);
  return result2;
};
var remove_default = remove;

// node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str4) {
  return is_type_default(str4, "String");
};

// node_modules/@antv/util/esm/sort-by.js
function sortBy(arr, key) {
  var comparer;
  if (is_function_default(key)) {
    comparer = function(a, b) {
      return key(a) - key(b);
    };
  } else {
    var keys_1 = [];
    if (is_string_default(key)) {
      keys_1.push(key);
    } else if (is_array_default(key)) {
      keys_1 = key;
    }
    comparer = function(a, b) {
      for (var i = 0; i < keys_1.length; i += 1) {
        var prop = keys_1[i];
        if (a[prop] > b[prop]) {
          return 1;
        }
        if (a[prop] < b[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
var sort_by_default = sortBy;

// node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache3) {
  if (cache3 === void 0) {
    cache3 = /* @__PURE__ */ new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len3 = arr.length; i < len3; i++) {
      var item = arr[i];
      if (!cache3.has(item)) {
        r.push(item);
        cache3.set(item, true);
      }
    }
  }
  return r;
}

// node_modules/@antv/util/esm/values-of-key.js
var values_of_key_default = function(data3, name) {
  var rst = [];
  var tmpMap = {};
  for (var i = 0; i < data3.length; i++) {
    var obj = data3[i];
    var value2 = obj[name];
    if (!is_nil_default(value2)) {
      if (!is_array_default(value2)) {
        value2 = [value2];
      }
      for (var j = 0; j < value2.length; j++) {
        var val = value2[j];
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }
  return rst;
};

// node_modules/@antv/util/esm/head.js
function head(o) {
  if (is_array_like_default(o)) {
    return o[0];
  }
  return void 0;
}

// node_modules/@antv/util/esm/last.js
function last(o) {
  if (is_array_like_default(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/every.js
var every = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (!func(arr[i], i))
      return false;
  }
  return true;
};
var every_default = every;

// node_modules/@antv/util/esm/some.js
var some = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i], i))
      return true;
  }
  return false;
};
var some_default = some;

// node_modules/@antv/util/esm/group-by.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data3, condition) {
  if (!condition || !is_array_default(data3)) {
    return {};
  }
  var result2 = {};
  var predicate = is_function_default(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i = 0; i < data3.length; i++) {
    var item = data3[i];
    key = predicate(item);
    if (hasOwnProperty.call(result2, key)) {
      result2[key].push(item);
    } else {
      result2[key] = [item];
    }
  }
  return result2;
}
var group_by_default = groupBy;

// node_modules/@antv/util/esm/group-to-map.js
function groupToMap(data3, condition) {
  if (!condition) {
    return {
      0: data3
    };
  }
  if (!is_function_default(condition)) {
    var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i = 0, l = paramscondition_1.length; i < l; i++) {
        unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
      }
      return unique;
    };
  }
  return group_by_default(data3, condition);
}

// node_modules/@antv/util/esm/group.js
var group_default = function(data3, condition) {
  if (!condition) {
    return [data3];
  }
  var groups = groupToMap(data3, condition);
  var array = [];
  for (var i in groups) {
    array.push(groups[i]);
  }
  return array;
};

// node_modules/@antv/util/esm/clamp.js
var clamp = function(a, min5, max5) {
  if (a < min5) {
    return min5;
  } else if (a > max5) {
    return max5;
  }
  return a;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/fixed-base.js
var fixedBase = function(v, base) {
  var str4 = base.toString();
  var index = str4.indexOf(".");
  if (index === -1) {
    return Math.round(v);
  }
  var length5 = str4.substr(index + 1).length;
  if (length5 > 20) {
    length5 = 20;
  }
  return parseFloat(v.toFixed(length5));
};
var fixed_base_default = fixedBase;

// node_modules/@antv/util/esm/is-number.js
var isNumber = function(value2) {
  return is_type_default(value2, "Number");
};
var is_number_default = isNumber;

// node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/util/esm/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}

// node_modules/@antv/util/esm/max-by.js
var max_by_default = function(arr, fn) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  var maxItem;
  var max5 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = is_function_default(fn) ? fn(item) : item[fn];
    if (v > max5) {
      maxItem = item;
      max5 = v;
    }
  }
  return maxItem;
};

// node_modules/@antv/util/esm/min-by.js
var min_by_default = function(arr, fn) {
  if (!is_array_default(arr)) {
    return void 0;
  }
  var minItem;
  var min5 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = is_function_default(fn) ? fn(item) : item[fn];
    if (v < min5) {
      minItem = item;
      min5 = v;
    }
  }
  return minItem;
};

// node_modules/@antv/util/esm/mod.js
var mod = function(n, m) {
  return (n % m + m) % m;
};
var mod_default = mod;

// node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;
var toRadian = function(degree2) {
  return RADIAN * degree2;
};
var to_radian_default = toRadian;

// node_modules/@antv/util/esm/for-in.js
var for_in_default = each_default;

// node_modules/@antv/util/esm/has.js
var has_default = function(obj, key) {
  return obj.hasOwnProperty(key);
};

// node_modules/@antv/util/esm/has-key.js
var has_key_default = has_default;

// node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result2 = [];
  each_default(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result2.push(value2);
    }
  });
  return result2;
};
var values_default = values;

// node_modules/@antv/util/esm/to-string.js
var to_string_default = function(value2) {
  if (is_nil_default(value2))
    return "";
  return value2.toString();
};

// node_modules/@antv/util/esm/lower-case.js
var lowerCase = function(str4) {
  return to_string_default(str4).toLowerCase();
};
var lower_case_default = lowerCase;

// node_modules/@antv/util/esm/substitute.js
function substitute(str4, o) {
  if (!str4 || !o) {
    return str4;
  }
  return str4.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name] === void 0 ? "" : o[name];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/upper-first.js
var upperFirst = function(value2) {
  var str4 = to_string_default(value2);
  return str4.charAt(0).toUpperCase() + str4.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/get-type.js
var toString2 = {}.toString;
var getType = function(value2) {
  return toString2.call(value2).replace(/^\[object /, "").replace(/]$/, "");
};
var get_type_default = getType;

// node_modules/@antv/util/esm/is-boolean.js
var isBoolean = function(value2) {
  return is_type_default(value2, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/is-date.js
var isDate = function(value2) {
  return is_type_default(value2, "Date");
};
var is_date_default = isDate;

// node_modules/@antv/util/esm/is-null.js
var isNull = function(value2) {
  return value2 === null;
};
var is_null_default = isNull;

// node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;
var isPrototype = function(value2) {
  var Ctor = value2 && value2.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value2 === proto;
};
var is_prototype_default = isPrototype;

// node_modules/@antv/util/esm/is-undefined.js
var isUndefined = function(value2) {
  return value2 === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/is-element.js
var isElement = function(o) {
  return o instanceof Element || o instanceof HTMLDocument;
};
var is_element_default = isElement;

// node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame(fn) {
  var method2 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 16);
  };
  return method2(fn);
}

// node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame(handler) {
  var method2 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method2(handler);
}

// node_modules/@antv/util/esm/mix.js
function _mix(dist3, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist3[key] = obj[key];
    }
  }
}
function mix(dist3, src1, src2, src3) {
  if (src1)
    _mix(dist3, src1);
  if (src2)
    _mix(dist3, src2);
  if (src3)
    _mix(dist3, src3);
  return dist3;
}

// node_modules/@antv/util/esm/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (is_array_default(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f, resolver) {
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache3 = memoized.cache;
    if (cache3.has(key)) {
      return cache3.get(key);
    }
    var result2 = f.apply(this, args);
    cache3.set(key, result2);
    return result2;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL = 5;
function _deepMix(dist3, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist3[key])) {
          dist3[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist3[key], value2, level + 1, maxLevel);
        } else {
          dist3[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist3[key] = [];
        dist3[key] = dist3[key].concat(value2);
      } else if (value2 !== void 0) {
        dist3[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/index-of.js
var indexOf2 = function(arr, obj) {
  if (!is_array_like_default(arr)) {
    return -1;
  }
  var m = Array.prototype.indexOf;
  if (m) {
    return m.call(arr, obj);
  }
  var index = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index = i;
      break;
    }
  }
  return index;
};
var index_of_default = indexOf2;

// node_modules/@antv/util/esm/is-empty.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function isEmpty(value2) {
  if (is_nil_default(value2)) {
    return true;
  }
  if (is_array_like_default(value2)) {
    return !value2.length;
  }
  var type = get_type_default(value2);
  if (type === "Map" || type === "Set") {
    return !value2.size;
  }
  if (is_prototype_default(value2)) {
    return !Object.keys(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty2.call(value2, key)) {
      return false;
    }
  }
  return true;
}
var is_empty_default = isEmpty;

// node_modules/@antv/util/esm/is-equal.js
var isEqual = function(value2, other2) {
  if (value2 === other2) {
    return true;
  }
  if (!value2 || !other2) {
    return false;
  }
  if (is_string_default(value2) || is_string_default(other2)) {
    return false;
  }
  if (is_array_like_default(value2) || is_array_like_default(other2)) {
    if (value2.length !== other2.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value2.length; i++) {
      rst = isEqual(value2[i], other2[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value2) || is_object_like_default(other2)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other2);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value2[valueKeys[i]], other2[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/map.js
var map = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result2 = [];
  for (var index = 0; index < arr.length; index++) {
    var value2 = arr[index];
    result2.push(func(value2, index));
  }
  return result2;
};
var map_default = map;

// node_modules/@antv/util/esm/map-values.js
var identity = function(v) {
  return v;
};
var map_values_default = function(object, func) {
  if (func === void 0) {
    func = identity;
  }
  var r = {};
  if (is_object_default(object) && !is_nil_default(object)) {
    Object.keys(object).forEach(function(key) {
      r[key] = func(object[key], key);
    });
  }
  return r;
};

// node_modules/@antv/util/esm/get.js
var get_default = function(obj, key, defaultValue) {
  var p = 0;
  var keyArr = is_string_default(key) ? key.split(".") : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/set.js
var set_default = function(obj, path, value2) {
  var o = obj;
  var keyArr = is_string_default(path) ? path.split(".") : path;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o[key])) {
        o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value2;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/pick.js
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys3) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result2 = {};
  each_default(keys3, function(key) {
    if (hasOwnProperty3.call(object, key)) {
      result2[key] = object[key];
    }
  });
  return result2;
};

// node_modules/@antv/util/esm/omit.js
var omit_default = function(obj, keys3) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys3.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/@antv/util/esm/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout2, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result2 = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now3 = Date.now();
    if (!previous && options.leading === false)
      previous = now3;
    var remaining = wait - (now3 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now3;
      result2 = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/to-array.js
var to_array_default = function(value2) {
  return is_array_like_default(value2) ? Array.prototype.slice.call(value2) : [];
};

// node_modules/@antv/util/esm/unique-id.js
var map2 = {};
var unique_id_default = function(prefix) {
  prefix = prefix || "g";
  if (!map2[prefix]) {
    map2[prefix] = 1;
  } else {
    map2[prefix] += 1;
  }
  return prefix + map2[prefix];
};

// node_modules/@antv/util/esm/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/size.js
function size(o) {
  if (is_nil_default(o)) {
    return 0;
  }
  if (is_array_like_default(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// node_modules/@antv/util/esm/get-ellipsis-text.js
var get_ellipsis_text_default = function(text, maxWidth, font, str4) {
  if (str4 === void 0) {
    str4 = "...";
  }
  var STEP = 16;
  var PLACEHOLDER_WIDTH = measure_text_width_default(str4, font);
  var leftText = !is_string_default(text) ? to_string_default(text) : text;
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measure_text_width_default(text, font) <= maxWidth) {
    return text;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measure_text_width_default(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measure_text_width_default(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "" + r.join("") + str4;
};

// node_modules/@antv/util/esm/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);
var cache_default = default_1;

// node_modules/@antv/g2/esm/constant.js
var LAYER;
(function(LAYER2) {
  LAYER2["FORE"] = "fore";
  LAYER2["MID"] = "mid";
  LAYER2["BG"] = "bg";
})(LAYER || (LAYER = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["TOP"] = "top";
  DIRECTION2["TOP_LEFT"] = "top-left";
  DIRECTION2["TOP_RIGHT"] = "top-right";
  DIRECTION2["RIGHT"] = "right";
  DIRECTION2["RIGHT_TOP"] = "right-top";
  DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION2["LEFT"] = "left";
  DIRECTION2["LEFT_TOP"] = "left-top";
  DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION2["BOTTOM"] = "bottom";
  DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION2["RADIUS"] = "radius";
  DIRECTION2["CIRCLE"] = "circle";
  DIRECTION2["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
var COMPONENT_TYPE;
(function(COMPONENT_TYPE2) {
  COMPONENT_TYPE2["AXIS"] = "axis";
  COMPONENT_TYPE2["GRID"] = "grid";
  COMPONENT_TYPE2["LEGEND"] = "legend";
  COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
  COMPONENT_TYPE2["ANNOTATION"] = "annotation";
  COMPONENT_TYPE2["SLIDER"] = "slider";
  COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
  COMPONENT_TYPE2["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
var GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE2) {
  VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE2) {
  GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  GEOMETRY_LIFE_CIRCLE2["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
  GEOMETRY_LIFE_CIRCLE2["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function(PLOT_EVENTS2) {
  PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
  PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
  PLOT_EVENTS2["CLICK"] = "plot:click";
  PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS2["LEAVE"] = "plot:leave";
  PLOT_EVENTS2["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function(ELEMENT_STATE2) {
  ELEMENT_STATE2["ACTIVE"] = "active";
  ELEMENT_STATE2["INACTIVE"] = "inactive";
  ELEMENT_STATE2["SELECTED"] = "selected";
  ELEMENT_STATE2["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
var GROUP_ATTRS = ["color", "shape", "size"];
var FIELD_ORIGIN = "_origin";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

// node_modules/@antv/g2/esm/engine/index.js
var ENGINES = {};
function getEngine(name) {
  var G = ENGINES[name];
  if (!G) {
    throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
  }
  return G;
}
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}

// node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}

// node_modules/@antv/dom-util/esm/create-dom.js
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom(str4) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str4) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str4 = typeof str4 === "string" ? str4.replace(/(^\s*)|(\s*$)/g, "") : str4;
  container.innerHTML = "" + str4;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/dom-util/esm/get-style.js
function getStyle(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e) {
  } finally {
    v = v === void 0 ? defaultValue : v;
  }
  return v;
}

// node_modules/@antv/dom-util/esm/get-height.js
function getHeight(el, defaultValue) {
  var height = getStyle(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}

// node_modules/@antv/dom-util/esm/get-outer-height.js
function getOuterHeight(el, defaultValue) {
  var height = getHeight(el, defaultValue);
  var bTop = parseFloat(getStyle(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}

// node_modules/@antv/dom-util/esm/get-width.js
function getHeight2(el, defaultValue) {
  var width = getStyle(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}

// node_modules/@antv/dom-util/esm/get-outer-width.js
function getOuterWidth(el, defaultValue) {
  var width = getHeight2(el, defaultValue);
  var bLeft = parseFloat(getStyle(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}

// node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}

// node_modules/@antv/g2/esm/util/dom.js
function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function isNumber2(v) {
  return typeof v === "number" && !isNaN(v);
}
function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;
  if (autoFit) {
    var size3 = getElementSize(ele);
    w = size3.width ? size3.width : w;
    h = size3.height ? size3.height : h;
  }
  return {
    width: Math.max(isNumber2(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber2(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  };
}
function removeDom(dom) {
  var parent2 = dom.parentNode;
  if (parent2) {
    parent2.removeChild(dom);
  }
}

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once2) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once2
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length5 = es.length;
        for (var i = 0; i < length5; i++) {
          if (!es[i]) {
            continue;
          }
          var _a6 = es[i], callback = _a6.callback, once2 = _a6.once;
          if (once2) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length5--;
            i--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }()
);
var esm_default = EventEmitter;

// node_modules/@antv/g2/esm/base.js
var Base = (
  /** @class */
  function(_super) {
    __extends(Base3, _super);
    function Base3(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var _a6 = cfg.visible, visible = _a6 === void 0 ? true : _a6;
      _this.visible = visible;
      return _this;
    }
    Base3.prototype.show = function() {
      var visible = this.visible;
      if (!visible) {
        this.changeVisible(true);
      }
    };
    Base3.prototype.hide = function() {
      var visible = this.visible;
      if (visible) {
        this.changeVisible(false);
      }
    };
    Base3.prototype.destroy = function() {
      this.off();
      this.destroyed = true;
    };
    Base3.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;
    };
    return Base3;
  }(esm_default)
);
var base_default = Base;

// node_modules/@antv/g-base/esm/util/path.js
var path_exports = {};
__export(path_exports, {
  catmullRomToBezier: () => catmullRomToBezier,
  fillPath: () => fillPath,
  fillPathByDiff: () => fillPathByDiff,
  formatPath: () => formatPath,
  intersection: () => intersection,
  parsePathArray: () => parsePathArray,
  parsePathString: () => parsePathString,
  pathToAbsolute: () => pathToAbsolute,
  pathToCurve: () => pathToCurve,
  rectPath: () => rectPath
});
var SPACES = "	\n\v\f\r \u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data3 = [];
  String(pathString).replace(PATH_COMMAND, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data3.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data3.push([b, params[0]]);
    }
    if (name === "r") {
      data3.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data3.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data3;
};
var catmullRomToBezier = function(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [
      {
        x: +crp[i - 2],
        y: +crp[i - 1]
      },
      {
        x: +crp[i],
        y: +crp[i + 1]
      },
      {
        x: +crp[i + 2],
        y: +crp[i + 3]
      },
      {
        x: +crp[i + 4],
        y: +crp[i + 5]
      }
    ];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push([
      "C",
      (-p[0].x + 6 * p[1].x + p[2].x) / 6,
      (-p[0].y + 6 * p[1].y + p[2].y) / 6,
      (p[1].x + 6 * p[2].x - p[3].x) / 6,
      (p[1].y + 6 * p[2].y - p[3].y) / 6,
      p[2].x,
      p[2].y
    ]);
  }
  return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
    ];
  } else {
    res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute = function(pathArray) {
  pathArray = parsePathString(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "R":
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === "R") {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ["R"].concat(pa.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r[0]) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle4, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle4 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate5 = function(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate5(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate5(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle4, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate5(res[i - 1], res[i], rad).y : rotate5(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii;
  var processPath = function(path3, d, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
        break;
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
      default:
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi2 = pp[i2];
      while (pi2.length) {
        pcoms1[i2] = "A";
        p2 && (pcoms2[i2] = "A");
        pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function(path1, path22, a1, a2, i2) {
    if (path1 && path22 && path1[i2][0] === "M" && path22[i2][0] !== "M") {
      path22.splice(i2, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i2][1];
      a1.y = path1[i2][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]);
    if (pfirst !== "C") {
      pcoms1[i] = pfirst;
      i && (pcom = pcoms1[i - 1]);
    }
    p[i] = processPath(p[i], attrs, pcom);
    if (pcoms1[i] !== "A" && pfirst === "C")
      pcoms1[i] = "C";
    fixArc(p, i);
    if (p2) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== "A" && pfirst === "C") {
        pcoms2[i] = "C";
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path) {
  return path.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
  var t12 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t * t12 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum2 = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum2 += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum2;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t12 = (-b + sqrtb2ac) / (2 * a);
    if (t12 > 0 && t12 < 1) {
      tvalues.push(t12);
    }
    var t22 = (-b - sqrtb2ac) / (2 * a);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function(x, y, w, h, r) {
  if (r) {
    return [
      ["M", +x + +r, y],
      ["l", w - r * 2, 0],
      ["a", r, r, 0, 0, 1, r, r],
      ["l", 0, h - r * 2],
      ["a", r, r, 0, 0, 1, -r, r],
      ["l", r * 2 - w, 0],
      ["a", r, r, 0, 0, 1, -r, -r],
      ["l", 0, r * 2 - h],
      ["a", r, r, 0, 0, 1, r, -r],
      ["z"]
    ];
  }
  var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    w: width,
    height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!is_array_default(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t12 = 1 - t;
  var t13 = Math.pow(t12, 3);
  var t122 = Math.pow(t12, 2);
  var t22 = t * t;
  var t32 = t22 * t;
  var x = t13 * p1x + t122 * 3 * t * c1x + t12 * 3 * t * t * c2x + t32 * p2x;
  var y = t13 * p1y + t122 * 3 * t * c1y + t12 * 3 * t * t * c2y + t32 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t12 * p1x + t * c1x;
  var ay = t12 * p1y + t * c1y;
  var cx = t12 * c2x + t * p2x;
  var cy = t12 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x,
    y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t12 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t22 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t12,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi2 = path1[i];
    if (pi2[0] === "M") {
      x1 = x1m = pi2[1];
      y1 = y1m = pi2[2];
    } else {
      if (pi2[0] === "C") {
        bez1 = [x1, y1].concat(pi2.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points2, t) {
  var left2 = [];
  var right2 = [];
  function recurse(points3, t4) {
    if (points3.length === 1) {
      left2.push(points3[0]);
      right2.push(points3[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points3.length - 1; i++) {
        if (i === 0) {
          left2.push(points3[0]);
        }
        if (i === points3.length - 2) {
          right2.push(points3[i + 1]);
        }
        middlePoints[i] = [
          (1 - t4) * points3[i][0] + t4 * points3[i + 1][0],
          (1 - t4) * points3[i][1] + t4 * points3[i + 1][1]
        ];
      }
      recurse(middlePoints, t4);
    }
  }
  if (points2.length) {
    recurse(points2, t);
  }
  return { left: left2, right: right2.reverse() };
}
function splitCurve(start, end, count2) {
  var points2 = [[start[1], start[2]]];
  count2 = count2 || 2;
  var segments = [];
  if (end[0] === "A") {
    points2.push(end[6]);
    points2.push(end[7]);
  } else if (end[0] === "C") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
    points2.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
  } else {
    points2.push([end[1], end[2]]);
  }
  var leftSegments = points2;
  var t = 1 / count2;
  for (var i = 0; i < count2 - 1; i++) {
    var rt = t / (1 - t * i);
    var split2 = decasteljau(leftSegments, rt);
    segments.push(split2.left);
    leftSegments = split2.right;
  }
  segments.push(leftSegments);
  var result2 = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result2;
}
var splitSegment = function(start, end, count2) {
  if (count2 === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count2));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i = 0; i <= count2 - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count2, i2) {
    if (i2 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i2], source[i2 + 1], count2));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual2 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result2 = true;
  each_default(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result2 = false;
      return false;
    }
  });
  return result2;
};
function getMinDiff(del, add6, modify) {
  var type = null;
  var min5 = modify;
  if (add6 < min5) {
    min5 = add6;
    type = "add";
  }
  if (del < min5) {
    min5 = del;
    type = "del";
  }
  return {
    type,
    min: min5
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist3 = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist3[i] = [];
    dist3[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist3[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual2(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist3[i - 1][j].min + 1;
      var add6 = dist3[i][j - 1].min + 1;
      var modify = dist3[i - 1][j - 1].min + temp;
      dist3[i][j] = getMinDiff(del, add6, modify);
    }
  }
  return dist3;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min5 = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min5) {
          min5 = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index = minPos;
      if (diffMatrix[i][index].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff2; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points2, former, count2) {
  var result2 = [].concat(points2);
  var index;
  var t = 1 / (count2 + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count2; i++) {
    t *= i;
    index = Math.floor(points2.length * t);
    if (index === 0) {
      result2.unshift([formerEnd[0] * t + points2[index][0] * (1 - t), formerEnd[1] * t + points2[index][1] * (1 - t)]);
    } else {
      result2.splice(index, 0, [
        formerEnd[0] * t + points2[index][0] * (1 - t),
        formerEnd[1] * t + points2[index][1] * (1 - t)
      ]);
    }
  }
  return result2;
}
function _getSegmentPoints(segment) {
  var points2 = [];
  switch (segment[0]) {
    case "M":
      points2.push([segment[1], segment[2]]);
      break;
    case "L":
      points2.push([segment[1], segment[2]]);
      break;
    case "A":
      points2.push([segment[6], segment[7]]);
      break;
    case "Q":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "T":
      points2.push([segment[1], segment[2]]);
      break;
    case "C":
      points2.push([segment[5], segment[6]]);
      points2.push([segment[1], segment[2]]);
      points2.push([segment[3], segment[4]]);
      break;
    case "S":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "H":
      points2.push([segment[1], segment[1]]);
      break;
    case "V":
      points2.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points2;
}
var formatPath = function(fromPath, toPath2) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points2;
  for (var i = 0; i < toPath2.length; i++) {
    if (fromPath[i][0] !== toPath2[i][0]) {
      points2 = _getSegmentPoints(fromPath[i]);
      switch (toPath2[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points2[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points2[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath2[i]);
          fromPath[i][6] = points2[0][0];
          fromPath[i][7] = points2[0][1];
          break;
        case "Q":
          if (points2.length < 2) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath2[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points2[0]);
          break;
        case "C":
          if (points2.length < 3) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath2[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points2.length < 2) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath2[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath2[i];
      }
    }
  }
  return fromPath;
};

// node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = (
  /** @class */
  function() {
    function GraphEvent2(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent2.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent2.prototype.save = function() {
    };
    GraphEvent2.prototype.restore = function() {
    };
    return GraphEvent2;
  }()
);
var graph_event_default = GraphEvent;

// node_modules/@antv/g-base/esm/util/util.js
function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent2 = shape.getParent();
  var isParent2 = false;
  while (parent2) {
    if (parent2 === container) {
      isParent2 = true;
      break;
    }
    parent2 = parent2.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// node_modules/@antv/g-base/esm/abstract/base.js
var Base2 = (
  /** @class */
  function(_super) {
    __extends(Base3, _super);
    function Base3(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base3.prototype.getDefaultCfg = function() {
      return {};
    };
    Base3.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base3.prototype.set = function(name, value2) {
      this.cfg[name] = value2;
    };
    Base3.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base3;
  }(esm_default)
);
var base_default2 = Base2;

// node_modules/detect-browser/es/index.js
var __spreadArray2 = function(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version4, os) {
      this.name = name;
      this.version = version4;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version4) {
      this.version = version4;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version4, os, bot) {
      this.name = name;
      this.version = version4;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a6) {
    var browser2 = _a6[0], regex = _a6[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray2(__spreadArray2([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version4 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version4, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version4, os);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a6 = operatingSystemRules[ii], os = _a6[0], regex = _a6[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output2 = [];
  for (var ii = 0; ii < count2; ii++) {
    output2.push("0");
  }
  return output2;
}

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b02 = b[0], b12 = b[1], b22 = b[2], b32 = b[3], b42 = b[4], b52 = b[5], b62 = b[6], b72 = b[7], b82 = b[8];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len3 = x * x + y * y + z * z;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  out[2] = a[2] * len3;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b02 = b[0], b12 = b[1], b22 = b[2];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create2();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len3 = x * x + y * y + z * z + w * w;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = x * len3;
  out[1] = y * len3;
  out[2] = z * len3;
  out[3] = w * len3;
  return out;
}
var forEach2 = function() {
  var vec = create3();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis22, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis22[0];
  out[1] = s * axis22[1];
  out[2] = s * axis22[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize3 = normalize2;
var rotationTo = function() {
  var tmpvec3 = create2();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a, b) {
    var dot7 = dot(a, b);
    if (dot7 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot7 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot7;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create4();
  var temp2 = create4();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add4,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create5,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length4,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random2,
  rotate: () => rotate2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create5() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues4(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set4(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len3 = x * x + y * y;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross2(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp3(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random2(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale8;
  out[1] = Math.sin(r) * scale8;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate2(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str3(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1];
  var b02 = b[0], b12 = b[1];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
}
var len2 = length4;
var sub3 = subtract3;
var mul3 = multiply3;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen2 = squaredLength4;
var forEach3 = function() {
  var vec = create5();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@antv/matrix-util/esm/ext.js
var ext_exports = {};
__export(ext_exports, {
  angleTo: () => angleTo,
  direction: () => direction,
  leftRotate: () => leftRotate,
  leftScale: () => leftScale,
  leftTranslate: () => leftTranslate,
  transform: () => transform,
  vertical: () => vertical
});
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v);
  return mat3_exports.multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v);
  return mat3_exports.multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
  return mat3_exports.multiply(out, a1, a);
}
function transform(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i = 0, len3 = actions.length; i < len3; i++) {
    var action = actions[i];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical(out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }
  return out;
}

// node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert2(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// node_modules/@antv/g-base/esm/abstract/element.js
var transform2 = ext_exports.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD2 = "*";
function _cloneArrayAttr(arr) {
  var result2 = [];
  for (var i = 0; i < arr.length; i++) {
    if (is_array_default(arr[i])) {
      result2.push([].concat(arr[i]));
    } else {
      result2.push(arr[i]);
    }
  }
  return result2;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation7) {
  if (animation7.onFrame) {
    return animations;
  }
  var startTime = animation7.startTime, delay2 = animation7.delay, duration = animation7.duration;
  var hasOwnProperty29 = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay2 < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation7.toAttrs, function(v, k) {
        if (hasOwnProperty29.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element2 = (
  /** @class */
  function(_super) {
    __extends(Element4, _super);
    function Element4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element4.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element4.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element4.prototype.onCanvasChange = function(changeType) {
    };
    Element4.prototype.initAttrs = function(attrs) {
    };
    Element4.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element4.prototype.isGroup = function() {
      return false;
    };
    Element4.prototype.getParent = function() {
      return this.get("parent");
    };
    Element4.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element4.prototype.attr = function() {
      var _a6;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value2 = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value2);
        this.afterAttrsChange((_a6 = {}, _a6[name] = value2, _a6));
        return this;
      }
      return this.attrs[name];
    };
    Element4.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element4.prototype.setAttr = function(name, value2) {
      var originValue = this.attrs[name];
      if (originValue !== value2) {
        this.attrs[name] = value2;
        this.onAttrChange(name, value2, originValue);
      }
    };
    Element4.prototype.onAttrChange = function(name, value2, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element4.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element4.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element4.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element4.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent2 = this.getParent();
      if (parent2) {
        parent2.sort();
      }
      return this;
    };
    Element4.prototype.toFront = function() {
      var parent2 = this.getParent();
      if (!parent2) {
        return;
      }
      var children = parent2.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element4.prototype.toBack = function() {
      var parent2 = this.getParent();
      if (!parent2) {
        return;
      }
      var children = parent2.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element4.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent2 = this.getParent();
      if (parent2) {
        removeFromArray(parent2.getChildren(), this);
        if (!parent2.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element4.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element4.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element4.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element4.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element4.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element4.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element4.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v);
      }
      return v;
    };
    Element4.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert2(matrix);
        if (invertMatrix) {
          return multiplyVec2(invertMatrix, v);
        }
      }
      return v;
    };
    Element4.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase4 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase4[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element4.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element4.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone7 = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone7.set(cfgName, _this.get(cfgName));
      });
      return clone7;
    };
    Element4.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element4.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element4.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a6 = args[2], easing = _a6 === void 0 ? "easeLinear" : _a6, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay2 = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat2;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat2 = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay2 = animateCfg.delay || 0;
        repeat2 = animateCfg.repeat || repeat2 || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay2 = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation7 = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat: repeat2,
        callback,
        pauseCallback,
        resumeCallback,
        delay: delay2,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation7);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation7);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element4.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation7) {
        if (toEnd) {
          if (animation7.onFrame) {
            _this.attr(animation7.onFrame(1));
          } else {
            _this.attr(animation7.toAttrs);
          }
        }
        if (animation7.callback) {
          animation7.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element4.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation7) {
        animation7._paused = true;
        animation7._pauseTime = pauseTime;
        if (animation7.pauseCallback) {
          animation7.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element4.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation7) {
        animation7.startTime = animation7.startTime + (current - pauseTime);
        animation7._paused = false;
        animation7._pauseTime = null;
        if (animation7.resumeCallback) {
          animation7.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element4.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if (
            //  element  Group  Canvas  isParent
            (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)
          ) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element4.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD2]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element4.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element4.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element4.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotateAtStart = function(rotate5) {
      var _a6 = this.attr(), x = _a6.x, y = _a6.y;
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotateAtPoint = function(x, y, rotate5) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element4;
  }(base_default2)
);
var element_default = Element2;

// node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare2) {
  return function(left2, right2) {
    var result2 = compare2(left2, right2);
    return result2 === 0 ? left2[INDEX] - right2[INDEX] : result2;
  };
}
var Container = (
  /** @class */
  function(_super) {
    __extends(Container2, _super);
    function Container2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container2.prototype.isCanvas = function() {
      return false;
    };
    Container2.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY2 = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a6 = child.getBBox(), childMinX = _a6.minX, childMaxX = _a6.maxX, childMinY = _a6.minY, childMaxY = _a6.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY2) {
            maxY2 = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY2 = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
      return box2;
    };
    Container2.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY2 = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a6 = child.getCanvasBBox(), childMinX = _a6.minX, childMaxX = _a6.maxX, childMinY = _a6.minY, childMaxY = _a6.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY2) {
            maxY2 = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY2 = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
      return box2;
    };
    Container2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container2.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container2.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container2.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase4 = this.getShapeBase();
      var shape = new ShapeBase4[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container2.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            // canvas,
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container2.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container2.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container2.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container2.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container2.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container2.prototype.getChildren = function() {
      return this.get("children");
    };
    Container2.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX] = index;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container2.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container2.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container2.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container2.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container2.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container2.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container2.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container2.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container2.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container2.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container2.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container2.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container2.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container2;
  }(element_default)
);
var container_default = Container;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay2 == null ? 0 : +delay2);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay2, time) {
  var t = new Timer();
  t.restart(callback, delay2, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay2 = now3 - clockLast;
  if (delay2 > pokeDelay)
    clockSkew -= delay2, clockLast = now3;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay2 = time - clockNow;
  if (delay2 > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min5 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s = max5 - min5, l = (max5 + min5) / 2;
  if (s) {
    if (r === max5)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max5)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max5 + min5 : 2 - max5 - min5;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values3) {
  var n = values3.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values3[i], v2 = values3[i + 1], v0 = i > 0 ? values3[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values3[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values3) {
  var n = values3.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values3[(i + n - 1) % n], v1 = values3[i % n], v2 = values3[(i + 1) % n], v3 = values3[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color3 = gamma(y);
  function rgb2(start, end) {
    var r = color3((start = rgb(start)).r, (end = rgb(end)).r), g = color3(start.g, end.g), b = color3(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;
    for (i = 0; i < n; ++i) {
      color3 = rgb(colors[i]);
      r[i] = color3.r || 0;
      g[i] = color3.g || 0;
      b[i] = color3.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color3.opacity = 1;
    return function(t) {
      color3.r = r(t);
      color3.g = g(t);
      color3.b = b(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero3(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero3(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m.isIdentity ? identity3 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity3;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity3;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate3(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate5(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale8(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate3(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate5(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale8(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-ease/src/index.js
var src_exports = {};
__export(src_exports, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// node_modules/d3-ease/src/linear.js
function linear2(t) {
  return +t;
}

// node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/exp.js
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

// node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports[type];
}
function registerEasing(type, easeFn) {
  EASING_MAP[type.toLowerCase()] = easeFn;
}

// node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation7, ratio) {
  var cProps = {};
  var fromAttrs = animation7.fromAttrs, toAttrs = animation7.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath2 = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath2.length > fromPath.length) {
          toPath2 = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = fillPathByDiff(fromPath, toPath2);
          fromPath = formatPath(fromPath, toPath2);
          animation7.fromAttrs.path = fromPath;
          animation7.toAttrs.path = toPath2;
        } else if (!animation7.pathFormatted) {
          toPath2 = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = formatPath(fromPath, toPath2);
          animation7.fromAttrs.path = fromPath;
          animation7.toAttrs.path = toPath2;
          animation7.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath2.length; i++) {
          var toPathPoint = toPath2[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
              interf = value_default(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!is_function_default(toAttrs[k])) {
        interf = value_default(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation7, elapsed) {
  var startTime = animation7.startTime, delay2 = animation7.delay;
  if (elapsed < startTime + delay2 || animation7._paused) {
    return false;
  }
  var ratio;
  var duration = animation7.duration;
  var easing = animation7.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation7.delay;
  if (animation7.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation7.onFrame) {
        shape.attr(animation7.onFrame(1));
      } else {
        shape.attr(animation7.toAttrs);
      }
      return true;
    }
  }
  if (animation7.onFrame) {
    var attrs = animation7.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation7, ratio);
  }
  return false;
}
var Timeline = (
  /** @class */
  function() {
    function Timeline2(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline2.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation7;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation7 = animations[j];
                isFinished = update(shape, animation7, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation7.callback) {
                    animation7.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline2.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline2.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline2.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline2.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline2.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline2.prototype.getTime = function() {
      return this.current;
    };
    return Timeline2;
  }()
);
var timeline_default = Timeline;

// node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = (
  /** @class */
  function() {
    function EventController2(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController2.prototype.init = function() {
      this._bindEvents();
    };
    EventController2.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._getEventObj = function(type, event, point2, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point2.x;
      eventObj.y = point2.y;
      eventObj.clientX = point2.clientX;
      eventObj.clientY = point2.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController2.prototype._getShape = function(point2, ev) {
      return this.canvas.getShape(point2.x, point2.y, ev);
    };
    EventController2.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point2 = canvas.getPointByEvent(ev);
      return {
        x: point2.x,
        y: point2.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController2.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method2 = this["_on" + type];
      var leaveCanvas = false;
      if (method2) {
        method2.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController2.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now3 = event.timeStamp;
          var timeWindow = now3 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist3 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist3 > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController2.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController2;
  }()
);
var event_contoller_default = EventController;

// node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas4.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas4.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas4.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas4.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas4.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas4.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas4.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas4.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas4.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a6 = this.getClientByEvent(ev), clientX = _a6.x, clientY = _a6.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas4.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas4.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas4.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas4.prototype.draw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas4.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas4.prototype.isCanvas = function() {
      return true;
    };
    Canvas4.prototype.getParent = function() {
      return null;
    };
    Canvas4.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas4;
  }(container_default)
);
var canvas_default = Canvas;

// node_modules/@antv/g-base/esm/abstract/group.js
var AbstractGroup = (
  /** @class */
  function(_super) {
    __extends(AbstractGroup2, _super);
    function AbstractGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup2.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup2.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup2.prototype.clone = function() {
      var clone7 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone7.add(child.clone());
      }
      return clone7;
    };
    return AbstractGroup2;
  }(container_default)
);
var group_default2 = AbstractGroup;

// node_modules/@antv/g-base/esm/abstract/shape.js
var AbstractShape = (
  /** @class */
  function(_super) {
    __extends(AbstractShape2, _super);
    function AbstractShape2(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape2.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape2.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape2.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape2.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY2 = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a6 = attrs.shadowBlur, shadowBlur = _a6 === void 0 ? 0 : _a6, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY2 + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY2 = Math.max(maxY2, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
    };
    AbstractShape2.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape2.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape2.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape2.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape2;
  }(element_default)
);
var shape_default = AbstractShape;

// node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method2) {
  cache.set(type, method2);
}
function getMethod(type) {
  return cache.get(type);
}

// node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}

// node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a6 = shape.attr(), x = _a6.x, y = _a6.y, r = _a6.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}

// node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance3,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
function distance3(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY2 = max_default(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: min_default([x1, x2]),
    maxX: max_default([x1, x2]),
    minY: min_default([y1, y2]),
    maxY: max_default([y1, y2])
  };
}
function piMod(angle4) {
  return (angle4 + Math.PI * 2) % (Math.PI * 2);
}

// node_modules/@antv/g-math/esm/line.js
var line_default = {
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {object} 
   */
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  length: function(x1, y1, x2, y2) {
    return distance3(x1, y1, x2, y2);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} t 
   * @return {object}  x, y 
   */
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointDistance: function(x1, y1, x2, y2, x, y) {
    var cross3 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross3 < 0) {
      return distance3(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross3 > lengthSquare) {
      return distance3(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointToLine: function(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals4(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    normalize4(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(dot4(a, u));
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};

// node_modules/@antv/g-math/esm/bezier.js
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length5) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval3 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count2 = xArr.length;
    return {
      x: xArr[count2 - 1],
      y: yArr[count2 - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval3 < EPSILON2) {
      break;
    }
    var prev = t - interval3;
    var next = t + interval3;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance3(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval3 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count2 = xArr.length;
  for (var i = 0; i < count2; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count2];
    var nextY = yArr[(i + 1) % count2];
    totalLength += distance3(x, y, nextX, nextY);
  }
  return totalLength / 2;
}

// node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance3(x1, y1, x2, y2) + distance3(x2, y2, x3, y3) + distance3(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left2 = quadratics[0];
  var right2 = quadratics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return quadraticLength.apply(null, left2) + quadraticLength.apply(null, right2);
}
var quadratic_default = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance3(point2.x, point2.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle4 = Math.atan2(dy, dx);
    return piMod(angle4);
  }
};

// node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line_default.pointAt(x1, y1, x2, y2, t);
  var c2 = line_default.pointAt(x2, y2, x3, y3, t);
  var c3 = line_default.pointAt(x3, y3, x4, y4, t);
  var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left2 = cubics[0];
  var right2 = cubics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return cubicLength.apply(null, left2) + cubicLength.apply(null, right2);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x2, x3, x4);
    var yExtrema2 = extrema2(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length5);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5);
    return distance3(point2.x, point2.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt2(x1, x2, x3, x4, t);
    var dy = derivativeAt2(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {object} 
   */
  box: function(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {number} 
   */
  length: function(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {object} 
   */
  nearestPoint: function(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {number} 
   */
  pointDistance: function(x, y, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t x 0
   * @return {object} 
   */
  pointAt: function(x, y, rx, ry, t) {
    var angle4 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle4),
      y: y + ry * Math.sin(angle4)
    };
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t  0 - 1 x 0 0-1  null
   * @return {number}  0 - 2PI 
   */
  tangentAngle: function(x, y, rx, ry, t) {
    var angle4 = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle4), -rx * Math.sin(angle4));
    return piMod(tangentAngle);
  }
};

// node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle4) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle4) - ry * Math.sin(xRotation) * Math.cos(angle4);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle4) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle4) + ry * Math.cos(xRotation) * Math.cos(angle4);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
}
function getAngle(rx, ry, x0, y0) {
  var angle4 = Math.atan2(y0 * rx, x0 * ry);
  return (angle4 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle4) {
  return {
    x: rx * Math.cos(angle4),
    y: ry * Math.sin(angle4)
  };
}
function rotate3(x, y, angle4) {
  var cos2 = Math.cos(angle4);
  var sin2 = Math.sin(angle4);
  return [x * cos2 - y * sin2, x * sin2 + y * cos2];
}
var arc_default = {
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @return {object} 
   */
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY2 = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY2) {
        maxY2 = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  },
  /**
   * 
   *  rx, ry, startAngle, endAngle 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   */
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @param {number} x0          x
   * @param {number} y0          y
   * @return {object} 
   */
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle4 = getAngle(rx, ry, relativePoint.x, relativePoint.y);
    if (angle4 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle4 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle4 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle4),
      y: yAt(cx, cy, rx, ry, xRotation, angle4)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle4 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle4);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle4);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points2) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points2.length - 1; i++) {
    var from = points2[i];
    var to = points2[i + 1];
    var length_1 = distance3(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points2) {
  if (points2.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points2.length - 1; i++) {
    var from = points2[i];
    var to = points2[i + 1];
    totalLength += distance3(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points2, t) {
  if (t > 1 || t < 0 || points2.length < 2) {
    return null;
  }
  var _a6 = analyzePoints(points2), segments = _a6.segments, totalLength = _a6.totalLength;
  if (totalLength === 0) {
    return {
      x: points2[0][0],
      y: points2[0][1]
    };
  }
  var startRatio = 0;
  var point2 = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point2 = line_default.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point2;
}
function angleAtSegments(points2, t) {
  if (t > 1 || t < 0 || points2.length < 2) {
    return 0;
  }
  var _a6 = analyzePoints(points2), segments = _a6.segments, totalLength = _a6.totalLength;
  var startRatio = 0;
  var angle4 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle4;
}
function distanceAtSegment(points2, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points2.length - 1; i++) {
    var point2 = points2[i];
    var nextPoint = points2[i + 1];
    var distance_1 = line_default.pointDistance(point2[0], point2[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  box: function(points2) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points2.length; i++) {
      var point2 = points2[i];
      xArr.push(point2[0]);
      yArr.push(point2[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  length: function(points2) {
    return lengthOfSegment(points2);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  pointAt: function(points2, t) {
    return pointAtSegments(points2, t);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} x  x
   * @param {number} y  y
   * @return {number} 
   */
  pointDistance: function(points2, x, y) {
    return distanceAtSegment(points2, x, y);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  tangentAngle: function(points2, t) {
    return angleAtSegments(points2, t);
  }
};

// node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a6 = util_exports.getBBoxByArray(xArr, yArr), x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (is_nil_default(text) || text === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}

// node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize, lineHeight);
    var point2 = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width;
      } else if (textAlign === "center") {
        point2.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width,
      height
    };
  }
  return bbox;
}

// node_modules/@antv/path-util/esm/parse-path.js
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path = p || [];
  if (is_array_default(path)) {
    return path;
  }
  if (is_string_default(path)) {
    path = path.match(regexTags);
    each_default(path, function(item, index) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each_default(item, function(sub4, i) {
        if (!isNaN(sub4)) {
          item[i] = +sub4;
        }
      });
      path[index] = item;
    });
    return path;
  }
}
var parse_path_default = parsePath;

// node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min5;
  var max5;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min5 = constraint[0], max5 = constraint[1];
    for (var i = 0, l = points2.length; i < l; i += 1) {
      var point2 = points2[i];
      min5 = vec2_exports.min([0, 0], min5, point2);
      max5 = vec2_exports.max([0, 0], max5, point2);
    }
  }
  for (var i = 0, len3 = points2.length; i < len3; i += 1) {
    var point2 = points2[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len3 - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len3 - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points2[prevIdx];
      nextPoint = points2[isLoop ? (i + 1) % len3 : i + 1];
      var v = [0, 0];
      v = vec2_exports.sub(v, nextPoint, prevPoint);
      v = vec2_exports.scale(v, v, smooth);
      var d0 = vec2_exports.distance(point2, prevPoint);
      var d1 = vec2_exports.distance(point2, nextPoint);
      var sum2 = d0 + d1;
      if (sum2 !== 0) {
        d0 /= sum2;
        d1 /= sum2;
      }
      var v1 = vec2_exports.scale([0, 0], v, -d0);
      var v2 = vec2_exports.scale([0, 0], v, d1);
      cp1 = vec2_exports.add([0, 0], point2, v1);
      nextCp0 = vec2_exports.add([0, 0], point2, v2);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point2));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point2));
      v1 = vec2_exports.sub([0, 0], nextCp0, point2);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point2, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point2));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point2));
      v2 = vec2_exports.sub([0, 0], point2, cp1);
      v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min5);
        cp1 = vec2_exports.min([0, 0], cp1, max5);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min5);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max5);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len3 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len3 - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len3];
    cp2 = controlPointList[len3 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

// node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES2 = "	\n\v\f\r \u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
function parsePathString2(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data3 = [];
  String(pathString).replace(PATH_COMMAND2, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES2, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data3.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data3.push([b, params[0]]);
    }
    if (name === "r") {
      data3.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data3.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data3;
}

// node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
  return [
    c[0] + (c[0] - p[0]),
    c[1] + (c[1] - p[1])
  ];
}
function pathToAbsolute2(pathString) {
  var pathArray = parsePathString2(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1];
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      r = pathArray[i];
    }
    switch (upCmd) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        r = ["L", x, y];
        break;
      case "V":
        y = r[1];
        r = ["L", x, y];
        break;
      case "T":
        x = r[1];
        y = r[2];
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ["Q", symetricT[0], symetricT[1], x, y];
        break;
      case "S":
        x = r[r.length - 2];
        y = r[r.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}

// node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// node_modules/@antv/path-util/esm/get-arc-params.js
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry2(point2, center2) {
  return [center2[0] + (center2[0] - point2[0]), center2[1] + (center2[1] - point2[1])];
}
function getSegments(path) {
  path = parse_path_default(path);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count2 = path.length;
  for (var i = 0; i < count2; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len3 = params.length;
      currentPoint = [params[len3 - 2], params[len3 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry2(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a6 = segment["arcParams"] || {}, _b = _a6.cx, cx = _b === void 0 ? 0 : _b, _c = _a6.cy, cy = _c === void 0 ? 0 : _c, _d = _a6.rx, rx = _d === void 0 ? 0 : _d, _e = _a6.ry, ry = _e === void 0 ? 0 : _e, _f = _a6.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a6.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a6.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// node_modules/@antv/path-util/esm/get-line-intersect.js
var isBetween = function(value2, min5, max5) {
  return value2 >= min5 && value2 <= max5;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance3 = 1e-3;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point2 = null;
  if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
    var s = (E2.x * D1.y - E2.y * D1.x) / kross;
    var t = (E2.x * D0.y - E2.y * D0.x) / kross;
    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
      point2 = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point2;
}

// node_modules/@antv/path-util/esm/point-in-polygon.js
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points2, x, y) {
  var isHit = false;
  var n = points2.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points2[i];
    var p2 = points2[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/path-util/esm/is-polygons-intersect.js
function parseToLines(points2) {
  var lines = [];
  var count2 = points2.length;
  for (var i = 0; i < count2 - 1; i++) {
    var point2 = points2[i];
    var next = points2[i + 1];
    lines.push({
      from: {
        x: point2[0],
        y: point2[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points2[0];
    var last3 = points2[count2 - 1];
    lines.push({
      from: {
        x: last3[0],
        y: last3[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line2) {
  var isIntersect = false;
  each_default(lines, function(l) {
    if (getLineIntersect(l.from, l.to, line2.from, line2.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox(points2) {
  var xArr = points2.map(function(p) {
    return p[0];
  });
  var yArr = points2.map(function(p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point2) {
    if (isInPolygon(points1, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point2) {
    if (isInPolygon(points2, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each_default(lines2, function(line2) {
    if (lineIntersectPolygon(lines1, line2)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}

// node_modules/@antv/g-base/esm/bbox/path.js
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY2 = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY2 = maxY2 + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default(shape) {
  var attrs = shape.attr();
  var path = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path);
  var _a6 = getPathBox(segments, lineWidth), x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/line.js
function line_default2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY: maxY2
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default);
register("line", line_default2);
register("ellipse", ellipse_default2);

// node_modules/@antv/adjust/esm/constant.js
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = 0.05;

// node_modules/@antv/adjust/esm/adjusts/adjust.js
var Adjust = (
  /** @class */
  function() {
    function Adjust2(cfg) {
      var xField = cfg.xField, yField = cfg.yField, _a6 = cfg.adjustNames, adjustNames = _a6 === void 0 ? ["x", "y"] : _a6, dimValuesMap = cfg.dimValuesMap;
      this.adjustNames = adjustNames;
      this.xField = xField;
      this.yField = yField;
      this.dimValuesMap = dimValuesMap;
    }
    Adjust2.prototype.isAdjust = function(dim) {
      return this.adjustNames.indexOf(dim) >= 0;
    };
    Adjust2.prototype.getAdjustRange = function(dim, dimValue, values3) {
      var yField = this.yField;
      var index = values3.indexOf(dimValue);
      var length5 = values3.length;
      var pre;
      var next;
      if (!yField && this.isAdjust("y")) {
        pre = 0;
        next = 1;
      } else if (length5 > 1) {
        pre = values3[index === 0 ? 0 : index - 1];
        next = values3[index === length5 - 1 ? length5 - 1 : index + 1];
        if (index !== 0) {
          pre += (dimValue - pre) / 2;
        } else {
          pre -= (next - dimValue) / 2;
        }
        if (index !== length5 - 1) {
          next -= (next - dimValue) / 2;
        } else {
          next += (dimValue - values3[length5 - 2]) / 2;
        }
      } else {
        pre = dimValue === 0 ? 0 : dimValue - 0.5;
        next = dimValue === 0 ? 1 : dimValue + 0.5;
      }
      return {
        pre,
        next
      };
    };
    Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
      var _this = this;
      var dimValuesMap = this.getDimValues(mergedData);
      each_default(groupedDataArray, function(dataArray, index) {
        each_default(dimValuesMap, function(values3, dim) {
          _this.adjustDim(dim, values3, dataArray, index);
        });
      });
    };
    Adjust2.prototype.groupData = function(data3, dim) {
      each_default(data3, function(record) {
        if (record[dim] === void 0) {
          record[dim] = DEFAULT_Y;
        }
      });
      return group_by_default(data3, dim);
    };
    Adjust2.prototype.adjustDim = function(dim, values3, data3, index) {
    };
    Adjust2.prototype.getDimValues = function(mergedData) {
      var _a6 = this, xField = _a6.xField, yField = _a6.yField;
      var dimValuesMap = mix({}, this.dimValuesMap);
      var dims = [];
      if (xField && this.isAdjust("x")) {
        dims.push(xField);
      }
      if (yField && this.isAdjust("y")) {
        dims.push(yField);
      }
      dims.forEach(function(dim2) {
        if (dimValuesMap && dimValuesMap[dim2]) {
          return;
        }
        dimValuesMap[dim2] = values_of_key_default(mergedData, dim2).sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      if (!yField && this.isAdjust("y")) {
        var dim = "y";
        dimValuesMap[dim] = [DEFAULT_Y, 1];
      }
      return dimValuesMap;
    };
    return Adjust2;
  }()
);
var adjust_default = Adjust;

// node_modules/@antv/adjust/esm/factory.js
var ADJUST_MAP = {};
var getAdjust = function(type) {
  return ADJUST_MAP[type.toLowerCase()];
};
var registerAdjust = function(type, ctor) {
  if (getAdjust(type)) {
    throw new Error("Adjust type '" + type + "' existed.");
  }
  ADJUST_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/adjust/node_modules/tslib/tslib.es6.js
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (b10.hasOwnProperty(p))
        d2[p] = b10[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};

// node_modules/@antv/adjust/esm/adjusts/dodge.js
var Dodge = (
  /** @class */
  function(_super) {
    __extends2(Dodge2, _super);
    function Dodge2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.cacheMap = {};
      _this.adjustDataArray = [];
      _this.mergeData = [];
      var _a6 = cfg.marginRatio, marginRatio = _a6 === void 0 ? MARGIN_RATIO : _a6, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
      _this.marginRatio = marginRatio;
      _this.dodgeRatio = dodgeRatio;
      _this.dodgeBy = dodgeBy;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.xDimensionLegenth = xDimensionLength;
      _this.groupNum = groupNum;
      _this.defaultSize = defaultSize;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.customOffset = customOffset;
      return _this;
    }
    Dodge2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData2 = flatten_default(groupedDataArray);
      var dodgeBy = this.dodgeBy;
      var adjustDataArray = dodgeBy ? group_default(mergeData2, dodgeBy) : groupedDataArray;
      this.cacheMap = {};
      this.adjustDataArray = adjustDataArray;
      this.mergeData = mergeData2;
      this.adjustData(adjustDataArray, mergeData2);
      this.adjustDataArray = [];
      this.mergeData = [];
      return groupedDataArray;
    };
    Dodge2.prototype.adjustDim = function(dim, values3, data3, frameIndex) {
      var _this = this;
      var customOffset = this.customOffset;
      var map5 = this.getDistribution(dim);
      var groupData = this.groupData(data3, dim);
      each_default(groupData, function(group2, key) {
        var range2;
        if (values3.length === 1) {
          range2 = {
            pre: values3[0] - 1,
            next: values3[0] + 1
          };
        } else {
          range2 = _this.getAdjustRange(dim, parseFloat(key), values3);
        }
        each_default(group2, function(d) {
          var value2 = d[dim];
          var valueArr = map5[value2];
          var valIndex = valueArr.indexOf(frameIndex);
          if (!is_nil_default(customOffset)) {
            var pre = range2.pre, next = range2.next;
            d[dim] = is_function_default(customOffset) ? customOffset(d, range2) : (pre + next) / 2 + customOffset;
          } else {
            d[dim] = _this.getDodgeOffset(range2, valIndex, valueArr.length);
          }
        });
      });
      return [];
    };
    Dodge2.prototype.getDodgeOffset = function(range2, idx, len3) {
      var _a6 = this, dodgeRatio = _a6.dodgeRatio, marginRatio = _a6.marginRatio, intervalPadding = _a6.intervalPadding, dodgePadding = _a6.dodgePadding;
      var pre = range2.pre, next = range2.next;
      var tickLength = next - pre;
      var position;
      if (!is_nil_default(intervalPadding) && is_nil_default(dodgePadding) && intervalPadding >= 0) {
        var offset = this.getIntervalOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(dodgePadding) && is_nil_default(intervalPadding) && dodgePadding >= 0) {
        var offset = this.getDodgeOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(intervalPadding) && !is_nil_default(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
        var offset = this.getIntervalAndDodgeOffset(len3, idx);
        position = pre + offset;
      } else {
        var width = tickLength * dodgeRatio / len3;
        var margin = marginRatio * width;
        var offset = 1 / 2 * (tickLength - len3 * width - (len3 - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
        position = (pre + next) / 2 + offset;
      }
      return position;
    };
    Dodge2.prototype.getIntervalOnlyOffset = function(len3, idx) {
      var _a6 = this, defaultSize = _a6.defaultSize, intervalPadding = _a6.intervalPadding, xDimensionLegenth = _a6.xDimensionLegenth, groupNum = _a6.groupNum, dodgeRatio = _a6.dodgeRatio, maxColumnWidth = _a6.maxColumnWidth, minColumnWidth = _a6.minColumnWidth, columnWidthRatio = _a6.columnWidthRatio;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len3 - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = !is_nil_default(columnWidthRatio) ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len3 * geomWidth) / (len3 - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDodgeOnlyOffset = function(len3, idx) {
      var _a6 = this, defaultSize = _a6.defaultSize, dodgePadding = _a6.dodgePadding, xDimensionLegenth = _a6.xDimensionLegenth, groupNum = _a6.groupNum, marginRatio = _a6.marginRatio, maxColumnWidth = _a6.maxColumnWidth, minColumnWidth = _a6.minColumnWidth, columnWidthRatio = _a6.columnWidthRatio;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = columnWidthRatio ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedIntervalPadding = (1 - (geomWidth * len3 + normalizedDodgePadding * (len3 - 1)) * groupNum) / (groupNum - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getIntervalAndDodgeOffset = function(len3, idx) {
      var _a6 = this, intervalPadding = _a6.intervalPadding, dodgePadding = _a6.dodgePadding, xDimensionLegenth = _a6.xDimensionLegenth, groupNum = _a6.groupNum;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDistribution = function(dim) {
      var groupedDataArray = this.adjustDataArray;
      var cacheMap = this.cacheMap;
      var map5 = cacheMap[dim];
      if (!map5) {
        map5 = {};
        each_default(groupedDataArray, function(data3, index) {
          var values3 = values_of_key_default(data3, dim);
          if (!values3.length) {
            values3.push(0);
          }
          each_default(values3, function(val) {
            if (!map5[val]) {
              map5[val] = [];
            }
            map5[val].push(index);
          });
        });
        cacheMap[dim] = map5;
      }
      return map5;
    };
    return Dodge2;
  }(adjust_default)
);
var dodge_default = Dodge;

// node_modules/@antv/adjust/esm/adjusts/jitter.js
function randomNumber(min5, max5) {
  return (max5 - min5) * Math.random() + min5;
}
var Jitter = (
  /** @class */
  function(_super) {
    __extends2(Jitter2, _super);
    function Jitter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Jitter2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData2 = flatten_default(groupedDataArray);
      this.adjustData(groupedDataArray, mergeData2);
      return groupedDataArray;
    };
    Jitter2.prototype.adjustDim = function(dim, values3, dataArray) {
      var _this = this;
      var groupDataArray = this.groupData(dataArray, dim);
      return each_default(groupDataArray, function(data3, dimValue) {
        return _this.adjustGroup(data3, dim, parseFloat(dimValue), values3);
      });
    };
    Jitter2.prototype.getAdjustOffset = function(range2) {
      var pre = range2.pre, next = range2.next;
      var margin = (next - pre) * GAP;
      return randomNumber(pre + margin, next - margin);
    };
    Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values3) {
      var _this = this;
      var range2 = this.getAdjustRange(dim, dimValue, values3);
      each_default(group2, function(data3) {
        data3[dim] = _this.getAdjustOffset(range2);
      });
      return group2;
    };
    return Jitter2;
  }(adjust_default)
);
var jitter_default = Jitter;

// node_modules/@antv/adjust/esm/adjusts/stack.js
var Cache = cache_default;
var Stack = (
  /** @class */
  function(_super) {
    __extends2(Stack3, _super);
    function Stack3(cfg) {
      var _this = _super.call(this, cfg) || this;
      var _a6 = cfg.adjustNames, adjustNames = _a6 === void 0 ? ["y"] : _a6, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size3 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
      _this.adjustNames = adjustNames;
      _this.height = height;
      _this.size = size3;
      _this.reverseOrder = reverseOrder;
      return _this;
    }
    Stack3.prototype.process = function(groupDataArray) {
      var _a6 = this, yField = _a6.yField, reverseOrder = _a6.reverseOrder;
      var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
      return reverseOrder ? this.reverse(d) : d;
    };
    Stack3.prototype.reverse = function(groupedDataArray) {
      return groupedDataArray.slice(0).reverse();
    };
    Stack3.prototype.processStack = function(groupDataArray) {
      var _a6 = this, xField = _a6.xField, yField = _a6.yField, reverseOrder = _a6.reverseOrder;
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var positive = new Cache();
      var negative = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data3) {
          var _a7;
          var x = get_default(data3, xField, 0);
          var y = get_default(data3, [yField]);
          var xKey = x.toString();
          y = is_array_default(y) ? y[1] : y;
          if (!is_nil_default(y)) {
            var cache3 = y >= 0 ? positive : negative;
            if (!cache3.has(xKey)) {
              cache3.set(xKey, 0);
            }
            var xValue = cache3.get(xKey);
            var newXValue = y + xValue;
            cache3.set(xKey, newXValue);
            return __assign2(__assign2({}, data3), (_a7 = {}, _a7[yField] = [xValue, newXValue], _a7));
          }
          return data3;
        });
      });
    };
    Stack3.prototype.processOneDimStack = function(groupDataArray) {
      var _this = this;
      var _a6 = this, xField = _a6.xField, height = _a6.height, reverseOrder = _a6.reverseOrder;
      var yField = "y";
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var cache3 = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data3) {
          var _a7;
          var size3 = _this.size;
          var xValue = data3[xField];
          var stackHeight = size3 * 2 / height;
          if (!cache3.has(xValue)) {
            cache3.set(xValue, stackHeight / 2);
          }
          var stackValue = cache3.get(xValue);
          cache3.set(xValue, stackValue + stackHeight);
          return __assign2(__assign2({}, data3), (_a7 = {}, _a7[yField] = stackValue, _a7));
        });
      });
    };
    return Stack3;
  }(adjust_default)
);
var stack_default = Stack;

// node_modules/@antv/adjust/esm/adjusts/symmetric.js
var Symmetric = (
  /** @class */
  function(_super) {
    __extends2(Symmetric2, _super);
    function Symmetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Symmetric2.prototype.process = function(groupDataArray) {
      var mergeData2 = flatten_default(groupDataArray);
      var _a6 = this, xField = _a6.xField, yField = _a6.yField;
      var cache3 = this.getXValuesMaxMap(mergeData2);
      var max5 = Math.max.apply(Math, Object.keys(cache3).map(function(key) {
        return cache3[key];
      }));
      return map_default(groupDataArray, function(dataArray) {
        return map_default(dataArray, function(data3) {
          var _a7, _b;
          var yValue = data3[yField];
          var xValue = data3[xField];
          if (is_array_default(yValue)) {
            var off_1 = (max5 - cache3[xValue]) / 2;
            return __assign2(__assign2({}, data3), (_a7 = {}, _a7[yField] = map_default(yValue, function(y) {
              return off_1 + y;
            }), _a7));
          }
          var offset = (max5 - yValue) / 2;
          return __assign2(__assign2({}, data3), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
        });
      });
    };
    Symmetric2.prototype.getXValuesMaxMap = function(mergeData2) {
      var _this = this;
      var _a6 = this, xField = _a6.xField, yField = _a6.yField;
      var groupDataArray = group_by_default(mergeData2, function(data3) {
        return data3[xField];
      });
      return map_values_default(groupDataArray, function(dataArray) {
        return _this.getDimMaxValue(dataArray, yField);
      });
    };
    Symmetric2.prototype.getDimMaxValue = function(mergeData2, dim) {
      var dimValues = map_default(mergeData2, function(data3) {
        return get_default(data3, dim, []);
      });
      var flattenValues = flatten_default(dimValues);
      return Math.max.apply(Math, flattenValues);
    };
    return Symmetric2;
  }(adjust_default)
);
var symmetric_default = Symmetric;

// node_modules/@antv/adjust/esm/index.js
registerAdjust("Dodge", dodge_default);
registerAdjust("Jitter", jitter_default);
registerAdjust("Stack", stack_default);
registerAdjust("Symmetric", symmetric_default);

// node_modules/@antv/attr/esm/attributes/base.js
var toScaleString = function(scale8, value2) {
  if (is_string_default(value2)) {
    return value2;
  }
  return scale8.invert(scale8.scale(value2));
};
var Attribute = (
  /** @class */
  function() {
    function Attribute2(cfg) {
      this.names = [];
      this.scales = [];
      this.linear = false;
      this.values = [];
      this.callback = function() {
        return [];
      };
      this._parseCfg(cfg);
    }
    Attribute2.prototype.mapping = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      var values3 = params.map(function(param, idx) {
        return _this._toOriginParam(param, _this.scales[idx]);
      });
      return this.callback.apply(this, values3);
    };
    Attribute2.prototype.getLinearValue = function(percent2) {
      var steps = this.values.length - 1;
      var step = Math.floor(steps * percent2);
      var leftPercent = steps * percent2 - step;
      var start = this.values[step];
      var end = step === steps ? start : this.values[step + 1];
      return start + (end - start) * leftPercent;
    };
    Attribute2.prototype.getNames = function() {
      var scales = this.scales;
      var names = this.names;
      var length5 = Math.min(scales.length, names.length);
      var rst = [];
      for (var i = 0; i < length5; i += 1) {
        rst.push(names[i]);
      }
      return rst;
    };
    Attribute2.prototype.getFields = function() {
      return this.scales.map(function(scale8) {
        return scale8.field;
      });
    };
    Attribute2.prototype.getScale = function(name) {
      return this.scales[this.names.indexOf(name)];
    };
    Attribute2.prototype.defaultCallback = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 0) {
        return this.values;
      }
      return params.map(function(param, idx) {
        var scale8 = _this.scales[idx];
        return scale8.type === "identity" ? scale8.values[0] : _this._getAttributeValue(scale8, param);
      });
    };
    Attribute2.prototype._parseCfg = function(cfg) {
      var _this = this;
      var _a6 = cfg.type, type = _a6 === void 0 ? "base" : _a6, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values3 = _d === void 0 ? [] : _d, callback = cfg.callback;
      this.type = type;
      this.scales = scales;
      this.values = values3;
      this.names = names;
      this.callback = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        if (callback) {
          var ret = callback.apply(void 0, params);
          if (!is_nil_default(ret)) {
            return [ret];
          }
        }
        return _this.defaultCallback.apply(_this, params);
      };
    };
    Attribute2.prototype._getAttributeValue = function(scale8, value2) {
      if (scale8.isCategory && !this.linear) {
        var idx = scale8.translate(value2);
        return this.values[idx % this.values.length];
      }
      var percent2 = scale8.scale(value2);
      return this.getLinearValue(percent2);
    };
    Attribute2.prototype._toOriginParam = function(param, scale8) {
      return !scale8.isLinear ? is_array_default(param) ? param.map(function(p) {
        return toScaleString(scale8, p);
      }) : toScaleString(scale8, param) : param;
    };
    return Attribute2;
  }()
);
var base_default3 = Attribute;

// node_modules/@antv/color-util/esm/index.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor2 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
  var i = document.createElement("i");
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
};
var getValue = function(start, end, percent2, index) {
  return start[index] + (end[index] - start[index]) * percent2;
};
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str4) {
  return [
    parseInt(str4.substr(1, 2), 16),
    parseInt(str4.substr(3, 2), 16),
    parseInt(str4.substr(5, 2), 16)
  ];
};
var toHex = function(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points2, percent2) {
  var fixedPercent = isNaN(Number(percent2)) || percent2 < 0 ? 0 : percent2 > 1 ? 1 : Number(percent2);
  var steps = points2.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left2 = steps * fixedPercent - step;
  var start = points2[step];
  var end = step === steps ? start : points2[step + 1];
  return arr2rgb([
    getValue(start, end, left2, 0),
    getValue(start, end, left2, 1),
    getValue(start, end, left2, 2)
  ]);
};
var iEl;
var toRGB = function(color3) {
  if (color3[0] === "#" && color3.length === 7) {
    return color3;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color3;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches2 = RGB_REG.exec(rst);
  var cArray = matches2[1].split(/\s*,\s*/).map(function(s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function(colors) {
  var colorArray = is_string_default(colors) ? colors.split("-") : colors;
  var points2 = map_default(colorArray, function(color3) {
    return rgb2arr(color3.indexOf("#") === -1 ? toRGB(color3) : color3);
  });
  return function(percent2) {
    return calColor(points2, percent2);
  };
};
var toCSSGradient = function(gradientColor) {
  if (isGradientColor2(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG.exec(gradientColor);
      var angle4 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle4 + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop);
    each_default(colorStops_1, function(item, index) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
};
var esm_default2 = {
  rgb2arr,
  gradient,
  toRGB: memoize_default(toRGB),
  toCSSGradient
};

// node_modules/@antv/attr/esm/attributes/color.js
var Color2 = (
  /** @class */
  function(_super) {
    __extends(Color3, _super);
    function Color3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "color";
      _this.names = ["color"];
      if (is_string_default(_this.values)) {
        _this.linear = true;
      }
      _this.gradient = esm_default2.gradient(_this.values);
      return _this;
    }
    Color3.prototype.getLinearValue = function(percent2) {
      return this.gradient(percent2);
    };
    return Color3;
  }(base_default3)
);
var color_default = Color2;

// node_modules/@antv/attr/esm/attributes/opacity.js
var Opacity = (
  /** @class */
  function(_super) {
    __extends(Opacity2, _super);
    function Opacity2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "opacity";
      _this.names = ["opacity"];
      return _this;
    }
    return Opacity2;
  }(base_default3)
);
var opacity_default = Opacity;

// node_modules/@antv/attr/esm/attributes/position.js
var Position = (
  /** @class */
  function(_super) {
    __extends(Position2, _super);
    function Position2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.names = ["x", "y"];
      _this.type = "position";
      return _this;
    }
    Position2.prototype.mapping = function(x, y) {
      var _a6 = this.scales, scaleX = _a6[0], scaleY = _a6[1];
      if (is_nil_default(x) || is_nil_default(y)) {
        return [];
      }
      return [
        is_array_default(x) ? x.map(function(xi) {
          return scaleX.scale(xi);
        }) : scaleX.scale(x),
        is_array_default(y) ? y.map(function(yi) {
          return scaleY.scale(yi);
        }) : scaleY.scale(y)
      ];
    };
    return Position2;
  }(base_default3)
);
var position_default = Position;

// node_modules/@antv/attr/esm/attributes/shape.js
var Shape = (
  /** @class */
  function(_super) {
    __extends(Shape2, _super);
    function Shape2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "shape";
      _this.names = ["shape"];
      return _this;
    }
    Shape2.prototype.getLinearValue = function(percent2) {
      var idx = Math.round((this.values.length - 1) * percent2);
      return this.values[idx];
    };
    return Shape2;
  }(base_default3)
);
var shape_default2 = Shape;

// node_modules/@antv/attr/esm/attributes/size.js
var Size = (
  /** @class */
  function(_super) {
    __extends(Size2, _super);
    function Size2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "size";
      _this.names = ["size"];
      return _this;
    }
    return Size2;
  }(base_default3)
);
var size_default = Size;

// node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method2) {
  methodCache[key] = method2;
}

// node_modules/@antv/scale/esm/base.js
var Scale = (
  /** @class */
  function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v) {
      return v;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map_default(this.ticks, function(tick, idx) {
        if (is_object_default(tick)) {
          return tick;
        }
        return {
          text: _this.getText(tick, idx),
          tickValue: tick,
          value: _this.scale(tick)
        };
      });
    };
    Scale2.prototype.getText = function(value2, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value2, key) : value2;
      if (is_nil_default(res) || !is_function_default(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (is_empty_default(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (is_string_default(tickMethod)) {
        var method2 = getTickMethod(tickMethod);
        if (!method2) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method2(this);
      } else if (is_function_default(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value2, min5, max5) {
      if (is_number_default(value2)) {
        return (value2 - min5) / (max5 - min5);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent2, min5, max5) {
      return min5 + percent2 * (max5 - min5);
    };
    return Scale2;
  }()
);
var base_default4 = Scale;

// node_modules/@antv/scale/esm/category/base.js
var Category = (
  /** @class */
  function(_super) {
    __extends(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category3.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = /* @__PURE__ */ new Map();
        for (var i = 0; i < this.values.length; i++) {
          this.translateIndexMap.set(this.values[i], i);
        }
      }
    };
    Category3.prototype.translate = function(value2) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value2);
      if (idx === void 0) {
        idx = is_number_default(value2) ? value2 : NaN;
      }
      return idx;
    };
    Category3.prototype.scale = function(value2) {
      var order = this.translate(value2);
      var percent2 = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent2, this.rangeMin(), this.rangeMax());
    };
    Category3.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent2 = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent2) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category3.prototype.getText = function(value2) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var v = value2;
      if (is_number_default(value2) && !this.values.includes(value2)) {
        v = this.values[v];
      }
      return _super.prototype.getText.apply(this, __spreadArrays([v], args));
    };
    Category3.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category3.prototype.setDomain = function() {
      if (is_nil_default(this.getConfig("min"))) {
        this.min = 0;
      }
      if (is_nil_default(this.getConfig("max"))) {
        var size3 = this.values.length;
        this.max = size3 > 1 ? size3 - 1 : size3;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category3;
  }(base_default4)
);
var base_default5 = Category;

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len3 = arr.length; i < len3; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
      return index;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a6 = 0, args_1 = args; _a6 < args_1.length; _a6++) {
    var obj = args_1[_a6];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str4) {
  return str4.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len3) {
  if (len3 === void 0) {
    len3 = 2;
  }
  val = String(val);
  while (val.length < len3) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now3 = /* @__PURE__ */ new Date();
      var cent = +("" + now3.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = /* @__PURE__ */ new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field7 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field7]) {
      throw new Error("Invalid format. " + field7 + " specified twice in format");
    }
    specifiedFields[field7] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field7) {
    if (!specifiedFields[field7]) {
      throw new Error("Invalid format. " + field7 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches2 = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches2) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches2.length; i++) {
    var _a6 = parseInfo[i - 1], field6 = _a6[0], parser = _a6[2];
    var value2 = parser ? parser(matches2[i], combinedI18nSettings) : +matches2[i];
    if (value2 == null) {
      return null;
    }
    dateInfo[field6] = value2;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len3 = validateFields.length; i < len3; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha_default = fecha;

// node_modules/@antv/scale/esm/util/bisector.js
function bisector_default(getter) {
  return function(a, x, _lo, _hi) {
    var lo = is_nil_default(_lo) ? 0 : _lo;
    var hi = is_nil_default(_hi) ? a.length : _hi;
    while (lo < hi) {
      var mid2 = lo + hi >>> 1;
      if (getter(a[mid2]) > x) {
        hi = mid2;
      } else {
        lo = mid2 + 1;
      }
    }
    return lo;
  };
}

// node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method2 = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
  return method2(time, mask);
}
function toTimeStamp(value2) {
  if (is_string_default(value2)) {
    if (value2.indexOf("T") > 0) {
      value2 = new Date(value2).getTime();
    } else {
      value2 = new Date(value2.replace(/-/gi, "/")).getTime();
    }
  }
  if (is_date_default(value2)) {
    value2 = value2.getTime();
  }
  return value2;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min5, max5, tickCount) {
  var target = (max5 - min5) / tickCount;
  var idx = bisector_default(function(o) {
    return o[1];
  })(intervals, target) - 1;
  var interval3 = intervals[idx];
  if (idx < 0) {
    interval3 = intervals[0];
  } else if (idx >= intervals.length) {
    interval3 = last(intervals);
  }
  return interval3;
}

// node_modules/@antv/scale/esm/category/time.js
var TimeCat = (
  /** @class */
  function(_super) {
    __extends(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value2) {
      value2 = toTimeStamp(value2);
      var index = this.values.indexOf(value2);
      if (index === -1) {
        if (is_number_default(value2) && value2 < this.values.length) {
          index = value2;
        } else {
          index = NaN;
        }
      }
      return index;
    };
    TimeCat2.prototype.getText = function(value2, tickIndex) {
      var index = this.translate(value2);
      if (index > -1) {
        var result2 = this.values[index];
        var formatter = this.formatter;
        result2 = formatter ? formatter(result2, tickIndex) : timeFormat(result2, this.mask);
        return result2;
      }
      return value2;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values3 = this.values;
      each_default(values3, function(v, i) {
        values3[i] = toTimeStamp(v);
      });
      values3.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(base_default5)
);
var time_default = TimeCat;

// node_modules/@antv/scale/esm/continuous/base.js
var Continuous = (
  /** @class */
  function(_super) {
    __extends(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value2) {
      if (is_nil_default(value2)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max5 = this.max;
      var min5 = this.min;
      if (max5 === min5) {
        return rangeMin;
      }
      var percent2 = this.getScalePercent(value2);
      return rangeMin + percent2 * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!is_nil_default(this.minLimit)) {
        this.min = firstTick;
      }
      if (!is_nil_default(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a6 = get_range_default(this.values), min5 = _a6.min, max5 = _a6.max;
      if (is_nil_default(this.min)) {
        this.min = min5;
      }
      if (is_nil_default(this.max)) {
        this.max = max5;
      }
      if (this.min > this.max) {
        this.min = min5;
        this.max = max5;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter_default(ticks, function(tick) {
          return tick >= _this.min && tick <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value2) {
      var max5 = this.max;
      var min5 = this.min;
      return (value2 - min5) / (max5 - min5);
    };
    Continuous2.prototype.getInvertPercent = function(value2) {
      return (value2 - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(base_default4)
);
var base_default6 = Continuous;

// node_modules/@antv/scale/esm/continuous/linear.js
var Linear = (
  /** @class */
  function(_super) {
    __extends(Linear2, _super);
    function Linear2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear2.prototype.invert = function(value2) {
      var percent2 = this.getInvertPercent(value2);
      return this.min + percent2 * (this.max - this.min);
    };
    Linear2.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear2;
  }(base_default6)
);
var linear_default = Linear;

// node_modules/@antv/scale/esm/util/math.js
function calBase(a, b) {
  var e = Math.E;
  var value2;
  if (b >= 0) {
    value2 = Math.pow(e, Math.log(b) / a);
  } else {
    value2 = Math.pow(e, Math.log(-b) / a) * -1;
  }
  return value2;
}
function log(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values3, base, max5) {
  if (is_nil_default(max5)) {
    max5 = Math.max.apply(null, values3);
  }
  var positiveMin = max5;
  each_default(values3, function(value2) {
    if (value2 > 0 && value2 < positiveMin) {
      positiveMin = value2;
    }
  });
  if (positiveMin === max5) {
    positiveMin = max5 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}

// node_modules/@antv/scale/esm/continuous/log.js
var Log = (
  /** @class */
  function(_super) {
    __extends(Log2, _super);
    function Log2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log2.prototype.invert = function(value2) {
      var base = this.base;
      var max5 = log(base, this.max);
      var rangeMin = this.rangeMin();
      var range2 = this.rangeMax() - rangeMin;
      var min5;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value2 === 0) {
          return 0;
        }
        min5 = log(base, positiveMin / base);
        var appendPercent = 1 / (max5 - min5) * range2;
        if (value2 < appendPercent) {
          return value2 / appendPercent * positiveMin;
        }
      } else {
        min5 = log(base, this.min);
      }
      var percent2 = (value2 - rangeMin) / range2;
      var tmp = percent2 * (max5 - min5) + min5;
      return Math.pow(base, tmp);
    };
    Log2.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log2.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min5 = this.min;
      if (min5 < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min5 === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log2.prototype.getScalePercent = function(value2) {
      var max5 = this.max;
      var min5 = this.min;
      if (max5 === min5) {
        return 0;
      }
      if (value2 <= 0) {
        return 0;
      }
      var base = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min5 = positiveMin * 1 / base;
      }
      var percent2;
      if (value2 < positiveMin) {
        percent2 = value2 / positiveMin / (log(base, max5) - log(base, min5));
      } else {
        percent2 = (log(base, value2) - log(base, min5)) / (log(base, max5) - log(base, min5));
      }
      return percent2;
    };
    return Log2;
  }(base_default6)
);
var log_default = Log;

// node_modules/@antv/scale/esm/continuous/pow.js
var Pow = (
  /** @class */
  function(_super) {
    __extends(Pow2, _super);
    function Pow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow2.prototype.invert = function(value2) {
      var percent2 = this.getInvertPercent(value2);
      var exponent2 = this.exponent;
      var max5 = calBase(exponent2, this.max);
      var min5 = calBase(exponent2, this.min);
      var tmp = percent2 * (max5 - min5) + min5;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent2) * factor;
    };
    Pow2.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow2.prototype.getScalePercent = function(value2) {
      var max5 = this.max;
      var min5 = this.min;
      if (max5 === min5) {
        return 0;
      }
      var exponent2 = this.exponent;
      var percent2 = (calBase(exponent2, value2) - calBase(exponent2, min5)) / (calBase(exponent2, max5) - calBase(exponent2, min5));
      return percent2;
    };
    return Pow2;
  }(base_default6)
);
var pow_default = Pow;

// node_modules/@antv/scale/esm/continuous/time.js
var Time = (
  /** @class */
  function(_super) {
    __extends(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value2, index) {
      var numberValue = this.translate(value2);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value2) {
      var v = value2;
      if (is_string_default(v) || is_date_default(v)) {
        v = this.translate(v);
      }
      return _super.prototype.scale.call(this, v);
    };
    Time2.prototype.translate = function(v) {
      return toTimeStamp(v);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values3 = this.values;
      var minConfig = this.getConfig("min");
      var maxConfig = this.getConfig("max");
      if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
        this.min = this.translate(this.min);
      }
      if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
        this.max = this.translate(this.max);
      }
      if (values3 && values3.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each_default(values3, function(v) {
          var timeStamp = toTimeStamp(v);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values3.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (is_nil_default(minConfig)) {
          this.min = min_1;
        }
        if (is_nil_default(maxConfig)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(linear_default)
);
var time_default2 = Time;

// node_modules/@antv/scale/esm/continuous/quantize.js
var Quantize = (
  /** @class */
  function(_super) {
    __extends(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value2) {
      var ticks = this.ticks;
      var length5 = ticks.length;
      var percent2 = this.getInvertPercent(value2);
      var minIndex = Math.floor(percent2 * (length5 - 1));
      if (minIndex >= length5 - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length5 - 1);
      var maxIndexPercent = (minIndex + 1) / (length5 - 1);
      return minTick + (percent2 - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value2) {
      var ticks = this.ticks;
      if (value2 < head(ticks)) {
        return 0;
      }
      if (value2 > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each_default(ticks, function(tick, index) {
        if (value2 >= tick) {
          minIndex = index;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(base_default6)
);
var quantize_default2 = Quantize;

// node_modules/@antv/scale/esm/continuous/quantile.js
var Quantile = (
  /** @class */
  function(_super) {
    __extends(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(quantize_default2)
);
var quantile_default = Quantile;

// node_modules/@antv/scale/esm/factory.js
var map3 = {};
function getClass(key) {
  return map3[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map3[key] = cls;
}

// node_modules/@antv/scale/esm/identity/index.js
var Identity = (
  /** @class */
  function(_super) {
    __extends(Identity2, _super);
    function Identity2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity2.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity2.prototype.scale = function(value2) {
      if (this.values[0] !== value2 && is_number_default(value2)) {
        return value2;
      }
      return this.range[0];
    };
    Identity2.prototype.invert = function(value2) {
      var range2 = this.range;
      if (value2 < range2[0] || value2 > range2[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity2;
  }(base_default4)
);
var identity_default2 = Identity;

// node_modules/@antv/scale/esm/tick-method/cat.js
function calculateCatTicks(cfg) {
  var values3 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (is_number_default(tickInterval)) {
    var ticks_1 = filter_default(values3, function(__, i2) {
      return i2 % tickInterval === 0;
    });
    var lastValue = last(values3);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len3 = values3.length;
  var min5 = cfg.min, max5 = cfg.max;
  if (is_nil_default(min5)) {
    min5 = 0;
  }
  if (is_nil_default(max5)) {
    max5 = values3.length - 1;
  }
  if (!is_number_default(tickCount) || tickCount >= len3)
    return values3.slice(min5, max5 + 1);
  if (tickCount <= 0 || max5 <= 0)
    return [];
  var interval3 = tickCount === 1 ? len3 : Math.floor(len3 / (tickCount - 1));
  var ticks = [];
  var idx = min5;
  for (var i = 0; i < tickCount; i++) {
    if (idx >= max5)
      break;
    idx = Math.min(min5 + i * interval3, max5);
    if (i === tickCount - 1 && showLast)
      ticks.push(values3[max5]);
    else
      ticks.push(values3[idx]);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
  var min5 = cfg.min, max5 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear5 = new D3Linear();
  linear5.domain([min5, max5]);
  if (nice) {
    linear5.nice(tickCount);
  }
  return linear5.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = (
  /** @class */
  function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count2) {
      var _a6, _b;
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      var d = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop = this._domain[i1];
      var step;
      if (stop < start) {
        _a6 = [stop, start], start = _a6[0], stop = _a6[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step = tickIncrement(start, stop, count2);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count2);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count2);
      }
      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        this.domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        this.domain(d);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count2) {
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count2 || DEFAULT_COUNT);
    };
    return D3Linear2;
  }()
);
function d3ArrayTicks(start, stop, count2) {
  var reverse2;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0) {
    return [start];
  }
  if (reverse2 = stop < start) {
    n = start, start = stop, stop = n;
  }
  if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }
  if (reverse2) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2);
  var power2 = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power2);
  return power2 >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power2) : -Math.pow(10, -power2) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

// node_modules/@antv/scale/esm/util/interval.js
function snapMultiple(v, base, snapType) {
  var div3;
  if (snapType === "ceil") {
    div3 = Math.ceil(v / base);
  } else if (snapType === "floor") {
    div3 = Math.floor(v / base);
  } else {
    div3 = Math.round(v / base);
  }
  return div3 * base;
}
function intervalTicks(min5, max5, interval3) {
  var minTick = snapMultiple(min5, interval3, "floor");
  var maxTick = snapMultiple(max5, interval3, "ceil");
  minTick = fixed_base_default(minTick, interval3);
  maxTick = fixed_base_default(maxTick, interval3);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval3);
  for (var i = minTick; i <= maxTick; i = i + availableInterval) {
    var tickValue = fixed_base_default(i, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}

// node_modules/@antv/scale/esm/util/strict-limit.js
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a6;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min5 = cfg.min, max5 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min5 : defaultMin : minLimit;
  var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max5 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a6 = [tickMin, tickMax], tickMax = _a6[0], tickMin = _a6[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
  var min5 = cfg.min, max5 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min5, max5, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}

// node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n, m) {
  return (n % m + m) % m;
}
function round3(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 0;
  var m = mod2(lmin, lstep);
  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
  var r = (k - 1) / (lMax - lMin);
  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range2 = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range2, 2);
}
function coverageMax(dMin, dMax, span) {
  var range2 = dMax - dMin;
  if (span > range2) {
    var half = (span - range2) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range2, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n, onlyLoose, Q, w) {
  if (n === void 0) {
    n = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q === void 0) {
    Q = DEFAULT_Q;
  }
  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  }
  var m = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count2 = n || 5;
    var step_1 = (dMax - dMin) / count2;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count2).fill(null).map(function(_, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;
  while (j < Infinity) {
    for (var i = 0; i < Q.length; i += 1) {
      var q = Q[i];
      var sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      var k = 2;
      while (k < Infinity) {
        var dm = densityMax(k, m);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dMin, dMax, step * (k - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            var count2 = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count2; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j);
              var lMax = lMin + step * (k - 1);
              var lStep = step;
              var s = simplicity(q, Q, j, lMin, lMax, lStep);
              var c = coverage(dMin, dMax, lMin, lMax);
              var g = density(k, m, dMin, dMax, lMin, lMax);
              var l = legibility();
              var score2 = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k += 1;
      }
    }
    j += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round3((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i = 1; i < tickCount; i++) {
    ticks[i] = prettyNumber(ticks[i - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/linear.js
function linear3(cfg) {
  var min5 = cfg.min, max5 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min5, max5, tickCount, nice).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min5, max5, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/log.js
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min5 = cfg.min, max5 = cfg.max, values3 = cfg.values;
  var minTick;
  var maxTick = log(base, max5);
  if (min5 > 0) {
    minTick = Math.floor(log(base, min5));
  } else {
    var positiveMin = getLogPositiveMin(values3, base, max5);
    minTick = Math.floor(log(base, positiveMin));
  }
  var count2 = maxTick - minTick;
  var avg2 = Math.ceil(count2 / tickCount);
  var ticks = [];
  for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
    ticks.push(Math.pow(base, i));
  }
  if (min5 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty.js
function pretty(min5, max5, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min5 === max5) {
    return {
      max: max5,
      min: min5,
      ticks: [min5]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0)
    return { max: max5, min: min5, ticks: [] };
  var h = 1.5;
  var h5 = 0.5 + 1.5 * h;
  var d = max5 - min5;
  var c = d / n;
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max5 / unit);
  var ns = Math.floor(min5 / unit);
  var hi = Math.max(nu * unit, max5);
  var lo = Math.min(ns * unit, min5);
  var size3 = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size3);
  for (var i = 0; i < size3; i++) {
    ticks[i] = prettyNumber(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/pow.js
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max5 = Math.ceil(calBase(exponent2, cfg.max));
  var min5 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min5, max5, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}

// node_modules/@antv/scale/esm/tick-method/quantile.js
function quantileSorted(x, p) {
  var idx = x.length * p;
  if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values3 = cfg.values;
  if (!values3 || !values3.length) {
    return [];
  }
  var sorted = values3.slice().sort(function(a, b) {
    return a - b;
  });
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p));
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/r-prettry.js
function linearPretty(cfg) {
  var min5 = cfg.min, max5 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min5, max5, tickCount).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min5, max5, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
  var min5 = cfg.min, max5 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max5 - min5) / tickInterval);
  } else {
    tickInterval = getTickInterval(min5, max5, tickCount)[1];
    var count2 = (max5 - min5) / tickInterval;
    var ratio = count2 / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max5 - min5) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i = min5; i < max5 + tickInterval; i += tickInterval) {
    ticks.push(i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-cat.js
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign({ showLast: true }, cfg));
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min5, max5) {
  var minYear = getYear(min5);
  var maxYear = getYear(max5);
  var minMonth = getMonth(min5);
  var maxMonth = getMonth(max5);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min5, max5) {
  return Math.ceil((max5 - min5) / DAY);
}
function diffHour(min5, max5) {
  return Math.ceil((max5 - min5) / HOUR);
}
function diffMinus(min5, max5) {
  return Math.ceil((max5 - min5) / (60 * 1e3));
}
function timePretty(cfg) {
  var min5 = cfg.min, max5 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max5 - min5) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max5 - min5) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min5);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max5);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min5);
    var dMonths = diffMonth(min5, max5);
    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min5);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min5, max5);
    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min5);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min5, max5);
    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min5, max5);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min5 + i * MINUTE);
    }
  } else {
    var interval3 = tickInterval;
    if (interval3 < SECOND) {
      interval3 = SECOND;
    }
    var minSecond = Math.floor(min5 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max5 - min5) / SECOND);
    var seconds = Math.ceil(interval3 / SECOND);
    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear3);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

// node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default5);
registerClass("category", base_default5);
registerClass("identity", identity_default2);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default2);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default2);
registerClass("quantile", quantile_default);

// node_modules/@antv/attr/esm/factory.js
var ATTRIBUTE_MAP = {};
var getAttribute = function(type) {
  return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function(type, ctor) {
  if (getAttribute(type)) {
    throw new Error("Attribute type '".concat(type, "' existed."));
  }
  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/attr/esm/index.js
registerAttribute("Color", color_default);
registerAttribute("Opacity", opacity_default);
registerAttribute("Position", position_default);
registerAttribute("Shape", shape_default2);
registerAttribute("Size", size_default);

// node_modules/@antv/coord/esm/coord/base.js
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(cfg) {
      this.type = "coordinate";
      this.isRect = false;
      this.isHelix = false;
      this.isPolar = false;
      this.isReflectX = false;
      this.isReflectY = false;
      var start = cfg.start, end = cfg.end, _a6 = cfg.matrix, matrix = _a6 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a6, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
      this.start = start;
      this.end = end;
      this.matrix = matrix;
      this.originalMatrix = __spreadArray([], matrix);
      this.isTransposed = isTransposed;
    }
    Coordinate2.prototype.initial = function() {
      this.center = {
        x: (this.start.x + this.end.x) / 2,
        y: (this.start.y + this.end.y) / 2
      };
      this.width = Math.abs(this.end.x - this.start.x);
      this.height = Math.abs(this.end.y - this.start.y);
    };
    Coordinate2.prototype.update = function(cfg) {
      mix(this, cfg);
      this.initial();
    };
    Coordinate2.prototype.convertDim = function(percent2, dim) {
      var _a6;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a6 = [end, start], start = _a6[0], end = _a6[1];
      }
      return start + percent2 * (end - start);
    };
    Coordinate2.prototype.invertDim = function(value2, dim) {
      var _a6;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a6 = [end, start], start = _a6[0], end = _a6[1];
      }
      return (value2 - start) / (end - start);
    };
    Coordinate2.prototype.applyMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var vector = [x, y, tag];
      vec3_exports.transformMat3(vector, vector, matrix);
      return vector;
    };
    Coordinate2.prototype.invertMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var inverted = mat3_exports.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
      var vector = [x, y, tag];
      if (inverted) {
        vec3_exports.transformMat3(vector, vector, inverted);
      }
      return vector;
    };
    Coordinate2.prototype.convert = function(point2) {
      var _a6 = this.convertPoint(point2), x = _a6.x, y = _a6.y;
      var vector = this.applyMatrix(x, y, 1);
      return {
        x: vector[0],
        y: vector[1]
      };
    };
    Coordinate2.prototype.invert = function(point2) {
      var vector = this.invertMatrix(point2.x, point2.y, 1);
      return this.invertPoint({
        x: vector[0],
        y: vector[1]
      });
    };
    Coordinate2.prototype.rotate = function(radian) {
      var matrix = this.matrix;
      var center2 = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
      ext_exports.leftRotate(matrix, matrix, radian);
      ext_exports.leftTranslate(matrix, matrix, [center2.x, center2.y]);
      return this;
    };
    Coordinate2.prototype.reflect = function(dim) {
      if (dim === "x") {
        this.isReflectX = !this.isReflectX;
      } else {
        this.isReflectY = !this.isReflectY;
      }
      return this;
    };
    Coordinate2.prototype.scale = function(s1, s2) {
      var matrix = this.matrix;
      var center2 = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
      ext_exports.leftScale(matrix, matrix, [s1, s2]);
      ext_exports.leftTranslate(matrix, matrix, [center2.x, center2.y]);
      return this;
    };
    Coordinate2.prototype.translate = function(x, y) {
      var matrix = this.matrix;
      ext_exports.leftTranslate(matrix, matrix, [x, y]);
      return this;
    };
    Coordinate2.prototype.transpose = function() {
      this.isTransposed = !this.isTransposed;
      return this;
    };
    Coordinate2.prototype.getCenter = function() {
      return this.center;
    };
    Coordinate2.prototype.getWidth = function() {
      return this.width;
    };
    Coordinate2.prototype.getHeight = function() {
      return this.height;
    };
    Coordinate2.prototype.getRadius = function() {
      return this.radius;
    };
    Coordinate2.prototype.isReflect = function(dim) {
      return dim === "x" ? this.isReflectX : this.isReflectY;
    };
    Coordinate2.prototype.resetMatrix = function(matrix) {
      this.matrix = matrix ? matrix : __spreadArray([], this.originalMatrix);
    };
    return Coordinate2;
  }()
);
var base_default7 = Coordinate;

// node_modules/@antv/coord/esm/coord/cartesian.js
var Cartesian = (
  /** @class */
  function(_super) {
    __extends(Cartesian2, _super);
    function Cartesian2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isRect = true;
      _this.type = "cartesian";
      _this.initial();
      return _this;
    }
    Cartesian2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var start = this.start;
      var end = this.end;
      this.x = {
        start: start.x,
        end: end.x
      };
      this.y = {
        start: start.y,
        end: end.y
      };
    };
    Cartesian2.prototype.convertPoint = function(point2) {
      var _a6;
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a6 = [y, x], x = _a6[0], y = _a6[1];
      }
      return {
        x: this.convertDim(x, "x"),
        y: this.convertDim(y, "y")
      };
    };
    Cartesian2.prototype.invertPoint = function(point2) {
      var _a6;
      var x = this.invertDim(point2.x, "x");
      var y = this.invertDim(point2.y, "y");
      if (this.isTransposed) {
        _a6 = [y, x], x = _a6[0], y = _a6[1];
      }
      return { x, y };
    };
    return Cartesian2;
  }(base_default7)
);
var cartesian_default = Cartesian;

// node_modules/@antv/coord/esm/coord/helix.js
var Helix = (
  /** @class */
  function(_super) {
    __extends(Helix2, _super);
    function Helix2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isHelix = true;
      _this.type = "helix";
      var _a6 = cfg.startAngle, startAngle = _a6 === void 0 ? 1.25 * Math.PI : _a6, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Helix2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
      var maxRadius = Math.min(this.width, this.height) / 2;
      if (this.radius && this.radius >= 0 && this.radius <= 1) {
        maxRadius = maxRadius * this.radius;
      }
      this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
      this.a = this.d / (Math.PI * 2);
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * maxRadius,
        end: this.innerRadius * maxRadius + this.d * 0.99
      };
    };
    Helix2.prototype.convertPoint = function(point2) {
      var _a6;
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a6 = [y, x], x = _a6[0], y = _a6[1];
      }
      var thi = this.convertDim(x, "x");
      var r = this.a * thi;
      var newY = this.convertDim(y, "y");
      return {
        x: this.center.x + Math.cos(thi) * (r + newY),
        y: this.center.y + Math.sin(thi) * (r + newY)
      };
    };
    Helix2.prototype.invertPoint = function(point2) {
      var _a6;
      var d = this.d + this.y.start;
      var v = vec2_exports.subtract([0, 0], [point2.x, point2.y], [this.center.x, this.center.y]);
      var thi = ext_exports.angleTo(v, [1, 0], true);
      var rMin = thi * this.a;
      if (vec2_exports.length(v) < rMin) {
        rMin = vec2_exports.length(v);
      }
      var index = Math.floor((vec2_exports.length(v) - rMin) / d);
      thi = 2 * index * Math.PI + thi;
      var r = this.a * thi;
      var newY = vec2_exports.length(v) - r;
      newY = isNumberEqual(newY, 0) ? 0 : newY;
      var x = this.invertDim(thi, "x");
      var y = this.invertDim(newY, "y");
      x = isNumberEqual(x, 0) ? 0 : x;
      y = isNumberEqual(y, 0) ? 0 : y;
      if (this.isTransposed) {
        _a6 = [y, x], x = _a6[0], y = _a6[1];
      }
      return { x, y };
    };
    return Helix2;
  }(base_default7)
);
var helix_default = Helix;

// node_modules/@antv/coord/esm/coord/polar.js
var Polar = (
  /** @class */
  function(_super) {
    __extends(Polar2, _super);
    function Polar2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isPolar = true;
      _this.type = "polar";
      var _a6 = cfg.startAngle, startAngle = _a6 === void 0 ? -Math.PI / 2 : _a6, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Polar2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      while (this.endAngle < this.startAngle) {
        this.endAngle += Math.PI * 2;
      }
      var oneBox = this.getOneBox();
      var oneWidth = oneBox.maxX - oneBox.minX;
      var oneHeight = oneBox.maxY - oneBox.minY;
      var left2 = Math.abs(oneBox.minX) / oneWidth;
      var top = Math.abs(oneBox.minY) / oneHeight;
      var maxRadius;
      if (this.height / oneHeight > this.width / oneWidth) {
        maxRadius = this.width / oneWidth;
        this.circleCenter = {
          x: this.center.x - (0.5 - left2) * this.width,
          y: this.center.y - (0.5 - top) * maxRadius * oneHeight
        };
      } else {
        maxRadius = this.height / oneHeight;
        this.circleCenter = {
          x: this.center.x - (0.5 - left2) * maxRadius * oneWidth,
          y: this.center.y - (0.5 - top) * this.height
        };
      }
      this.polarRadius = this.radius;
      if (!this.radius) {
        this.polarRadius = maxRadius;
      } else if (this.radius > 0 && this.radius <= 1) {
        this.polarRadius = maxRadius * this.radius;
      } else if (this.radius <= 0 || this.radius > maxRadius) {
        this.polarRadius = maxRadius;
      }
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * this.polarRadius,
        end: this.polarRadius
      };
    };
    Polar2.prototype.getRadius = function() {
      return this.polarRadius;
    };
    Polar2.prototype.convertPoint = function(point2) {
      var _a6;
      var center2 = this.getCenter();
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a6 = [y, x], x = _a6[0], y = _a6[1];
      }
      x = this.convertDim(x, "x");
      y = this.convertDim(y, "y");
      return {
        x: center2.x + Math.cos(x) * y,
        y: center2.y + Math.sin(x) * y
      };
    };
    Polar2.prototype.invertPoint = function(point2) {
      var _a6;
      var center2 = this.getCenter();
      var vPoint = [point2.x - center2.x, point2.y - center2.y];
      var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (this.isReflect("x")) {
        _a6 = [endAngle, startAngle], startAngle = _a6[0], endAngle = _a6[1];
      }
      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      ext_exports.leftRotate(m, m, startAngle);
      var vStart3 = [1, 0, 0];
      vec3_exports.transformMat3(vStart3, vStart3, m);
      var vStart2 = [vStart3[0], vStart3[1]];
      var angle4 = ext_exports.angleTo(vStart2, vPoint, endAngle < startAngle);
      if (isNumberEqual(angle4, Math.PI * 2)) {
        angle4 = 0;
      }
      var radius = vec2_exports.length(vPoint);
      var xPercent = angle4 / (endAngle - startAngle);
      xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
      var yPercent = this.invertDim(radius, "y");
      var rst = { x: 0, y: 0 };
      rst.x = this.isTransposed ? yPercent : xPercent;
      rst.y = this.isTransposed ? xPercent : yPercent;
      return rst;
    };
    Polar2.prototype.getCenter = function() {
      return this.circleCenter;
    };
    Polar2.prototype.getOneBox = function() {
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
        return {
          minX: -1,
          maxX: 1,
          minY: -1,
          maxY: 1
        };
      }
      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
        xs.push(Math.cos(i));
        ys.push(Math.sin(i));
      }
      return {
        minX: Math.min.apply(Math, xs),
        maxX: Math.max.apply(Math, xs),
        minY: Math.min.apply(Math, ys),
        maxY: Math.max.apply(Math, ys)
      };
    };
    return Polar2;
  }(base_default7)
);
var polar_default = Polar;

// node_modules/@antv/coord/esm/factory.js
var COORDINATE_MAP = {};
var getCoordinate = function(type) {
  return COORDINATE_MAP[type.toLowerCase()];
};
var registerCoordinate = function(type, ctor) {
  COORDINATE_MAP[type.toLowerCase()] = ctor;
};

// node_modules/@antv/coord/esm/index.js
registerCoordinate("rect", cartesian_default);
registerCoordinate("cartesian", cartesian_default);
registerCoordinate("polar", polar_default);
registerCoordinate("helix", helix_default);

// node_modules/@antv/component/esm/annotation/index.js
var annotation_exports = {};
__export(annotation_exports, {
  Arc: () => arc_default2,
  DataMarker: () => data_marker_default,
  DataRegion: () => data_region_default,
  Html: () => html_default,
  Image: () => image_default,
  Line: () => line_default3,
  Region: () => region_default,
  RegionFilter: () => region_filter_default,
  Shape: () => shape_default3,
  Text: () => text_default2
});

// node_modules/@antv/component/esm/util/event.js
function propagationDelegate(group2, eventName, eventObject) {
  var event = new graph_event_default(eventName, eventObject);
  event.target = group2;
  event.propagationPath.push(group2);
  group2.emitDelegation(eventName, event);
  var parent2 = group2.getParent();
  while (parent2) {
    parent2.emitDelegation(eventName, event);
    event.propagationPath.push(parent2);
    parent2 = parent2.getParent();
  }
}

// node_modules/@antv/component/esm/util/matrix.js
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point2, angle4, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle4) {
    return null;
  }
  var m = ext_exports.transform(matrix, [
    ["t", -point2.x, -point2.y],
    ["r", angle4],
    ["t", point2.x, point2.y]
  ]);
  return m;
}
function getMatrixByTranslate(point2, currentMatrix) {
  if (!point2.x && !point2.y) {
    return null;
  }
  return ext_exports.transform(currentMatrix || identityMatrix, [["t", point2.x, point2.y]]);
}
function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  vec3_exports.transformMat3(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}
function multiplyVec22(matrix, v) {
  var out = [0, 0];
  vec2_exports.transformMat3(out, v, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec22(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec22(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec22(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec22(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function applyRotate(shape, rotate5, x, y) {
  if (rotate5) {
    var matrix = getMatrixByAngle({ x, y }, rotate5, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({ x, y });
  shape.attr("matrix", translateMatrix);
}

// node_modules/@antv/component/esm/util/util.js
function formatPadding(padding3) {
  var top = 0;
  var left2 = 0;
  var right2 = 0;
  var bottom = 0;
  if (is_number_default(padding3)) {
    top = left2 = right2 = bottom = padding3;
  } else if (is_array_default(padding3)) {
    top = padding3[0];
    right2 = !is_nil_default(padding3[1]) ? padding3[1] : padding3[0];
    bottom = !is_nil_default(padding3[2]) ? padding3[2] : padding3[0];
    left2 = !is_nil_default(padding3[3]) ? padding3[3] : right2;
  }
  return [top, right2, bottom, left2];
}
function clearDom(container) {
  var children = container.childNodes;
  var length5 = children.length;
  for (var i = length5 - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start, end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY2 = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function pointsToBBox(points2) {
  var xs = points2.map(function(point2) {
    return point2.x;
  });
  var ys = points2.map(function(point2) {
    return point2.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY2 = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY2 = y + height;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    //  js 
    // Infinity + Infinity = Infinity
    // Infinity - Infinity = NaN
    // fixed https://github.com/antvis/G2Plot/issues/1243
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY2) ? 0 : maxY2
  };
}
function getValueByPercent(min5, max5, percent2) {
  return (1 - percent2) * min5 + max5 * percent2;
}
function getCirclePoint(center2, radius, angle4) {
  return {
    x: center2.x + Math.cos(angle4) * radius,
    y: center2.y + Math.sin(angle4) * radius
  };
}
function distance4(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var near = function(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox2(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY2 = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY2 - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      each_default(children, function(child) {
        if (child.get("visible")) {
          if (child.isGroup() && child.get("children").length === 0) {
            return true;
          }
          var box2 = getBBoxWithClip(child);
          var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
          var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
          var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
          var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox2(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    element.setClip(null);
    return;
  }
  var clipCfg = {
    type: newClipShape.get("type"),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number) {
  return number + "px";
}
function getTextPoint(start, end, position, offset) {
  var lineLength = distance4(start, end);
  var offsetPercent = offset / lineLength;
  var percent2 = 0;
  if (position === "start") {
    percent2 = 0 - offsetPercent;
  } else if (position === "end") {
    percent2 = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent2),
    y: getValueByPercent(start.y, end.y, percent2)
  };
}

// node_modules/@antv/component/esm/abstract/component.js
var LOCATION_FIELD_MAP = {
  none: [],
  point: ["x", "y"],
  region: ["start", "end"],
  points: ["points"],
  circle: ["center", "radius", "startAngle", "endAngle"]
};
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initCfg();
      return _this;
    }
    Component2.prototype.getDefaultCfg = function() {
      return {
        id: "",
        name: "",
        type: "",
        locationType: "none",
        offsetX: 0,
        offsetY: 0,
        animate: false,
        capture: true,
        updateAutoRender: false,
        animateOption: {
          appear: null,
          update: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          enter: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          leave: {
            duration: 350,
            easing: "easeQuadIn"
          }
        },
        events: null,
        defaultCfg: {},
        visible: true
      };
    };
    Component2.prototype.clear = function() {
    };
    Component2.prototype.update = function(cfg) {
      var _this = this;
      var defaultCfg = this.get("defaultCfg") || {};
      each_default(cfg, function(value2, name) {
        var originCfg = _this.get(name);
        var newCfg = value2;
        if (originCfg !== value2) {
          if (is_object_default(value2) && defaultCfg[name]) {
            newCfg = deep_mix_default({}, defaultCfg[name], value2);
          }
          _this.set(name, newCfg);
        }
      });
      this.updateInner(cfg);
      this.afterUpdate(cfg);
    };
    Component2.prototype.updateInner = function(cfg) {
    };
    Component2.prototype.afterUpdate = function(cfg) {
      if (has_key_default(cfg, "visible")) {
        if (cfg.visible) {
          this.show();
        } else {
          this.hide();
        }
      }
      if (has_key_default(cfg, "capture")) {
        this.setCapture(cfg.capture);
      }
    };
    Component2.prototype.getLayoutBBox = function() {
      return this.getBBox();
    };
    Component2.prototype.getLocationType = function() {
      return this.get("locationType");
    };
    Component2.prototype.getOffset = function() {
      return {
        offsetX: this.get("offsetX"),
        offsetY: this.get("offsetY")
      };
    };
    Component2.prototype.setOffset = function(offsetX, offsetY) {
      this.update({
        offsetX,
        offsetY
      });
    };
    Component2.prototype.setLocation = function(cfg) {
      var location = __assign({}, cfg);
      this.update(location);
    };
    Component2.prototype.getLocation = function() {
      var _this = this;
      var location = {};
      var locationType = this.get("locationType");
      var fields = LOCATION_FIELD_MAP[locationType];
      each_default(fields, function(field6) {
        location[field6] = _this.get(field6);
      });
      return location;
    };
    Component2.prototype.isList = function() {
      return false;
    };
    Component2.prototype.isSlider = function() {
      return false;
    };
    Component2.prototype.init = function() {
    };
    Component2.prototype.initCfg = function() {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each_default(defaultCfg, function(value2, name) {
        var cfg = _this.get(name);
        if (is_object_default(cfg)) {
          var newCfg = deep_mix_default({}, value2, cfg);
          _this.set(name, newCfg);
        }
      });
    };
    return Component2;
  }(base_default2)
);
var component_default = Component;

// node_modules/@antv/component/esm/abstract/group-component.js
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
var GroupComponent = (
  /** @class */
  function(_super) {
    __extends(GroupComponent2, _super);
    function GroupComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        container: null,
        /**
         * @private
         *  Map
         */
        shapesMap: {},
        group: null,
        capture: true,
        /**
         * @private 
         * @type {false}
         */
        isRegister: false,
        /**
         * @private 
         * @type {false}
         */
        isUpdating: false,
        /**
         * @private
         *  renderupdate  false, clear 
         */
        isInit: true
      });
    };
    GroupComponent2.prototype.remove = function() {
      this.clear();
      var group2 = this.get("group");
      group2.remove();
    };
    GroupComponent2.prototype.clear = function() {
      var group2 = this.get("group");
      group2.clear();
      this.set("shapesMap", {});
      this.clearOffScreenCache();
      this.set("isInit", true);
    };
    GroupComponent2.prototype.getChildComponentById = function(id) {
      var group2 = this.getElementById(id);
      var inst = group2 && group2.get("component");
      return inst;
    };
    GroupComponent2.prototype.getElementById = function(id) {
      return this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.getElementByLocalId = function(localId) {
      var id = this.getElementId(localId);
      return this.getElementById(id);
    };
    GroupComponent2.prototype.getElementsByName = function(name) {
      var rst = [];
      each_default(this.get("shapesMap"), function(elem) {
        if (elem.get("name") === name) {
          rst.push(elem);
        }
      });
      return rst;
    };
    GroupComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    GroupComponent2.prototype.updateInner = function(cfg) {
      this.offScreenRender();
      if (this.get("updateAutoRender")) {
        this.render();
      }
    };
    GroupComponent2.prototype.render = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (!offScreenGroup) {
        offScreenGroup = this.offScreenRender();
      }
      var group2 = this.get("group");
      this.updateElements(offScreenGroup, group2);
      this.deleteElements();
      this.applyOffset();
      if (!this.get("eventInitted")) {
        this.initEvent();
        this.set("eventInitted", true);
      }
      this.set("isInit", false);
    };
    GroupComponent2.prototype.show = function() {
      var group2 = this.get("group");
      group2.show();
      this.set("visible", true);
    };
    GroupComponent2.prototype.hide = function() {
      var group2 = this.get("group");
      group2.hide();
      this.set("visible", false);
    };
    GroupComponent2.prototype.setCapture = function(capture) {
      var group2 = this.get("group");
      group2.set("capture", capture);
      this.set("capture", capture);
    };
    GroupComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.remove();
      _super.prototype.destroy.call(this);
    };
    GroupComponent2.prototype.getBBox = function() {
      return this.get("group").getCanvasBBox();
    };
    GroupComponent2.prototype.getLayoutBBox = function() {
      var group2 = this.get("group");
      var bbox = this.getInnerLayoutBBox();
      var matrix = group2.getTotalMatrix();
      if (matrix) {
        bbox = applyMatrix2BBox(matrix, bbox);
      }
      return bbox;
    };
    GroupComponent2.prototype.on = function(evt, callback, once2) {
      var group2 = this.get("group");
      group2.on(evt, callback, once2);
      return this;
    };
    GroupComponent2.prototype.off = function(evt, callback) {
      var group2 = this.get("group");
      group2 && group2.off(evt, callback);
      return this;
    };
    GroupComponent2.prototype.emit = function(eventName, eventObject) {
      var group2 = this.get("group");
      group2.emit(eventName, eventObject);
    };
    GroupComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      if (!this.get("group")) {
        this.initGroup();
      }
      this.offScreenRender();
    };
    GroupComponent2.prototype.getInnerLayoutBBox = function() {
      return this.get("offScreenBBox") || this.get("group").getBBox();
    };
    GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
      var group2 = this.get("group");
      eventObject.target = group2;
      group2.emit(eventName, eventObject);
      propagationDelegate(group2, eventName, eventObject);
    };
    GroupComponent2.prototype.createOffScreenGroup = function() {
      var group2 = this.get("group");
      var GroupClass = group2.getGroupBase();
      var newGroup = new GroupClass({
        delegateObject: this.getDelegateObject()
      });
      return newGroup;
    };
    GroupComponent2.prototype.applyOffset = function() {
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: offsetX,
        y: offsetY
      });
    };
    GroupComponent2.prototype.initGroup = function() {
      var container = this.get("container");
      this.set("group", container.addGroup({
        id: this.get("id"),
        name: this.get("name"),
        capture: this.get("capture"),
        visible: this.get("visible"),
        isComponent: true,
        component: this,
        delegateObject: this.getDelegateObject()
      }));
    };
    GroupComponent2.prototype.offScreenRender = function() {
      this.clearOffScreenCache();
      var offScreenGroup = this.createOffScreenGroup();
      this.renderInner(offScreenGroup);
      this.set("offScreenGroup", offScreenGroup);
      this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
      return offScreenGroup;
    };
    GroupComponent2.prototype.addGroup = function(parent2, cfg) {
      this.appendDelegateObject(parent2, cfg);
      var group2 = parent2.addGroup(cfg);
      if (this.get("isRegister")) {
        this.registerElement(group2);
      }
      return group2;
    };
    GroupComponent2.prototype.addShape = function(parent2, cfg) {
      this.appendDelegateObject(parent2, cfg);
      var shape = parent2.addShape(cfg);
      if (this.get("isRegister")) {
        this.registerElement(shape);
      }
      return shape;
    };
    GroupComponent2.prototype.addComponent = function(parent2, cfg) {
      var id = cfg.id, Ctor = cfg.component, restCfg = __rest(cfg, ["id", "component"]);
      var inst = new Ctor(__assign(__assign({}, restCfg), { id, container: parent2, updateAutoRender: this.get("updateAutoRender") }));
      inst.init();
      inst.render();
      if (this.get("isRegister")) {
        this.registerElement(inst.get("group"));
      }
      return inst;
    };
    GroupComponent2.prototype.initEvent = function() {
    };
    GroupComponent2.prototype.removeEvent = function() {
      var group2 = this.get("group");
      group2.off();
    };
    GroupComponent2.prototype.getElementId = function(localId) {
      var id = this.get("id");
      var name = this.get("name");
      return id + "-" + name + "-" + localId;
    };
    GroupComponent2.prototype.registerElement = function(element) {
      var id = element.get("id");
      this.get("shapesMap")[id] = element;
    };
    GroupComponent2.prototype.unregisterElement = function(element) {
      var id = element.get("id");
      delete this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.moveElementTo = function(element, point2) {
      var matrix = getMatrixByTranslate(point2);
      element.attr("matrix", matrix);
    };
    GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
      var originOpacity = newElement.attr("opacity");
      if (is_nil_default(originOpacity)) {
        originOpacity = 1;
      }
      newElement.attr("opacity", 0);
      newElement.animate({ opacity: originOpacity }, animateCfg);
    };
    GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
      originElement.animate({ opacity: 0 }, animateCfg);
    };
    GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
      originElement.animate(newAttrs, animateCfg);
    };
    GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
      var _this = this;
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      var children = newGroup.getChildren().slice(0);
      var preElement;
      each_default(children, function(element) {
        var elementId = element.get("id");
        var originElement = _this.getElementById(elementId);
        var elementName = element.get("name");
        if (originElement) {
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            var origChildComponent = originElement.get("component");
            var newCfg = pick_default(childComponent.cfg, difference_default(keys_default(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
            origChildComponent.update(newCfg);
            originElement.set(STATUS_UPDATE, "update");
          } else {
            var replaceAttrs = _this.getReplaceAttrs(originElement, element);
            if (animate && animateOption.update) {
              _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
            } else {
              originElement.attr(replaceAttrs);
            }
            if (element.isGroup()) {
              _this.updateElements(element, originElement);
            }
            each_default(COPY_PROPERTIES, function(name) {
              originElement.set(name, element.get(name));
            });
            updateClip(originElement, element);
            preElement = originElement;
            originElement.set(STATUS_UPDATE, "update");
          }
        } else {
          originGroup.add(element);
          var siblings = originGroup.getChildren();
          siblings.splice(siblings.length - 1, 1);
          if (preElement) {
            var index = siblings.indexOf(preElement);
            siblings.splice(index + 1, 0, element);
          } else {
            siblings.unshift(element);
          }
          _this.registerElement(element);
          element.set(STATUS_UPDATE, "add");
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            childComponent.set("container", originGroup);
          } else if (element.isGroup()) {
            _this.registerNewGroup(element);
          }
          preElement = element;
          if (animate) {
            var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
            if (animateCfg) {
              _this.addAnimation(elementName, element, animateCfg);
            }
          }
        }
      });
    };
    GroupComponent2.prototype.clearUpdateStatus = function(group2) {
      var children = group2.getChildren();
      each_default(children, function(el) {
        el.set(STATUS_UPDATE, null);
      });
    };
    GroupComponent2.prototype.clearOffScreenCache = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (offScreenGroup) {
        offScreenGroup.destroy();
      }
      this.set("offScreenGroup", null);
      this.set("offScreenBBox", null);
    };
    GroupComponent2.prototype.getDelegateObject = function() {
      var _a6;
      var name = this.get("name");
      var delegateObject = (_a6 = {}, _a6[name] = this, _a6.component = this, _a6);
      return delegateObject;
    };
    GroupComponent2.prototype.appendDelegateObject = function(parent2, cfg) {
      var parentObject = parent2.get("delegateObject");
      if (!cfg.delegateObject) {
        cfg.delegateObject = {};
      }
      mix(cfg.delegateObject, parentObject);
    };
    GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
      var originAttrs = originElement.attr();
      var newAttrs = newElement.attr();
      each_default(originAttrs, function(v, k) {
        if (newAttrs[k] === void 0) {
          newAttrs[k] = void 0;
        }
      });
      return newAttrs;
    };
    GroupComponent2.prototype.registerNewGroup = function(group2) {
      var _this = this;
      var children = group2.getChildren();
      each_default(children, function(element) {
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
      });
    };
    GroupComponent2.prototype.deleteElements = function() {
      var _this = this;
      var shapesMap = this.get("shapesMap");
      var deleteArray = [];
      each_default(shapesMap, function(element, id) {
        if (!element.get(STATUS_UPDATE) || element.destroyed) {
          deleteArray.push([id, element]);
        } else {
          element.set(STATUS_UPDATE, null);
        }
      });
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      each_default(deleteArray, function(item) {
        var id = item[0], element = item[1];
        if (!element.destroyed) {
          var elementName = element.get("name");
          if (animate && animateOption.leave) {
            var callbackAnimCfg = mix({
              callback: function() {
                _this.removeElement(element);
              }
            }, animateOption.leave);
            _this.removeAnimation(elementName, element, callbackAnimCfg);
          } else {
            _this.removeElement(element);
          }
        }
        delete shapesMap[id];
      });
    };
    GroupComponent2.prototype.removeElement = function(element) {
      if (element.get("isGroup")) {
        var component2 = element.get("component");
        if (component2) {
          component2.destroy();
        }
      }
      element.remove();
    };
    return GroupComponent2;
  }(component_default)
);
var group_component_default = GroupComponent;

// node_modules/@antv/component/esm/util/text.js
var ELLIPSIS_CODE = "";
function strLen(str4) {
  var len3 = 0;
  for (var i = 0; i < str4.length; i++) {
    len3 += charAtLength(str4, i);
  }
  return len3;
}
function charAtLength(str4, i) {
  if (str4.charCodeAt(i) > 0 && str4.charCodeAt(i) < 128) {
    return 1;
  } else {
    return 2;
  }
}
function ellipsisString(str4, reseveLength, position) {
  if (position === void 0) {
    position = "tail";
  }
  var count2 = str4.length;
  var rst = "";
  if (position === "tail") {
    for (var i = 0, index = 0; i < reseveLength; ) {
      var charLength = charAtLength(str4, index);
      if (i + charLength <= reseveLength) {
        rst += str4[index];
        i += charAtLength(str4, index);
        index++;
      } else {
        break;
      }
    }
    rst += ELLIPSIS_CODE;
  } else if (position === "head") {
    for (var i = 0, index = count2 - 1; i < reseveLength; ) {
      var charLength = charAtLength(str4, index);
      if (i + charLength <= reseveLength) {
        rst += str4[index];
        i += charAtLength(str4, index);
        index--;
      } else {
        break;
      }
    }
    rst = ELLIPSIS_CODE + rst;
  } else {
    var startStr = "";
    var endStr = "";
    for (var i = 0, startIndex = 0, endIndex = count2 - 1; i < reseveLength; ) {
      var startCodeLen = charAtLength(str4, startIndex);
      var hasAdd = false;
      if (startCodeLen + i <= reseveLength) {
        startStr += str4[startIndex];
        startIndex++;
        i += startCodeLen;
        hasAdd = true;
      }
      var endCodeLen = charAtLength(str4, endIndex);
      if (endCodeLen + i <= reseveLength) {
        endStr = str4[endIndex] + endStr;
        i += endCodeLen;
        endIndex--;
        hasAdd = true;
      }
      if (!hasAdd) {
        break;
      }
    }
    rst = startStr + ELLIPSIS_CODE + endStr;
  }
  return rst;
}

// node_modules/@antv/component/esm/util/label.js
var ELLIPSIS_CODE2 = "";
var ELLIPSIS_CODE_LENGTH = 2;
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function(label17) {
    var text = label17.attr("text");
    return is_nil_default(text) ? "" : "" + text;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i = 0; i < texts.length; i += 1) {
    var len3 = 0;
    for (var j = 0; j <= texts[i].length; j += 1) {
      var code2 = texts[i].charCodeAt(j);
      if (code2 >= 19968 && code2 <= 40869) {
        len3 += 2;
      } else {
        len3 += 1;
      }
    }
    if (len3 > maxLen) {
      maxLen = len3;
      maxIdx = i;
    }
  }
  return labels[maxIdx].getBBox().width;
}
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max5 = 0;
  each_default(labels, function(label17) {
    var bbox = label17.getBBox();
    var width = bbox.width;
    if (max5 < width) {
      max5 = width;
    }
  });
  return max5;
}
function getLabelLength(isVertical2, label17) {
  var bbox = label17.getCanvasBBox();
  return isVertical2 ? bbox.width : bbox.height;
}
function ellipsisLabel(isVertical2, label17, limitLength, position) {
  var _a6;
  if (position === void 0) {
    position = "tail";
  }
  var text = (_a6 = label17.attr("text")) !== null && _a6 !== void 0 ? _a6 : "";
  if (position === "tail") {
    var font = pick_default(label17.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
    var ellipsisText = get_ellipsis_text_default(text, limitLength, font, "");
    if (text !== ellipsisText) {
      label17.attr("text", ellipsisText);
      label17.set("tip", text);
      return true;
    }
    label17.set("tip", null);
    return false;
  }
  var labelLength = getLabelLength(isVertical2, label17);
  var codeLength = strLen(text);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = ellipsisString(text, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE2;
    }
    if (newText) {
      label17.attr("text", newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label17.set("tip", text);
  } else {
    label17.set("tip", null);
  }
  return ellipsisFlag;
}

// node_modules/@antv/component/esm/util/graphic.js
function renderTag(container, tagCfg) {
  var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate5 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id + "-group",
    name: name + "-group",
    attrs: {
      x,
      y
    }
  });
  var text = tagGroup.addShape({
    type: "text",
    id,
    name,
    attrs: __assign({ x: 0, y: 0, text: content }, style)
  });
  var padding3 = formatPadding(get_default(background, "padding", 0));
  if (maxLength && autoEllipsis) {
    var maxTextLength = maxLength - (padding3[1] + padding3[3]);
    ellipsisLabel(!isVertical2, text, maxTextLength, ellipsisPosition);
  }
  if (background) {
    var backgroundStyle = get_default(background, "style", {});
    var _a6 = text.getCanvasBBox(), minX = _a6.minX, minY = _a6.minY, width = _a6.width, height = _a6.height;
    var tagBg = tagGroup.addShape("rect", {
      id: id + "-bg",
      name: id + "-bg",
      attrs: __assign({ x: minX - padding3[3], y: minY - padding3[0], width: width + padding3[1] + padding3[3], height: height + padding3[0] + padding3[2] }, backgroundStyle)
    });
    tagBg.toBack();
  }
  applyTranslate(tagGroup, x, y);
  applyRotate(tagGroup, rotate5, x, y);
}

// node_modules/@antv/component/esm/util/theme.js
var theme_default = {
  fontFamily: '\n  BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
  textColor: "#2C3542",
  activeTextColor: "#333333",
  uncheckedColor: "#D8D8D8",
  lineColor: "#416180",
  regionColor: "#CCD7EB",
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4,
  // descriptionIcon theme
  descriptionIconStroke: "#fff",
  descriptionIconFill: "rgba(58, 73, 101, .25)"
};

// node_modules/@antv/component/esm/annotation/line.js
var LineAnnotation = (
  /** @class */
  function(_super) {
    __extends(LineAnnotation2, _super);
    function LineAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "bottom",
          fontFamily: theme_default.fontFamily
        },
        text: {
          position: "center",
          autoRotate: true,
          content: null,
          offsetX: 0,
          offsetY: 0,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        }
      } });
    };
    LineAnnotation2.prototype.renderInner = function(group2) {
      this.renderLine(group2);
      if (this.get("text")) {
        this.renderLabel(group2);
      }
    };
    LineAnnotation2.prototype.renderLine = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      this.addShape(group2, {
        type: "line",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: __assign({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
      });
    };
    LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
      var percent2;
      if (position === "start") {
        percent2 = 0;
      } else if (position === "center") {
        percent2 = 0.5;
      } else if (is_string_default(position) && position.indexOf("%") !== -1) {
        percent2 = parseInt(position, 10) / 100;
      } else if (is_number_default(position)) {
        percent2 = position;
      } else {
        percent2 = 1;
      }
      if (percent2 > 1 || percent2 < 0) {
        percent2 = 1;
      }
      return {
        x: getValueByPercent(start.x, end.x, percent2),
        y: getValueByPercent(start.y, end.y, percent2)
      };
    };
    LineAnnotation2.prototype.renderLabel = function(group2) {
      var text = this.get("text");
      var start = this.get("start");
      var end = this.get("end");
      var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a6 = text.isVertical, isVertical2 = _a6 === void 0 ? false : _a6;
      var point2 = this.getLabelPoint(start, end, position);
      var x = point2.x + offsetX;
      var y = point2.y + offsetY;
      var cfg = {
        id: this.getElementId("line-text"),
        name: "annotation-line-text",
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        ellipsisPosition,
        background,
        isVertical: isVertical2
      };
      if (autoRotate) {
        var vector = [end.x - start.x, end.y - start.y];
        cfg.rotate = Math.atan2(vector[1], vector[0]);
      }
      renderTag(group2, cfg);
    };
    return LineAnnotation2;
  }(group_component_default)
);
var line_default3 = LineAnnotation;

// node_modules/@antv/component/esm/annotation/text.js
var TextAnnotation = (
  /** @class */
  function(_super) {
    __extends(TextAnnotation2, _super);
    function TextAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TextAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: theme_default.fontFamily
        }
      } });
    };
    TextAnnotation2.prototype.setLocation = function(location) {
      this.set("x", location.x);
      this.set("y", location.y);
      this.resetLocation();
    };
    TextAnnotation2.prototype.renderInner = function(group2) {
      var _a6 = this.getLocation(), x = _a6.x, y = _a6.y;
      var content = this.get("content");
      var style = this.get("style");
      var id = this.getElementId("text");
      var name = this.get("name") + "-text";
      var maxLength = this.get("maxLength");
      var autoEllipsis = this.get("autoEllipsis");
      var isVertical2 = this.get("isVertical");
      var ellipsisPosition = this.get("ellipsisPosition");
      var background = this.get("background");
      var rotate5 = this.get("rotate");
      var cfg = {
        id,
        name,
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        isVertical: isVertical2,
        ellipsisPosition,
        background,
        rotate: rotate5
      };
      renderTag(group2, cfg);
    };
    TextAnnotation2.prototype.resetLocation = function() {
      var textGroup = this.getElementByLocalId("text-group");
      if (textGroup) {
        var _a6 = this.getLocation(), x = _a6.x, y = _a6.y;
        var rotate5 = this.get("rotate");
        applyTranslate(textGroup, x, y);
        applyRotate(textGroup, rotate5, x, y);
      }
    };
    return TextAnnotation2;
  }(group_component_default)
);
var text_default2 = TextAnnotation;

// node_modules/@antv/component/esm/annotation/arc.js
var ArcAnnotation = (
  /** @class */
  function(_super) {
    __extends(ArcAnnotation2, _super);
    function ArcAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ArcAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
        stroke: "#999",
        lineWidth: 1
      } });
    };
    ArcAnnotation2.prototype.renderInner = function(group2) {
      this.renderArc(group2);
    };
    ArcAnnotation2.prototype.getArcPath = function() {
      var _a6 = this.getLocation(), center2 = _a6.center, radius = _a6.radius, startAngle = _a6.startAngle, endAngle = _a6.endAngle;
      var startPoint = getCirclePoint(center2, radius, startAngle);
      var endPoint = getCirclePoint(center2, radius, endAngle);
      var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
      var path = [["M", startPoint.x, startPoint.y]];
      if (endAngle - startAngle === Math.PI * 2) {
        var middlePoint = getCirclePoint(center2, radius, startAngle + Math.PI);
        path.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      } else {
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      }
      return path;
    };
    ArcAnnotation2.prototype.renderArc = function(group2) {
      var path = this.getArcPath();
      var style = this.get("style");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("arc"),
        name: "annotation-arc",
        attrs: __assign({ path }, style)
      });
    };
    return ArcAnnotation2;
  }(group_component_default)
);
var arc_default2 = ArcAnnotation;

// node_modules/@antv/component/esm/annotation/region.js
var RegionAnnotation = (
  /** @class */
  function(_super) {
    __extends(RegionAnnotation2, _super);
    function RegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
        style: {
          lineWidth: 0,
          fill: theme_default.regionColor,
          opacity: 0.4
        }
      } });
    };
    RegionAnnotation2.prototype.renderInner = function(group2) {
      this.renderRegion(group2);
    };
    RegionAnnotation2.prototype.renderRegion = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
      });
    };
    return RegionAnnotation2;
  }(group_component_default)
);
var region_default = RegionAnnotation;

// node_modules/@antv/component/esm/annotation/image.js
var ImageAnnotation = (
  /** @class */
  function(_super) {
    __extends(ImageAnnotation2, _super);
    function ImageAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
    };
    ImageAnnotation2.prototype.renderInner = function(group2) {
      this.renderImage(group2);
    };
    ImageAnnotation2.prototype.getImageAttrs = function() {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      var src = this.get("src");
      return __assign({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
    };
    ImageAnnotation2.prototype.renderImage = function(group2) {
      this.addShape(group2, {
        type: "image",
        id: this.getElementId("image"),
        name: "annotation-image",
        attrs: this.getImageAttrs()
      });
    };
    return ImageAnnotation2;
  }(group_component_default)
);
var image_default = ImageAnnotation;

// node_modules/@antv/component/esm/annotation/data-marker.js
var DataMarkerAnnotation = (
  /** @class */
  function(_super) {
    __extends(DataMarkerAnnotation2, _super);
    function DataMarkerAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
        point: {
          display: true,
          style: {
            r: 3,
            fill: "#FFFFFF",
            stroke: "#1890FF",
            lineWidth: 2
          }
        },
        line: {
          display: true,
          length: 20,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        },
        text: {
          content: "",
          display: true,
          style: {
            fill: theme_default.textColor,
            opacity: 0.65,
            fontSize: 12,
            textAlign: "start",
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataMarkerAnnotation2.prototype.renderInner = function(group2) {
      if (get_default(this.get("line"), "display")) {
        this.renderLine(group2);
      }
      if (get_default(this.get("text"), "display")) {
        this.renderText(group2);
      }
      if (get_default(this.get("point"), "display")) {
        this.renderPoint(group2);
      }
      if (this.get("autoAdjust")) {
        this.autoAdjust(group2);
      }
    };
    DataMarkerAnnotation2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x") + this.get("offsetX"),
        y: this.get("y") + this.get("offsetY")
      });
    };
    DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
      var point2 = this.getShapeAttrs().point;
      this.addShape(group2, {
        type: "circle",
        id: this.getElementId("point"),
        name: "annotation-point",
        attrs: point2
      });
    };
    DataMarkerAnnotation2.prototype.renderLine = function(group2) {
      var line2 = this.getShapeAttrs().line;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: line2
      });
    };
    DataMarkerAnnotation2.prototype.renderText = function(group2) {
      var textAttrs = this.getShapeAttrs().text;
      var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = __rest(textAttrs, ["x", "y", "text"]);
      var _a6 = this.get("text"), background = _a6.background, maxLength = _a6.maxLength, autoEllipsis = _a6.autoEllipsis, isVertival = _a6.isVertival, ellipsisPosition = _a6.ellipsisPosition;
      var tagCfg = {
        x,
        y,
        id: this.getElementId("text"),
        name: "annotation-text",
        content: text,
        style,
        background,
        maxLength,
        autoEllipsis,
        isVertival,
        ellipsisPosition
      };
      renderTag(group2, tagCfg);
    };
    DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
      var direction2 = this.get("direction");
      var x = this.get("x");
      var y = this.get("y");
      var lineLength = get_default(this.get("line"), "length", 0);
      var coordinateBBox = this.get("coordinateBBox");
      var _a6 = group2.getBBox(), minX = _a6.minX, maxX = _a6.maxX, minY = _a6.minY, maxY2 = _a6.maxY;
      var textGroup = group2.findById(this.getElementId("text-group"));
      var textShape = group2.findById(this.getElementId("text"));
      var lineShape = group2.findById(this.getElementId("line"));
      if (!coordinateBBox) {
        return;
      }
      if (textGroup) {
        var translateX = textGroup.attr("x"), translateY = textGroup.attr("y");
        var _b = textShape.getCanvasBBox(), width = _b.width, height = _b.height;
        var xFactor = 0, yFactor = 0;
        if (x + minX <= coordinateBBox.minX) {
          if (direction2 === "leftward") {
            xFactor = 1;
          } else {
            var overflow = coordinateBBox.minX - (x + minX);
            translateX = textGroup.attr("x") + overflow;
          }
        } else if (x + maxX >= coordinateBBox.maxX) {
          if (direction2 === "rightward") {
            xFactor = -1;
          } else {
            var overflow = x + maxX - coordinateBBox.maxX;
            translateX = textGroup.attr("x") - overflow;
          }
        }
        if (!!xFactor) {
          if (lineShape) {
            lineShape.attr("path", [
              ["M", 0, 0],
              ["L", lineLength * xFactor, 0]
            ]);
          }
          translateX = (lineLength + 2 + width) * xFactor;
        }
        if (y + minY <= coordinateBBox.minY) {
          if (direction2 === "upward") {
            yFactor = 1;
          } else {
            var overflow = coordinateBBox.minY - (y + minY);
            translateY = textGroup.attr("y") + overflow;
          }
        } else if (y + maxY2 >= coordinateBBox.maxY) {
          if (direction2 === "downward") {
            yFactor = -1;
          } else {
            var overflow = y + maxY2 - coordinateBBox.maxY;
            translateY = textGroup.attr("y") - overflow;
          }
        }
        if (!!yFactor) {
          if (lineShape) {
            lineShape.attr("path", [
              ["M", 0, 0],
              ["L", 0, lineLength * yFactor]
            ]);
          }
          translateY = (lineLength + 2 + height) * yFactor;
        }
        if (translateX !== textGroup.attr("x") || translateY !== textGroup.attr("y"))
          applyTranslate(textGroup, translateX, translateY);
      }
    };
    DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
      var lineDisplay = get_default(this.get("line"), "display");
      var pointStyle = get_default(this.get("point"), "style", {});
      var lineStyle = get_default(this.get("line"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var direction2 = this.get("direction");
      var lineLength = lineDisplay ? get_default(this.get("line"), "length", 0) : 0;
      var xFactor = 0, yFactor = 0;
      var textBaseline = "top", textAlign = "start";
      switch (direction2) {
        case "upward":
          yFactor = -1;
          textBaseline = "bottom";
          break;
        case "downward":
          yFactor = 1;
          textBaseline = "top";
          break;
        case "leftward":
          xFactor = -1;
          textAlign = "end";
          break;
        case "rightward":
          xFactor = 1;
          textAlign = "start";
          break;
      }
      return {
        point: __assign({ x: 0, y: 0 }, pointStyle),
        line: __assign({ path: [
          ["M", 0, 0],
          ["L", lineLength * xFactor, lineLength * yFactor]
        ] }, lineStyle),
        text: __assign({
          x: (lineLength + 2) * xFactor,
          y: (lineLength + 2) * yFactor,
          text: get_default(this.get("text"), "content", ""),
          textBaseline,
          textAlign
        }, textStyle2)
      };
    };
    return DataMarkerAnnotation2;
  }(group_component_default)
);
var data_marker_default = DataMarkerAnnotation;

// node_modules/@antv/component/esm/annotation/data-region.js
var DataRegionAnnotation = (
  /** @class */
  function(_super) {
    __extends(DataRegionAnnotation2, _super);
    function DataRegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataRegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
        region: {
          style: {
            lineWidth: 0,
            fill: theme_default.regionColor,
            opacity: 0.4
          }
        },
        text: {
          content: "",
          style: {
            textAlign: "center",
            textBaseline: "bottom",
            fontSize: 12,
            fill: theme_default.textColor,
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataRegionAnnotation2.prototype.renderInner = function(group2) {
      var regionStyle = get_default(this.get("region"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var lineLength = this.get("lineLength") || 0;
      var points2 = this.get("points");
      if (!points2.length) {
        return;
      }
      var bbox = pointsToBBox(points2);
      var path = [];
      path.push(["M", points2[0].x, bbox.minY - lineLength]);
      points2.forEach(function(point2) {
        path.push(["L", point2.x, point2.y]);
      });
      path.push(["L", points2[points2.length - 1].x, points2[points2.length - 1].y - lineLength]);
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign({ path }, regionStyle)
      });
      var textCfg = __assign({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
      renderTag(group2, textCfg);
    };
    return DataRegionAnnotation2;
  }(group_component_default)
);
var data_region_default = DataRegionAnnotation;

// node_modules/@antv/component/esm/annotation/region-filter.js
var RegionFilterAnnotation = (
  /** @class */
  function(_super) {
    __extends(RegionFilterAnnotation2, _super);
    function RegionFilterAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
    };
    RegionFilterAnnotation2.prototype.renderInner = function(group2) {
      var _this = this;
      var start = this.get("start");
      var end = this.get("end");
      var layer = this.addGroup(group2, {
        id: this.getElementId("region-filter"),
        capture: false
      });
      each_default(this.get("shapes"), function(shape, shapeIdx) {
        var type = shape.get("type");
        var attrs = clone_default(shape.attr());
        _this.adjustShapeAttrs(attrs);
        _this.addShape(layer, {
          id: _this.getElementId("shape-" + type + "-" + shapeIdx),
          capture: false,
          type,
          attrs
        });
      });
      var clipBBox = regionToBBox({ start, end });
      layer.setClip({
        type: "rect",
        attrs: {
          x: clipBBox.minX,
          y: clipBBox.minY,
          width: clipBBox.width,
          height: clipBBox.height
        }
      });
    };
    RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
      var color3 = this.get("color");
      if (attr.fill) {
        attr.fill = attr.fillStyle = color3;
      }
      attr.stroke = attr.strokeStyle = color3;
    };
    return RegionFilterAnnotation2;
  }(group_component_default)
);
var region_filter_default = RegionFilterAnnotation;

// node_modules/@antv/component/esm/annotation/shape.js
var ShapeAnnotation = (
  /** @class */
  function(_super) {
    __extends(ShapeAnnotation2, _super);
    function ShapeAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "shape", draw: noop_default });
    };
    ShapeAnnotation2.prototype.renderInner = function(group2) {
      var render = this.get("render");
      if (is_function_default(render)) {
        render(group2);
      }
    };
    return ShapeAnnotation2;
  }(group_component_default)
);
var shape_default3 = ShapeAnnotation;

// node_modules/@antv/component/esm/abstract/html-component.js
var HtmlComponent = (
  /** @class */
  function(_super) {
    __extends(HtmlComponent2, _super);
    function HtmlComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
    };
    HtmlComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    HtmlComponent2.prototype.show = function() {
      var container = this.get("container");
      container.style.display = "";
      this.set("visible", true);
    };
    HtmlComponent2.prototype.hide = function() {
      var container = this.get("container");
      container.style.display = "none";
      this.set("visible", false);
    };
    HtmlComponent2.prototype.setCapture = function(capture) {
      var container = this.getContainer();
      var value2 = capture ? "auto" : "none";
      container.style.pointerEvents = value2;
      this.set("capture", capture);
    };
    HtmlComponent2.prototype.getBBox = function() {
      var container = this.getContainer();
      var x = parseFloat(container.style.left) || 0;
      var y = parseFloat(container.style.top) || 0;
      return createBBox(x, y, container.clientWidth, container.clientHeight);
    };
    HtmlComponent2.prototype.clear = function() {
      var container = this.get("container");
      clearDom(container);
    };
    HtmlComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    HtmlComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.initContainer();
      this.initDom();
      this.resetStyles();
      this.applyStyles();
      this.initEvent();
      this.initCapture();
      this.initVisible();
    };
    HtmlComponent2.prototype.initCapture = function() {
      this.setCapture(this.get("capture"));
    };
    HtmlComponent2.prototype.initVisible = function() {
      if (!this.get("visible")) {
        this.hide();
      } else {
        this.show();
      }
    };
    HtmlComponent2.prototype.initDom = function() {
    };
    HtmlComponent2.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_nil_default(container)) {
        container = this.createDom();
        var parent_1 = this.get("parent");
        if (is_string_default(parent_1)) {
          parent_1 = document.getElementById(parent_1);
          this.set("parent", parent_1);
        }
        parent_1.appendChild(container);
        if (this.get("containerId")) {
          container.setAttribute("id", this.get("containerId"));
        }
        this.set("container", container);
      } else if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!this.get("parent")) {
        this.set("parent", container.parentNode);
      }
    };
    HtmlComponent2.prototype.resetStyles = function() {
      var style = this.get("domStyles");
      var defaultStyles = this.get("defaultStyles");
      if (!style) {
        style = defaultStyles;
      } else {
        style = deep_mix_default({}, defaultStyles, style);
      }
      this.set("domStyles", style);
    };
    HtmlComponent2.prototype.applyStyles = function() {
      var domStyles = this.get("domStyles");
      if (!domStyles) {
        return;
      }
      var container = this.getContainer();
      this.applyChildrenStyles(container, domStyles);
      var containerClassName = this.get("containerClassName");
      if (containerClassName && hasClass(container, containerClassName)) {
        var containerCss = domStyles[containerClassName];
        modifyCSS(container, containerCss);
      }
    };
    HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
      each_default(styles, function(style, name) {
        var elements = element.getElementsByClassName(name);
        each_default(elements, function(el) {
          modifyCSS(el, style);
        });
      });
    };
    HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
      var domStyles = this.get("domStyles");
      modifyCSS(dom, domStyles[cssName]);
    };
    HtmlComponent2.prototype.createDom = function() {
      var containerTpl = this.get("containerTpl");
      return createDom(containerTpl);
    };
    HtmlComponent2.prototype.initEvent = function() {
    };
    HtmlComponent2.prototype.removeDom = function() {
      var container = this.get("container");
      container && container.parentNode && container.parentNode.removeChild(container);
    };
    HtmlComponent2.prototype.removeEvent = function() {
    };
    HtmlComponent2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "domStyles")) {
        this.resetStyles();
        this.applyStyles();
      }
      this.resetPosition();
    };
    HtmlComponent2.prototype.resetPosition = function() {
    };
    ;
    return HtmlComponent2;
  }(component_default)
);
var html_component_default = HtmlComponent;

// node_modules/@antv/component/esm/annotation/html.js
var HtmlAnnotation = (
  /** @class */
  function(_super) {
    __extends(HtmlAnnotation2, _super);
    function HtmlAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation" style="position:absolute"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
    };
    HtmlAnnotation2.prototype.render = function() {
      var container = this.getContainer();
      var html = this.get("html");
      clearDom(container);
      var rst = is_function_default(html) ? html(container) : html;
      if (is_element_default(rst)) {
        container.appendChild(rst);
      } else if (is_string_default(rst) || is_number_default(rst)) {
        var dom = createDom("" + rst);
        if (dom) {
          container.appendChild(dom);
        }
      }
      this.resetPosition();
    };
    HtmlAnnotation2.prototype.resetPosition = function() {
      var container = this.getContainer();
      var _a6 = this.getLocation(), x = _a6.x, y = _a6.y;
      var alignX = this.get("alignX");
      var alignY = this.get("alignY");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var domWidth = getOuterWidth(container);
      var domHeight = getOuterHeight(container);
      var position = {
        x,
        y
      };
      if (alignX === "middle") {
        position.x -= Math.round(domWidth / 2);
      } else if (alignX === "right") {
        position.x -= Math.round(domWidth);
      }
      if (alignY === "middle") {
        position.y -= Math.round(domHeight / 2);
      } else if (alignY === "bottom") {
        position.y -= Math.round(domHeight);
      }
      if (offsetX) {
        position.x += offsetX;
      }
      if (offsetY) {
        position.y += offsetY;
      }
      modifyCSS(container, {
        position: "absolute",
        left: position.x + "px",
        top: position.y + "px",
        zIndex: this.get("zIndex")
      });
    };
    return HtmlAnnotation2;
  }(html_component_default)
);
var html_default = HtmlAnnotation;

// node_modules/@antv/component/esm/axis/index.js
var axis_exports = {};
__export(axis_exports, {
  Base: () => base_default8,
  Circle: () => circle_default2,
  Line: () => line_default4
});

// node_modules/@antv/component/esm/util/state.js
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style";
  var styles = null;
  each_default(stateStyles, function(v, state2) {
    if (item[state2] && v[styleName]) {
      if (!styles) {
        styles = {};
      }
      mix(styles, v[styleName]);
    }
  });
  return styles;
}

// node_modules/@antv/component/esm/axis/base.js
var AxisBase = (
  /** @class */
  function(_super) {
    __extends(AxisBase2, _super);
    function AxisBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        name: "axis",
        ticks: [],
        line: {},
        tickLine: {},
        subTickLine: null,
        title: null,
        /**
         * 
         */
        label: {},
        /**
         * titletickLine 
         */
        verticalFactor: 1,
        // 
        verticalLimitLength: null,
        overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
        tickStates: {},
        optimize: {},
        defaultCfg: {
          line: {
            // @type {Attrs} ,null
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            }
          },
          tickLine: {
            // @type {Attrs} 
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            alignTick: true,
            length: 5,
            displayWithLabel: true
          },
          subTickLine: {
            // @type {Attrs} 
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            count: 4,
            length: 2
          },
          label: {
            autoRotate: true,
            autoHide: false,
            autoEllipsis: false,
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              fontFamily: theme_default.fontFamily,
              fontWeight: "normal"
            },
            offset: 10,
            offsetX: 0,
            offsetY: 0
          },
          title: {
            autoRotate: true,
            spacing: 5,
            position: "center",
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              textBaseline: "middle",
              fontFamily: theme_default.fontFamily,
              textAlign: "center"
            },
            iconStyle: {
              fill: theme_default.descriptionIconFill,
              stroke: theme_default.descriptionIconStroke
            },
            description: ""
          },
          tickStates: {
            active: {
              labelStyle: {
                fontWeight: 500
              },
              tickLineStyle: {
                lineWidth: 2
              }
            },
            inactive: {
              labelStyle: {
                fill: theme_default.uncheckedColor
              }
            }
          },
          // 
          optimize: {
            enable: true,
            threshold: 400
          }
        },
        theme: {}
      });
    };
    AxisBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.drawLine(group2);
      }
      this.drawTicks(group2);
      if (this.get("title")) {
        this.drawTitle(group2);
      }
    };
    AxisBase2.prototype.isList = function() {
      return true;
    };
    AxisBase2.prototype.getItems = function() {
      return this.get("ticks");
    };
    AxisBase2.prototype.setItems = function(items) {
      this.update({
        ticks: items
      });
    };
    AxisBase2.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    AxisBase2.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("label-group");
      itemGroup && itemGroup.clear();
    };
    AxisBase2.prototype.setItemState = function(item, state2, value2) {
      item[state2] = value2;
      this.updateTickStates(item);
    };
    AxisBase2.prototype.hasState = function(item, state2) {
      return !!item[state2];
    };
    AxisBase2.prototype.getItemStates = function(item) {
      var tickStates = this.get("tickStates");
      var rst = [];
      each_default(tickStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    AxisBase2.prototype.clearItemsState = function(state2) {
      var _this = this;
      var items = this.getItemsByState(state2);
      each_default(items, function(item) {
        _this.setItemState(item, state2, false);
      });
    };
    AxisBase2.prototype.getItemsByState = function(state2) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state2);
      });
    };
    AxisBase2.prototype.getSidePoint = function(point2, offset) {
      var self2 = this;
      var vector = self2.getSideVector(offset, point2);
      return {
        x: point2.x + vector[0],
        y: point2.y + vector[1]
      };
    };
    AxisBase2.prototype.getTextAnchor = function(vector) {
      var align;
      if (isNumberEqual(vector[0], 0)) {
        align = "center";
      } else if (vector[0] > 0) {
        align = "start";
      } else if (vector[0] < 0) {
        align = "end";
      }
      return align;
    };
    AxisBase2.prototype.getTextBaseline = function(vector) {
      var base;
      if (isNumberEqual(vector[1], 0)) {
        base = "middle";
      } else if (vector[1] > 0) {
        base = "top";
      } else if (vector[1] < 0) {
        base = "bottom";
      }
      return base;
    };
    AxisBase2.prototype.processOverlap = function(labelGroup) {
    };
    AxisBase2.prototype.drawLine = function(group2) {
      var path = this.getLinePath();
      var line2 = this.get("line");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "axis-line",
        attrs: mix({
          path
        }, line2.style)
      });
    };
    AxisBase2.prototype.getTickLineItems = function(ticks) {
      var _this = this;
      var tickLineItems = [];
      var tickLine = this.get("tickLine");
      var alignTick = tickLine.alignTick;
      var tickLineLength = tickLine.length;
      var tickSegment = 1;
      var tickCount = ticks.length;
      if (tickCount >= 2) {
        tickSegment = ticks[1].value - ticks[0].value;
      }
      each_default(ticks, function(tick) {
        var point2 = tick.point;
        if (!alignTick) {
          point2 = _this.getTickPoint(tick.value - tickSegment / 2);
        }
        var endPoint = _this.getSidePoint(point2, tickLineLength);
        tickLineItems.push({
          startPoint: point2,
          tickValue: tick.value,
          endPoint,
          tickId: tick.id,
          id: "tickline-" + tick.id
        });
      });
      return tickLineItems;
    };
    AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
      var subTickLineItems = [];
      var subTickLine = this.get("subTickLine");
      var subCount = subTickLine.count;
      var tickLineCount = tickLineItems.length;
      if (tickLineCount >= 2) {
        for (var i = 0; i < tickLineCount - 1; i++) {
          var pre = tickLineItems[i];
          var next = tickLineItems[i + 1];
          for (var j = 0; j < subCount; j++) {
            var percent2 = (j + 1) / (subCount + 1);
            var tickValue = (1 - percent2) * pre.tickValue + percent2 * next.tickValue;
            var point2 = this.getTickPoint(tickValue);
            var endPoint = this.getSidePoint(point2, subTickLine.length);
            subTickLineItems.push({
              startPoint: point2,
              endPoint,
              tickValue,
              id: "sub-" + pre.id + "-" + j
            });
          }
        }
      }
      return subTickLineItems;
    };
    AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index, tickItems) {
      var style = this.get(type).style;
      var item = {
        points: [tickItem.startPoint, tickItem.endPoint]
      };
      var defaultTickLineStyle = get_default(this.get("theme"), ["tickLine", "style"], {});
      style = is_function_default(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
      var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
      return __assign({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
    };
    AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index, tickItems) {
      this.addShape(tickLineGroup, {
        type: "line",
        id: this.getElementId(tickItem.id),
        name: "axis-" + type,
        attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
      });
    };
    AxisBase2.prototype.drawTickLines = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var subTickLine = this.get("subTickLine");
      var tickLineItems = this.getTickLineItems(ticks);
      var tickLineGroup = this.addGroup(group2, {
        name: "axis-tickline-group",
        id: this.getElementId("tickline-group")
      });
      var tickCfg = this.get("tickLine");
      each_default(tickLineItems, function(item, index) {
        if (tickCfg.displayWithLabel) {
          var labelId = _this.getElementId("label-" + item.tickId);
          if (group2.findById(labelId)) {
            _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
          }
        } else {
          _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
        }
      });
      if (subTickLine) {
        var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
        each_default(subTickLineItems_1, function(item, index) {
          _this.drawTick(item, tickLineGroup, "subTickLine", index, subTickLineItems_1);
        });
      }
    };
    AxisBase2.prototype.processTicks = function() {
      var _this = this;
      var ticks = this.get("ticks");
      each_default(ticks, function(tick) {
        tick.point = _this.getTickPoint(tick.value);
        if (is_nil_default(tick.id)) {
          tick.id = tick.name;
        }
      });
    };
    AxisBase2.prototype.drawTicks = function(group2) {
      var _this = this;
      this.optimizeTicks();
      this.processTicks();
      if (this.get("label")) {
        this.drawLabels(group2);
      }
      if (this.get("tickLine")) {
        this.drawTickLines(group2);
      }
      var ticks = this.get("ticks");
      each_default(ticks, function(tick) {
        _this.applyTickStates(tick, group2);
      });
    };
    AxisBase2.prototype.optimizeTicks = function() {
      var optimize = this.get("optimize");
      var ticks = this.get("ticks");
      if (optimize && optimize.enable && optimize.threshold > 0) {
        var len3 = size(ticks);
        if (len3 > optimize.threshold) {
          var page_1 = Math.ceil(len3 / optimize.threshold);
          var optimizedTicks = ticks.filter(function(tick, idx) {
            return idx % page_1 === 0;
          });
          this.set("ticks", optimizedTicks);
          this.set("originalTicks", ticks);
        }
      }
    };
    AxisBase2.prototype.getLabelAttrs = function(tick, index, ticks) {
      var labelCfg = this.get("label");
      var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate5 = labelCfg.rotate, formatter = labelCfg.formatter;
      var point2 = this.getSidePoint(tick.point, offset);
      var vector = this.getSideVector(offset, point2);
      var text = formatter ? formatter(tick.name, tick, index) : tick.name;
      var style = labelCfg.style;
      style = is_function_default(style) ? get_default(this.get("theme"), ["label", "style"], {}) : style;
      var attrs = mix({
        x: point2.x + offsetX,
        y: point2.y + offsetY,
        text,
        textAlign: this.getTextAnchor(vector),
        textBaseline: this.getTextBaseline(vector)
      }, style);
      if (rotate5) {
        attrs.matrix = getMatrixByAngle(point2, rotate5);
      }
      return attrs;
    };
    AxisBase2.prototype.drawLabels = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var labelGroup = this.addGroup(group2, {
        name: "axis-label-group",
        id: this.getElementId("label-group")
      });
      each_default(ticks, function(tick, index) {
        _this.addShape(labelGroup, {
          type: "text",
          name: "axis-label",
          id: _this.getElementId("label-" + tick.id),
          attrs: _this.getLabelAttrs(tick, index, ticks),
          delegateObject: {
            tick,
            item: tick,
            index
          }
        });
      });
      this.processOverlap(labelGroup);
      var labels = labelGroup.getChildren();
      var defaultLabelStyle = get_default(this.get("theme"), ["label", "style"], {});
      var _a6 = this.get("label"), style = _a6.style, formatter = _a6.formatter;
      if (is_function_default(style)) {
        var afterProcessTicks_1 = labels.map(function(label17) {
          return get_default(label17.get("delegateObject"), "tick");
        });
        each_default(labels, function(label17, index) {
          var tick = label17.get("delegateObject").tick;
          var text = formatter ? formatter(tick.name, tick, index) : tick.name;
          var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
          label17.attr(newStyle);
        });
      }
    };
    AxisBase2.prototype.getTitleAttrs = function() {
      var titleCfg = this.get("title");
      var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a6 = titleCfg.spacing, spacing = _a6 === void 0 ? 0 : _a6, autoRotate = titleCfg.autoRotate;
      var titleHeight = style.fontSize;
      var percent2 = 0.5;
      if (position === "start") {
        percent2 = 0;
      } else if (position === "end") {
        percent2 = 1;
      }
      var point2 = this.getTickPoint(percent2);
      var titlePoint = this.getSidePoint(point2, offset || spacing + titleHeight / 2);
      var attrs = mix({
        x: titlePoint.x,
        y: titlePoint.y,
        text: titleCfg.text
      }, style);
      var rotate5 = titleCfg.rotate;
      var angle4 = rotate5;
      if (is_nil_default(rotate5) && autoRotate) {
        var vector = this.getAxisVector(point2);
        var v1 = [1, 0];
        angle4 = ext_exports.angleTo(vector, v1, true);
      }
      if (angle4) {
        var matrix = getMatrixByAngle(titlePoint, angle4);
        attrs.matrix = matrix;
      }
      return attrs;
    };
    AxisBase2.prototype.drawTitle = function(group2) {
      var _a6;
      var titleAttrs = this.getTitleAttrs();
      var titleShape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "axis-title",
        attrs: titleAttrs
      });
      if ((_a6 = this.get("title")) === null || _a6 === void 0 ? void 0 : _a6.description) {
        this.drawDescriptionIcon(group2, titleShape, titleAttrs.matrix);
      }
    };
    AxisBase2.prototype.drawDescriptionIcon = function(group2, titleShape, matrix) {
      var descriptionShape = this.addGroup(group2, {
        name: "axis-description",
        id: this.getElementById("description")
      });
      var _a6 = titleShape.getBBox(), maxX = _a6.maxX, maxY2 = _a6.maxY, height = _a6.height;
      var iconStyle = this.get("title").iconStyle;
      var spacing = 4;
      var r = height / 2;
      var lineWidth = r / 6;
      var startX = maxX + spacing;
      var startY = maxY2 - height / 2;
      var _b = [startX + r, startY - r], x0 = _b[0], y0 = _b[1];
      var _c = [x0 + r, y0 + r], x1 = _c[0], y1 = _c[1];
      var _d = [x0, y1 + r], x2 = _d[0], y2 = _d[1];
      var _e = [startX, y0 + r], x3 = _e[0], y3 = _e[1];
      var _f = [startX + r, startY - height / 4], x4 = _f[0], y4 = _f[1];
      var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
      var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
      var _j = [x6, y6 + r * 3 / 4], x7 = _j[0], y7 = _j[1];
      this.addShape(descriptionShape, {
        type: "path",
        id: this.getElementId("title-description-icon"),
        name: "axis-title-description-icon",
        attrs: __assign({
          path: [
            ["M", x0, y0],
            ["A", r, r, 0, 0, 1, x1, y1],
            ["A", r, r, 0, 0, 1, x2, y2],
            ["A", r, r, 0, 0, 1, x3, y3],
            ["A", r, r, 0, 0, 1, x0, y0],
            ["M", x4, y4],
            ["L", x5, y5],
            ["M", x6, y6],
            ["L", x7, y7]
          ],
          lineWidth,
          matrix
        }, iconStyle)
      });
      this.addShape(descriptionShape, {
        type: "rect",
        id: this.getElementId("title-description-rect"),
        name: "axis-title-description-rect",
        attrs: {
          x: startX,
          y: startY - height / 2,
          width: height,
          height,
          stroke: "#000",
          fill: "#000",
          opacity: 0,
          matrix,
          cursor: "pointer"
        }
      });
    };
    AxisBase2.prototype.applyTickStates = function(tick, group2) {
      var states = this.getItemStates(tick);
      if (states.length) {
        var tickStates = this.get("tickStates");
        var labelId = this.getElementId("label-" + tick.id);
        var labelShape = group2.findById(labelId);
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        var tickLineId = this.getElementId("tickline-" + tick.id);
        var tickLineShape = group2.findById(tickLineId);
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      }
    };
    AxisBase2.prototype.updateTickStates = function(tick) {
      var states = this.getItemStates(tick);
      var tickStates = this.get("tickStates");
      var labelCfg = this.get("label");
      var labelShape = this.getElementByLocalId("label-" + tick.id);
      var tickLineCfg = this.get("tickLine");
      var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
      if (states.length) {
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      } else {
        if (labelShape) {
          labelShape.attr(labelCfg.style);
        }
        if (tickLineShape) {
          tickLineShape.attr(tickLineCfg.style);
        }
      }
    };
    return AxisBase2;
  }(group_component_default)
);
var base_default8 = AxisBase;

// node_modules/@antv/component/esm/axis/overlap/index.js
var overlap_exports = {};
__export(overlap_exports, {
  autoEllipsis: () => auto_ellipsis_exports,
  autoHide: () => auto_hide_exports,
  autoRotate: () => auto_rotate_exports
});

// node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
var auto_ellipsis_exports = {};
__export(auto_ellipsis_exports, {
  ellipsisHead: () => ellipsisHead,
  ellipsisMiddle: () => ellipsisMiddle,
  ellipsisTail: () => ellipsisTail,
  getDefault: () => getDefault
});
function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsisFlag = false;
  each_default(children, function(label17) {
    var rst = ellipsisLabel(isVertical2, label17, limitLength, position);
    ellipsisFlag = ellipsisFlag || rst;
  });
  return ellipsisFlag;
}
function getDefault() {
  return ellipsisTail;
}
function ellipsisHead(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
}

// node_modules/@antv/component/esm/axis/overlap/auto-hide.js
var auto_hide_exports = {};
__export(auto_hide_exports, {
  equidistance: () => equidistance,
  equidistanceWithReverseBoth: () => equidistanceWithReverseBoth,
  getDefault: () => getDefault2,
  reserveBoth: () => reserveBoth,
  reserveFirst: () => reserveFirst,
  reserveLast: () => reserveLast
});
function isRotate(label17) {
  var matrix = label17.attr("matrix");
  return matrix && matrix[0] !== 1;
}
function getRotateAngle(label17) {
  var angle4 = isRotate(label17) ? getAngleByMatrix(label17.attr("matrix")) : 0;
  return angle4 % 360;
}
function isOverlap(isVertical2, first, second, minGap) {
  var overlap2 = false;
  var angle4 = getRotateAngle(first);
  var distance9 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle4));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance9;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance9;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle4));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance9;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance9;
    }
  }
  return overlap2;
}
function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice().filter(function(item) {
    return item.get("visible");
  });
  if (!labels.length) {
    return false;
  }
  var hasHide = false;
  if (reversed) {
    labels.reverse();
  }
  var count2 = labels.length;
  var first = labels[0];
  var prev = first;
  for (var i = 1; i < count2; i++) {
    var label17 = labels[i];
    var curBBox = label17.getBBox();
    var isHide = isOverlap(isVertical2, prev, label17, minGap);
    if (isHide) {
      label17.hide();
      hasHide = true;
    } else {
      prev = label17;
    }
  }
  return hasHide;
}
function parityHide(isVertical2, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length < 2) {
    return false;
  }
  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count2 = labels.length;
  var angle4 = getRotateAngle(first);
  var distance9 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var interval3 = 0;
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle4));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval3 = (maxWidth + minGap) / distance9;
    } else {
      interval3 = (firstBBox.height / ratio + minGap) / distance9;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle4));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval3 = (maxWidth + minGap) / distance9;
    } else {
      interval3 = (firstBBox.height / ratio + minGap) / distance9;
    }
  }
  if (interval3 > 1) {
    interval3 = Math.ceil(interval3);
    for (var i = 0; i < count2; i++) {
      if (i % interval3 !== 0) {
        labels[i].hide();
        hasHide = true;
      }
    }
  }
  return hasHide;
}
function getDefault2() {
  return equidistance;
}
function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
}
function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
}
function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length <= 2) {
    return false;
  }
  var hasHide = false;
  var count2 = labels.length;
  var first = labels[0];
  var last3 = labels[count2 - 1];
  var preLabel = first;
  for (var i = 1; i < count2 - 1; i++) {
    var label17 = labels[i];
    var curBBox = label17.getBBox();
    var isHide = isOverlap(isVertical2, preLabel, label17, minGap);
    if (isHide) {
      label17.hide();
      hasHide = true;
    } else {
      preLabel = label17;
    }
  }
  var overlap2 = isOverlap(isVertical2, preLabel, last3, minGap);
  if (overlap2) {
    preLabel.hide();
    hasHide = true;
  }
  return hasHide;
}
function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (reserveOne(isVertical2, labelsGroup, false)) {
    hasHide = true;
  }
  return hasHide;
}
function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice();
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (labels.length > 2) {
    var first = labels[0];
    var last3 = labels[labels.length - 1];
    if (!first.get("visible")) {
      first.show();
      if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    }
    if (!last3.get("visible")) {
      last3.show();
      if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }
  return hasHide;
}

// node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
var auto_rotate_exports = {};
__export(auto_rotate_exports, {
  fixedAngle: () => fixedAngle,
  getDefault: () => getDefault3,
  unfixedAngle: () => unfixedAngle
});
function setLabelsAngle(labels, angle4) {
  each_default(labels, function(label17) {
    var x = label17.attr("x");
    var y = label17.attr("y");
    var matrix = getMatrixByAngle({ x, y }, angle4);
    label17.attr("matrix", matrix);
  });
}
function labelRotate(isVertical2, labelsGroup, limitLength, getAngle4) {
  var labels = labelsGroup.getChildren();
  if (!labels.length) {
    return false;
  }
  if (!isVertical2 && labels.length < 2) {
    return false;
  }
  var maxWidth = getMaxLabelWidth(labels);
  var isOverlap2 = false;
  if (isVertical2) {
    isOverlap2 = !!limitLength && maxWidth > limitLength;
  } else {
    var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
    isOverlap2 = maxWidth > tickWidth;
  }
  if (isOverlap2) {
    var angle4 = getAngle4(limitLength, maxWidth);
    setLabelsAngle(labels, angle4);
  }
  return isOverlap2;
}
function getDefault3() {
  return fixedAngle;
}
function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function() {
    if (is_number_default(customRotate)) {
      return customRotate;
    }
    return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
  });
}
function unfixedAngle(isVertical2, labelsGroup, limitLength) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function(length5, maxWidth) {
    if (!length5) {
      return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
    }
    if (isVertical2) {
      return -Math.acos(length5 / maxWidth);
    } else {
      var angle4 = 0;
      if (length5 > maxWidth) {
        angle4 = Math.PI / 4;
      } else {
        angle4 = Math.asin(length5 / maxWidth);
        if (angle4 > Math.PI / 4) {
          angle4 = Math.PI / 4;
        }
      }
      return angle4;
    }
  });
}

// node_modules/@antv/component/esm/axis/line.js
var Line = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line7.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        type: "line",
        locationType: "region",
        /**
         * , x, y
         * @type {object}
         */
        start: null,
        /**
         * , x, y
         * @type {object}
         */
        end: null
      });
    };
    Line7.prototype.getLinePath = function() {
      var start = this.get("start");
      var end = this.get("end");
      var path = [];
      path.push(["M", start.x, start.y]);
      path.push(["L", end.x, end.y]);
      return path;
    };
    Line7.prototype.getInnerLayoutBBox = function() {
      var start = this.get("start");
      var end = this.get("end");
      var bbox = _super.prototype.getInnerLayoutBBox.call(this);
      var minX = Math.min(start.x, end.x, bbox.x);
      var minY = Math.min(start.y, end.y, bbox.y);
      var maxX = Math.max(start.x, end.x, bbox.maxX);
      var maxY2 = Math.max(start.y, end.y, bbox.maxY);
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
    };
    Line7.prototype.isVertical = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.x, end.x);
    };
    Line7.prototype.isHorizontal = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.y, end.y);
    };
    Line7.prototype.getTickPoint = function(tickValue) {
      var self2 = this;
      var start = self2.get("start");
      var end = self2.get("end");
      var regionX = end.x - start.x;
      var regionY = end.y - start.y;
      return {
        x: start.x + regionX * tickValue,
        y: start.y + regionY * tickValue
      };
    };
    Line7.prototype.getSideVector = function(offset) {
      var axisVector = this.getAxisVector();
      var normal = vec2_exports.normalize([0, 0], axisVector);
      var factor = this.get("verticalFactor");
      var verticalVector = [normal[1], normal[0] * -1];
      return vec2_exports.scale([0, 0], verticalVector, offset * factor);
    };
    Line7.prototype.getAxisVector = function() {
      var start = this.get("start");
      var end = this.get("end");
      return [end.x - start.x, end.y - start.y];
    };
    Line7.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var isHorizontal2 = this.isHorizontal();
      if (!isVertical2 && !isHorizontal2) {
        return;
      }
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var bbox = labelGroup.getCanvasBBox();
          var length_1 = isVertical2 ? bbox.width : bbox.height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Line7.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Line7.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var hasAdjusted = false;
      var util = overlap_exports[name];
      if (value2 === true) {
        var labelCfg = this.get("label");
        hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
      } else if (is_function_default(value2)) {
        hasAdjusted = value2(isVertical2, labelGroup, limitLength);
      } else if (is_object_default(value2)) {
        var overlapCfg = value2;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value2]) {
        hasAdjusted = util[value2](isVertical2, labelGroup, limitLength);
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label17) {
            var textAlign = label17.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label17.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label17) {
          if (!label17.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label17);
            }
            label17.remove();
          }
        });
      }
    };
    return Line7;
  }(base_default8)
);
var line_default4 = Line;

// node_modules/@antv/component/esm/axis/circle.js
var Circle = (
  /** @class */
  function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    Circle6.prototype.getLinePath = function() {
      var center2 = this.get("center");
      var x = center2.x;
      var y = center2.y;
      var rx = this.get("radius");
      var ry = rx;
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var path = [];
      if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
        path = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
      } else {
        var startPoint = this.getCirclePoint(startAngle);
        var endPoint = this.getCirclePoint(endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", x, y],
          ["L", startPoint.x, startPoint.y],
          ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
          ["L", x, y]
        ];
      }
      return path;
    };
    Circle6.prototype.getTickPoint = function(tickValue) {
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var angle4 = startAngle + (endAngle - startAngle) * tickValue;
      return this.getCirclePoint(angle4);
    };
    Circle6.prototype.getSideVector = function(offset, point2) {
      var center2 = this.get("center");
      var vector = [point2.x - center2.x, point2.y - center2.y];
      var factor = this.get("verticalFactor");
      var vecLen = vec2_exports.length(vector);
      vec2_exports.scale(vector, vector, factor * offset / vecLen);
      return vector;
    };
    Circle6.prototype.getAxisVector = function(point2) {
      var center2 = this.get("center");
      var vector = [point2.x - center2.x, point2.y - center2.y];
      return [vector[1], -1 * vector[0]];
    };
    Circle6.prototype.getCirclePoint = function(angle4, radius) {
      var center2 = this.get("center");
      radius = radius || this.get("radius");
      return {
        x: center2.x + Math.cos(angle4) * radius,
        y: center2.y + Math.sin(angle4) * radius
      };
    };
    Circle6.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Circle6.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var length_1 = labelGroup.getCanvasBBox().height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Circle6.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
      var _this = this;
      var hasAdjusted = false;
      var util = overlap_exports[name];
      if (limitLength > 0) {
        if (value2 === true) {
          hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
        } else if (is_function_default(value2)) {
          hasAdjusted = value2(false, labelGroup, limitLength);
        } else if (is_object_default(value2)) {
          var overlapCfg = value2;
          if (util[overlapCfg.type]) {
            hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
          }
        } else if (util[value2]) {
          hasAdjusted = util[value2](false, labelGroup, limitLength);
        }
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label17) {
            var textAlign = label17.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label17.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label17) {
          if (!label17.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label17);
            }
            label17.remove();
          }
        });
      }
    };
    return Circle6;
  }(base_default8)
);
var circle_default2 = Circle;

// node_modules/@antv/component/esm/crosshair/index.js
var crosshair_exports = {};
__export(crosshair_exports, {
  Base: () => base_default9,
  Circle: () => circle_default3,
  Html: () => html_default2,
  Line: () => line_default5
});

// node_modules/@antv/component/esm/crosshair/base.js
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends(CrosshairBase2, _super);
    function CrosshairBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        },
        text: {
          position: "start",
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: theme_default.textColor,
            textAlign: "center",
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    CrosshairBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.renderLine(group2);
      }
      if (this.get("text")) {
        this.renderText(group2);
        this.renderBackground(group2);
      }
    };
    CrosshairBase2.prototype.renderText = function(group2) {
      var text = this.get("text");
      var style = text.style, autoRotate = text.autoRotate, content = text.content;
      if (!is_nil_default(content)) {
        var textPoint = this.getTextPoint();
        var matrix = null;
        if (autoRotate) {
          var angle4 = this.getRotateAngle();
          matrix = getMatrixByAngle(textPoint, angle4);
        }
        this.addShape(group2, {
          type: "text",
          name: "crosshair-text",
          id: this.getElementId("text"),
          attrs: __assign(__assign(__assign({}, textPoint), { text: content, matrix }), style)
        });
      }
    };
    CrosshairBase2.prototype.renderLine = function(group2) {
      var path = this.getLinePath();
      var line2 = this.get("line");
      var style = line2.style;
      this.addShape(group2, {
        type: "path",
        name: "crosshair-line",
        id: this.getElementId("line"),
        attrs: __assign({ path }, style)
      });
    };
    CrosshairBase2.prototype.renderBackground = function(group2) {
      var textId = this.getElementId("text");
      var textShape = group2.findById(textId);
      var textBackground = this.get("textBackground");
      if (textBackground && textShape) {
        var textBBox = textShape.getBBox();
        var padding3 = formatPadding(textBackground.padding);
        var style = textBackground.style;
        var backgroundShape = this.addShape(group2, {
          type: "rect",
          name: "crosshair-text-background",
          id: this.getElementId("text-background"),
          attrs: __assign({ x: textBBox.x - padding3[3], y: textBBox.y - padding3[0], width: textBBox.width + padding3[1] + padding3[3], height: textBBox.height + padding3[0] + padding3[2], matrix: textShape.attr("matrix") }, style)
        });
        backgroundShape.toBack();
      }
    };
    return CrosshairBase2;
  }(group_component_default)
);
var base_default9 = CrosshairBase;

// node_modules/@antv/component/esm/crosshair/line.js
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { type: "line", locationType: "region", start: null, end: null });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a6 = this.getLocation(), start = _a6.start, end = _a6.end;
      var position = this.get("text").position;
      var angle4 = Math.atan2(end.y - start.y, end.x - start.x);
      var tangentAngle = position === "start" ? angle4 - Math.PI / 2 : angle4 + Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var _a6 = this.getLocation(), start = _a6.start, end = _a6.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a6 = this.getLocation(), start = _a6.start, end = _a6.end;
      return [
        ["M", start.x, start.y],
        ["L", end.x, end.y]
      ];
    };
    return LineCrosshair3;
  }(base_default9)
);
var line_default5 = LineCrosshair;

// node_modules/@antv/component/esm/crosshair/circle.js
var LineCrosshair2 = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a6 = this.getLocation(), startAngle = _a6.startAngle, endAngle = _a6.endAngle;
      var position = this.get("text").position;
      var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var text = this.get("text");
      var position = text.position, offset = text.offset;
      var _a6 = this.getLocation(), center2 = _a6.center, radius = _a6.radius, startAngle = _a6.startAngle, endAngle = _a6.endAngle;
      var angle4 = position === "start" ? startAngle : endAngle;
      var tangentAngle = this.getRotateAngle() - Math.PI;
      var point2 = getCirclePoint(center2, radius, angle4);
      var offsetX = Math.cos(tangentAngle) * offset;
      var offsetY = Math.sin(tangentAngle) * offset;
      return {
        x: point2.x + offsetX,
        y: point2.y + offsetY
      };
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a6 = this.getLocation(), center2 = _a6.center, radius = _a6.radius, startAngle = _a6.startAngle, endAngle = _a6.endAngle;
      var path = null;
      if (endAngle - startAngle === Math.PI * 2) {
        var x = center2.x, y = center2.y;
        path = [
          ["M", x, y - radius],
          ["A", radius, radius, 0, 1, 1, x, y + radius],
          ["A", radius, radius, 0, 1, 1, x, y - radius],
          ["Z"]
        ];
      } else {
        var startPoint = getCirclePoint(center2, radius, startAngle);
        var endPoint = getCirclePoint(center2, radius, endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", startPoint.x, startPoint.y],
          ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
        ];
      }
      return path;
    };
    return LineCrosshair3;
  }(base_default9)
);
var circle_default3 = LineCrosshair2;

// node_modules/@antv/component/esm/crosshair/css-const.js
var CONTAINER_CLASS = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";

// node_modules/@antv/component/esm/crosshair/html-theme.js
var _a;
var html_theme_default = (_a = {}, // css style for tooltip
_a["" + CONTAINER_CLASS] = {
  position: "relative"
}, _a["" + CROSSHAIR_LINE] = {
  position: "absolute",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a["" + CROSSHAIR_TEXT] = {
  position: "absolute",
  color: theme_default.textColor,
  fontFamily: theme_default.fontFamily
}, _a);

// node_modules/@antv/component/esm/crosshair/html.js
var HtmlCrosshair = (
  /** @class */
  function(_super) {
    __extends(HtmlCrosshair2, _super);
    function HtmlCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS, defaultStyles: html_theme_default, defaultCfg: {
        text: {
          position: "start",
          content: null,
          align: "center",
          offset: 10
        }
      } });
    };
    HtmlCrosshair2.prototype.render = function() {
      this.resetText();
      this.resetPosition();
    };
    HtmlCrosshair2.prototype.initCrossHair = function() {
      var container = this.getContainer();
      var crosshairTpl = this.get("crosshairTpl");
      var crosshairEl = createDom(crosshairTpl);
      container.appendChild(crosshairEl);
      this.applyStyle(CROSSHAIR_LINE, crosshairEl);
      this.set("crosshairEl", crosshairEl);
    };
    HtmlCrosshair2.prototype.getTextPoint = function() {
      var _a6 = this.getLocation(), start = _a6.start, end = _a6.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    HtmlCrosshair2.prototype.resetText = function() {
      var text = this.get("text");
      var textEl = this.get("textEl");
      if (text) {
        var content = text.content;
        if (!textEl) {
          var container = this.getContainer();
          var textTpl = substitute_default(this.get("textTpl"), text);
          textEl = createDom(textTpl);
          container.appendChild(textEl);
          this.applyStyle(CROSSHAIR_TEXT, textEl);
          this.set("textEl", textEl);
        }
        textEl.innerHTML = content;
      } else if (textEl) {
        textEl.remove();
      }
    };
    HtmlCrosshair2.prototype.isVertical = function(start, end) {
      return start.x === end.x;
    };
    HtmlCrosshair2.prototype.resetPosition = function() {
      var crosshairEl = this.get("crosshairEl");
      if (!crosshairEl) {
        this.initCrossHair();
        crosshairEl = this.get("crosshairEl");
      }
      var start = this.get("start");
      var end = this.get("end");
      var minX = Math.min(start.x, end.x);
      var minY = Math.min(start.y, end.y);
      if (this.isVertical(start, end)) {
        modifyCSS(crosshairEl, {
          width: "1px",
          height: toPx(Math.abs(end.y - start.y))
        });
      } else {
        modifyCSS(crosshairEl, {
          height: "1px",
          width: toPx(Math.abs(end.x - start.x))
        });
      }
      modifyCSS(crosshairEl, {
        top: toPx(minY),
        left: toPx(minX)
      });
      this.alignText();
    };
    HtmlCrosshair2.prototype.alignText = function() {
      var textEl = this.get("textEl");
      if (textEl) {
        var align = this.get("text").align;
        var clientWidth = textEl.clientWidth;
        var point2 = this.getTextPoint();
        switch (align) {
          case "center":
            point2.x = point2.x - clientWidth / 2;
            break;
          case "right":
            point2.x = point2.x - clientWidth;
          case "left":
            break;
        }
        modifyCSS(textEl, {
          top: toPx(point2.y),
          left: toPx(point2.x)
        });
      }
    };
    HtmlCrosshair2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "text")) {
        this.resetText();
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    return HtmlCrosshair2;
  }(html_component_default)
);
var html_default2 = HtmlCrosshair;

// node_modules/@antv/component/esm/grid/index.js
var grid_exports = {};
__export(grid_exports, {
  Base: () => base_default10,
  Circle: () => circle_default4,
  Line: () => line_default6
});

// node_modules/@antv/component/esm/grid/base.js
var GridBase = (
  /** @class */
  function(_super) {
    __extends(GridBase2, _super);
    function GridBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
        line: {
          type: "line",
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    GridBase2.prototype.getLineType = function() {
      var line2 = this.get("line") || this.get("defaultCfg").line;
      return line2.type;
    };
    GridBase2.prototype.renderInner = function(group2) {
      this.drawGrid(group2);
    };
    GridBase2.prototype.getAlternatePath = function(prePoints, points2) {
      var regionPath = this.getGridPath(prePoints);
      var reversePoints = points2.slice(0).reverse();
      var nextPath = this.getGridPath(reversePoints, true);
      var closed = this.get("closed");
      if (closed) {
        regionPath = regionPath.concat(nextPath);
      } else {
        nextPath[0][0] = "L";
        regionPath = regionPath.concat(nextPath);
        regionPath.push(["Z"]);
      }
      return regionPath;
    };
    GridBase2.prototype.getPathStyle = function() {
      return this.get("line").style;
    };
    GridBase2.prototype.drawGrid = function(group2) {
      var _this = this;
      var line2 = this.get("line");
      var items = this.get("items");
      var alternateColor = this.get("alternateColor");
      var preItem = null;
      each_default(items, function(item, index) {
        var id = item.id || index;
        if (line2) {
          var style = _this.getPathStyle();
          style = is_function_default(style) ? style(item, index, items) : style;
          var lineId = _this.getElementId("line-" + id);
          var gridPath = _this.getGridPath(item.points);
          _this.addShape(group2, {
            type: "path",
            name: "grid-line",
            id: lineId,
            attrs: mix({
              path: gridPath
            }, style)
          });
        }
        if (alternateColor && index > 0) {
          var regionId = _this.getElementId("region-" + id);
          var isEven = index % 2 === 0;
          if (is_string_default(alternateColor)) {
            if (isEven) {
              _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
            }
          } else {
            var color3 = isEven ? alternateColor[1] : alternateColor[0];
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color3);
          }
        }
        preItem = item;
      });
    };
    GridBase2.prototype.drawAlternateRegion = function(id, group2, prePoints, points2, color3) {
      var regionPath = this.getAlternatePath(prePoints, points2);
      this.addShape(group2, {
        type: "path",
        id,
        name: "grid-region",
        attrs: {
          path: regionPath,
          fill: color3
        }
      });
    };
    return GridBase2;
  }(group_component_default)
);
var base_default10 = GridBase;

// node_modules/@antv/component/esm/grid/circle.js
function distance5(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
var Circle2 = (
  /** @class */
  function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        type: "circle",
        /**
         * 
         * @type {object}
         */
        center: null,
        /**
         * 
         * @type {true}
         */
        closed: true
      });
    };
    Circle6.prototype.getGridPath = function(points2, reversed) {
      var lineType = this.getLineType();
      var closed = this.get("closed");
      var path = [];
      if (points2.length) {
        if (lineType === "circle") {
          var center2 = this.get("center");
          var firstPoint = points2[0];
          var radius_1 = distance5(center2.x, center2.y, firstPoint.x, firstPoint.y);
          var sweepFlag_1 = reversed ? 0 : 1;
          if (closed) {
            path.push(["M", center2.x, center2.y - radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y + radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y - radius_1]);
            path.push(["Z"]);
          } else {
            each_default(points2, function(point2, index) {
              if (index === 0) {
                path.push(["M", point2.x, point2.y]);
              } else {
                path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point2.x, point2.y]);
              }
            });
          }
        } else {
          each_default(points2, function(point2, index) {
            if (index === 0) {
              path.push(["M", point2.x, point2.y]);
            } else {
              path.push(["L", point2.x, point2.y]);
            }
          });
          if (closed) {
            path.push(["Z"]);
          }
        }
      }
      return path;
    };
    return Circle6;
  }(base_default10)
);
var circle_default4 = Circle2;

// node_modules/@antv/component/esm/grid/line.js
var Line2 = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line7.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { type: "line" });
    };
    Line7.prototype.getGridPath = function(points2) {
      var path = [];
      each_default(points2, function(point2, index) {
        if (index === 0) {
          path.push(["M", point2.x, point2.y]);
        } else {
          path.push(["L", point2.x, point2.y]);
        }
      });
      return path;
    };
    return Line7;
  }(base_default10)
);
var line_default6 = Line2;

// node_modules/@antv/component/esm/legend/index.js
var legend_exports = {};
__export(legend_exports, {
  Base: () => base_default11,
  Category: () => category_default,
  Continuous: () => continuous_default
});

// node_modules/@antv/component/esm/legend/base.js
var LegendBase = (
  /** @class */
  function(_super) {
    __extends(LegendBase2, _super);
    function LegendBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LegendBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        name: "legend",
        /**
         *  horizontalvertical
         * @type {String}
         */
        layout: "horizontal",
        locationType: "point",
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0,
        title: null,
        background: null
      });
    };
    LegendBase2.prototype.getLayoutBBox = function() {
      var bbox = _super.prototype.getLayoutBBox.call(this);
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var width = bbox.width, height = bbox.height;
      if (maxWidth) {
        width = Math.min(width, maxWidth);
      }
      if (maxHeight) {
        height = Math.min(height, maxHeight);
      }
      return createBBox(bbox.minX, bbox.minY, width, height);
    };
    LegendBase2.prototype.setLocation = function(cfg) {
      this.set("x", cfg.x);
      this.set("y", cfg.y);
      this.resetLocation();
    };
    LegendBase2.prototype.resetLocation = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: x + offsetX,
        y: y + offsetY
      });
    };
    LegendBase2.prototype.applyOffset = function() {
      this.resetLocation();
    };
    LegendBase2.prototype.getDrawPoint = function() {
      return this.get("currentPoint");
    };
    LegendBase2.prototype.setDrawPoint = function(point2) {
      return this.set("currentPoint", point2);
    };
    LegendBase2.prototype.renderInner = function(group2) {
      this.resetDraw();
      if (this.get("title")) {
        this.drawTitle(group2);
      }
      this.drawLegendContent(group2);
      if (this.get("background")) {
        this.drawBackground(group2);
      }
    };
    LegendBase2.prototype.drawBackground = function(group2) {
      var background = this.get("background");
      var bbox = group2.getBBox();
      var padding3 = formatPadding(background.padding);
      var attrs = __assign({
        //  (0,0) 
        x: 0,
        y: 0,
        width: bbox.width + padding3[1] + padding3[3],
        height: bbox.height + padding3[0] + padding3[2]
      }, background.style);
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        name: "legend-background",
        attrs
      });
      backgroundShape.toBack();
    };
    LegendBase2.prototype.drawTitle = function(group2) {
      var currentPoint = this.get("currentPoint");
      var titleCfg = this.get("title");
      var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
      var shape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "legend-title",
        attrs: __assign({ text, x: currentPoint.x, y: currentPoint.y }, style)
      });
      var bbox = shape.getBBox();
      this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
    };
    LegendBase2.prototype.resetDraw = function() {
      var background = this.get("background");
      var currentPoint = { x: 0, y: 0 };
      if (background) {
        var padding3 = formatPadding(background.padding);
        currentPoint.x = padding3[3];
        currentPoint.y = padding3[0];
      }
      this.set("currentPoint", currentPoint);
    };
    return LegendBase2;
  }(group_component_default)
);
var base_default11 = LegendBase;

// node_modules/@antv/component/esm/legend/category.js
var DEFAULT_PAGE_NAVIGATOR = {
  marker: {
    style: {
      inactiveFill: "#000",
      inactiveOpacity: 0.45,
      fill: "#000",
      opacity: 1,
      size: 12
    }
  },
  text: {
    style: {
      fill: "#ccc",
      fontSize: 12
    }
  }
};
var textStyle = {
  fill: theme_default.textColor,
  fontSize: 12,
  textAlign: "start",
  textBaseline: "middle",
  fontFamily: theme_default.fontFamily,
  fontWeight: "normal",
  lineHeight: 12
};
var RIGHT_ARROW_NAME = "navigation-arrow-right";
var LEFT_ARROW_NAME = "navigation-arrow-left";
var ROTATE_MAP = {
  right: 90 * Math.PI / 180,
  left: (360 - 90) * Math.PI / 180,
  up: 0,
  down: 180 * Math.PI / 180
};
var Category2 = (
  /** @class */
  function(_super) {
    __extends(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.currentPageIndex = 1;
      _this.totalPagesCnt = 1;
      _this.pageWidth = 0;
      _this.pageHeight = 0;
      _this.startX = 0;
      _this.startY = 0;
      _this.onNavigationBack = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex > 1) {
          _this.currentPageIndex -= 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      _this.onNavigationAfter = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex < _this.totalPagesCnt) {
          _this.currentPageIndex += 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      return _this;
    }
    Category3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, radio: null, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        },
        background: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        },
        itemBackground: {
          style: {
            opacity: 0,
            fill: "#fff"
          }
        },
        pageNavigator: DEFAULT_PAGE_NAVIGATOR,
        itemName: {
          spacing: 16,
          style: textStyle
        },
        marker: {
          spacing: 8,
          style: {
            r: 6,
            symbol: "circle"
          }
        },
        itemValue: {
          alignRight: false,
          formatter: null,
          style: textStyle,
          spacing: 6
        },
        itemStates: {
          active: {
            nameStyle: {
              opacity: 0.8
            }
          },
          unchecked: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              fill: theme_default.uncheckedColor,
              stroke: theme_default.uncheckedColor
            }
          },
          inactive: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              opacity: 0.2
            }
          }
        }
      } });
    };
    Category3.prototype.isList = function() {
      return true;
    };
    Category3.prototype.getItems = function() {
      return this.get("items");
    };
    Category3.prototype.setItems = function(items) {
      this.update({
        items
      });
    };
    Category3.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    Category3.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("item-group");
      itemGroup && itemGroup.clear();
    };
    Category3.prototype.setItemState = function(item, state2, value2) {
      item[state2] = value2;
      var itemElement = this.getElementByLocalId("item-" + item.id);
      if (itemElement) {
        var items = this.getItems();
        var index = items.indexOf(item);
        var offsetGroup = this.createOffScreenGroup();
        var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
        this.updateElements(newElement, itemElement);
        this.clearUpdateStatus(itemElement);
      }
    };
    Category3.prototype.hasState = function(item, state2) {
      return !!item[state2];
    };
    Category3.prototype.getItemStates = function(item) {
      var itemStates = this.get("itemStates");
      var rst = [];
      each_default(itemStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    Category3.prototype.clearItemsState = function(state2) {
      var _this = this;
      var items = this.getItemsByState(state2);
      each_default(items, function(item) {
        _this.setItemState(item, state2, false);
      });
    };
    Category3.prototype.getItemsByState = function(state2) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state2);
      });
    };
    Category3.prototype.drawLegendContent = function(group2) {
      this.processItems();
      this.drawItems(group2);
    };
    Category3.prototype.processItems = function() {
      var items = this.get("items");
      each_default(items, function(item) {
        if (!item.id) {
          item.id = item.name;
        }
      });
    };
    Category3.prototype.drawItems = function(group2) {
      var _this = this;
      var itemContainerGroup = this.addGroup(group2, {
        id: this.getElementId("item-container-group"),
        name: "legend-item-container-group"
      });
      var itemGroup = this.addGroup(itemContainerGroup, {
        id: this.getElementId("item-group"),
        name: "legend-item-group"
      });
      var itemHeight = this.getItemHeight();
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemMarginBottom = this.get("itemMarginBottom");
      var currentPoint = this.get("currentPoint");
      var startX = currentPoint.x;
      var startY = currentPoint.y;
      var layout2 = this.get("layout");
      var items = this.get("items");
      var wrapped = false;
      var pageWidth = 0;
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      each_default(items, function(item, index) {
        var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
        var bbox = subGroup.getBBox();
        var width = itemWidth || bbox.width;
        if (width > pageWidth) {
          pageWidth = width;
        }
        if (layout2 === "horizontal") {
          if (maxWidth && maxWidth < currentPoint.x + width - startX) {
            wrapped = true;
            currentPoint.x = startX;
            currentPoint.y += itemHeight + itemMarginBottom;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.x += width + itemSpacing;
        } else {
          if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
            wrapped = true;
            currentPoint.x += pageWidth + itemSpacing;
            currentPoint.y = startY;
            pageWidth = 0;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.y += itemHeight + itemMarginBottom;
        }
      });
      if (wrapped && this.get("flipPage")) {
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.totalPagesCnt = 1;
        this.startX = startX;
        this.startY = startY;
        this.adjustNavigation(group2, itemGroup);
      }
    };
    Category3.prototype.getItemHeight = function() {
      var itemHeight = this.get("itemHeight");
      if (!itemHeight) {
        var style_1 = (this.get("itemName") || {}).style;
        if (is_function_default(style_1)) {
          var items_1 = this.getItems();
          items_1.forEach(function(item, index) {
            var fontSize = __assign(__assign({}, textStyle), style_1(item, index, items_1)).fontSize;
            if (itemHeight < fontSize) {
              itemHeight = fontSize;
            }
          });
        } else if (style_1) {
          itemHeight = style_1.fontSize;
        }
      }
      return itemHeight;
    };
    Category3.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
      var markerAttrs = __assign(__assign(__assign({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get_default(item.marker, "symbol", "circle") }), get_default(item.marker, "style", {}));
      var shape = this.addShape(container, {
        type: "marker",
        id: this.getElementId("item-" + item.id + "-marker"),
        name: "legend-item-marker",
        attrs: markerAttrs
      });
      var bbox = shape.getBBox();
      shape.attr("x", bbox.width / 2);
      var _a6 = shape.attr(), stroke = _a6.stroke, fill2 = _a6.fill;
      if (stroke) {
        shape.set("isStroke", true);
      }
      if (fill2) {
        shape.set("isFill", true);
      }
      return shape;
    };
    Category3.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index) {
      var formatter = cfg.formatter;
      var style = cfg.style;
      var attrs = __assign(__assign({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index) : item[textName] }, textStyle), is_function_default(style) ? style(item, index, this.getItems()) : style);
      return this.addShape(container, {
        type: "text",
        id: this.getElementId("item-" + item.id + "-" + textName),
        name: "legend-item-" + textName,
        attrs
      });
    };
    Category3.prototype.drawRadio = function(container, radioCfg, item, itemHeight, x) {
      var _a6, _b;
      var style = radioCfg.style || {};
      var r = (_a6 = style.r) !== null && _a6 !== void 0 ? _a6 : itemHeight / 2;
      var lineWidth = r * 3.6 / 8;
      var _c = [x + r, itemHeight / 2 - r], x0 = _c[0], y0 = _c[1];
      var _d = [x0 + r, y0 + r], x1 = _d[0], y1 = _d[1];
      var _e = [x0, y1 + r], x2 = _e[0], y2 = _e[1];
      var _f = [x, y0 + r], x3 = _f[0], y3 = _f[1];
      var showRadio = item.showRadio;
      var attrs = __assign(__assign({ path: [
        ["M", x0, y0],
        ["A", r, r, 0, 0, 1, x1, y1],
        ["L", x1 - lineWidth, y1],
        ["L", x1, y1],
        ["A", r, r, 0, 0, 1, x2, y2],
        ["L", x2, y2 - lineWidth],
        ["L", x2, y2],
        ["A", r, r, 0, 0, 1, x3, y3],
        ["L", x3 + lineWidth, y3],
        ["L", x3, y3],
        ["A", r, r, 0, 0, 1, x0, y0],
        ["L", x0, y0 + lineWidth]
      ], stroke: "#000000", fill: "#ffffff" }, style), { opacity: showRadio ? (_b = style === null || style === void 0 ? void 0 : style.opacity) !== null && _b !== void 0 ? _b : 0.45 : 0 });
      var radioShape = this.addShape(container, {
        type: "path",
        id: this.getElementId("item-" + item.id + "-radio"),
        name: "legend-item-radio",
        attrs
      });
      radioShape.set("tip", radioCfg.tip);
      return radioShape;
    };
    Category3.prototype.drawItem = function(item, index, itemHeight, itemGroup) {
      var groupId = "item-" + item.id;
      var subContainer = this.addGroup(itemGroup, {
        name: "legend-item-container",
        id: this.getElementId("item-container-" + groupId),
        delegateObject: {
          item,
          index
        }
      });
      var subGroup = this.addGroup(subContainer, {
        name: "legend-item",
        id: this.getElementId(groupId),
        delegateObject: {
          item,
          index
        }
      });
      var marker = this.get("marker");
      var itemName = this.get("itemName");
      var itemValue = this.get("itemValue");
      var itemBackground = this.get("itemBackground");
      var radio = this.get("radio");
      var itemWidth = this.getLimitItemWidth();
      var curX = 0;
      if (marker) {
        var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
        var spacing = marker.spacing;
        var itemMarkerSpacing = get_default(item, ["marker", "spacing"]);
        if (is_number_default(itemMarkerSpacing)) {
          spacing = itemMarkerSpacing;
        }
        curX = markerShape.getBBox().maxX + spacing;
      }
      if (itemName) {
        var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index);
        if (itemWidth) {
          ellipsisLabel(true, nameShape, clamp_default(itemWidth - curX, 0, itemWidth));
        }
        curX = nameShape.getBBox().maxX + itemName.spacing;
      }
      if (itemValue) {
        var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index);
        if (itemWidth) {
          if (itemValue.alignRight) {
            valueShape.attr({
              textAlign: "right",
              x: itemWidth
            });
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth), "head");
          } else {
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth));
          }
        }
        curX = valueShape.getBBox().maxX + itemValue.spacing;
      }
      if (radio) {
        this.drawRadio(subGroup, radio, item, itemHeight, curX);
      }
      if (itemBackground) {
        var bbox = subGroup.getBBox();
        var backShape = this.addShape(subGroup, {
          type: "rect",
          name: "legend-item-background",
          id: this.getElementId(groupId + "-background"),
          attrs: __assign({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
        });
        backShape.toBack();
      }
      this.applyItemStates(item, subGroup);
      return subGroup;
    };
    Category3.prototype.adjustNavigation = function(container, itemGroup) {
      var _this = this;
      var startX = this.startX;
      var startY = this.startY;
      var layout2 = this.get("layout");
      var subGroups = itemGroup.findAll(function(item) {
        return item.get("name") === "legend-item";
      });
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemHeight = this.getItemHeight();
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var navigation = this.drawNavigation(container, layout2, "00/00", pageNavigator);
      var navigationBBox = navigation.getBBox();
      var currentPoint = { x: startX, y: startY };
      var pages = 1;
      var widthLimit = 0;
      var pageWidth = 0;
      var maxItemWidth = 0;
      var itemMarginBottom = this.get("itemMarginBottom");
      function shouldWrap(item, currentPoint2) {
        var bbox = item.getBBox();
        var width = itemWidth || bbox.width;
        var newItemXPos = currentPoint2.x + width + itemSpacing + navigationBBox.width;
        return newItemXPos > maxWidth;
      }
      if (layout2 === "horizontal") {
        var maxRow = this.get("maxRow") || 1;
        var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
        var navigationX_1 = maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX;
        this.pageHeight = maxRowHeight_1 * maxRow;
        this.pageWidth = navigationX_1;
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          var width = itemWidth || bbox.width;
          if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || shouldWrap(item, currentPoint)) {
            if (pages === 1) {
              widthLimit = currentPoint.x + itemSpacing;
              _this.moveElementTo(navigation, {
                x: navigationX_1,
                y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
              });
            }
            pages += 1;
            currentPoint.x = startX;
            currentPoint.y += maxRowHeight_1;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: width + itemSpacing,
              height: itemHeight
            }
          });
          currentPoint.x += width + itemSpacing;
        });
      } else {
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          if (bbox.width > pageWidth) {
            pageWidth = bbox.width;
          }
        });
        maxItemWidth = pageWidth;
        pageWidth += itemSpacing;
        if (maxWidth) {
          pageWidth = Math.min(maxWidth, pageWidth);
          maxItemWidth = Math.min(maxWidth, maxItemWidth);
        }
        this.pageWidth = pageWidth;
        this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
        var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
        each_default(subGroups, function(item, index) {
          if (index !== 0 && index % cntPerPage_1 === 0) {
            pages += 1;
            currentPoint.x += pageWidth;
            currentPoint.y = startY;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: pageWidth,
              height: itemHeight
            }
          });
          currentPoint.y += itemHeight + itemMarginBottom;
        });
        this.totalPagesCnt = pages;
        this.moveElementTo(navigation, {
          x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
          y: maxHeight - navigationBBox.height - navigationBBox.minY
        });
      }
      if (this.pageHeight && this.pageWidth) {
        itemGroup.getParent().setClip({
          type: "rect",
          attrs: {
            x: this.startX,
            y: this.startY,
            width: this.pageWidth,
            height: this.pageHeight
          }
        });
      }
      if (layout2 === "horizontal" && this.get("maxRow")) {
        this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
      } else {
        this.totalPagesCnt = pages;
      }
      if (this.currentPageIndex > this.totalPagesCnt) {
        this.currentPageIndex = 1;
      }
      this.updateNavigation(navigation);
      itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
    };
    Category3.prototype.drawNavigation = function(group2, layout2, text, styleCfg) {
      var currentPoint = { x: 0, y: 0 };
      var subGroup = this.addGroup(group2, {
        id: this.getElementId("navigation-group"),
        name: "legend-navigation"
      });
      var _a6 = get_default(styleCfg.marker, "style", {}), _b = _a6.size, size3 = _b === void 0 ? 12 : _b, arrowStyle = __rest(_a6, ["size"]);
      var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout2 === "horizontal" ? "up" : "left", size3, arrowStyle);
      leftArrow.on("click", this.onNavigationBack);
      var leftArrowBBox = leftArrow.getBBox();
      currentPoint.x += leftArrowBBox.width + 2;
      var textShape = this.addShape(subGroup, {
        type: "text",
        id: this.getElementId("navigation-text"),
        name: "navigation-text",
        attrs: __assign({ x: currentPoint.x, y: currentPoint.y + size3 / 2, text, textBaseline: "middle" }, get_default(styleCfg.text, "style"))
      });
      var textBBox = textShape.getBBox();
      currentPoint.x += textBBox.width + 2;
      var rightArrow = this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout2 === "horizontal" ? "down" : "right", size3, arrowStyle);
      rightArrow.on("click", this.onNavigationAfter);
      return subGroup;
    };
    Category3.prototype.updateNavigation = function(navigation) {
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var _a6 = pageNavigator.marker.style, fill2 = _a6.fill, opacity = _a6.opacity, inactiveFill = _a6.inactiveFill, inactiveOpacity = _a6.inactiveOpacity;
      var text = this.currentPageIndex + "/" + this.totalPagesCnt;
      var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
      var leftArrow = navigation ? navigation.findById(this.getElementId(LEFT_ARROW_NAME)) : this.getElementByLocalId(LEFT_ARROW_NAME);
      var rightArrow = navigation ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME)) : this.getElementByLocalId(RIGHT_ARROW_NAME);
      textShape.attr("text", text);
      leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
      leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill2);
      leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
      rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
      rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill2);
      rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
      var cursorX = leftArrow.getBBox().maxX + 2;
      textShape.attr("x", cursorX);
      cursorX += textShape.getBBox().width + 2;
      this.updateArrowPath(rightArrow, { x: cursorX, y: 0 });
    };
    Category3.prototype.drawArrow = function(group2, currentPoint, name, direction2, size3, style) {
      var x = currentPoint.x, y = currentPoint.y;
      var shape = this.addShape(group2, {
        type: "path",
        id: this.getElementId(name),
        name,
        attrs: __assign({
          size: size3,
          direction: direction2,
          path: [["M", x + size3 / 2, y], ["L", x, y + size3], ["L", x + size3, y + size3], ["Z"]],
          cursor: "pointer"
        }, style)
      });
      shape.attr("matrix", getMatrixByAngle({ x: x + size3 / 2, y: y + size3 / 2 }, ROTATE_MAP[direction2]));
      return shape;
    };
    Category3.prototype.updateArrowPath = function(arrow, point2) {
      var x = point2.x, y = point2.y;
      var _a6 = arrow.attr(), size3 = _a6.size, direction2 = _a6.direction;
      var matrix = getMatrixByAngle({ x: x + size3 / 2, y: y + size3 / 2 }, ROTATE_MAP[direction2]);
      arrow.attr("path", [["M", x + size3 / 2, y], ["L", x, y + size3], ["L", x + size3, y + size3], ["Z"]]);
      arrow.attr("matrix", matrix);
    };
    Category3.prototype.getCurrentNavigationMatrix = function() {
      var _a6 = this, currentPageIndex = _a6.currentPageIndex, pageWidth = _a6.pageWidth, pageHeight = _a6.pageHeight;
      var layout2 = this.get("layout");
      var translate3 = layout2 === "horizontal" ? {
        x: 0,
        y: pageHeight * (1 - currentPageIndex)
      } : {
        x: pageWidth * (1 - currentPageIndex),
        y: 0
      };
      return getMatrixByTranslate(translate3);
    };
    Category3.prototype.applyItemStates = function(item, subGroup) {
      var states = this.getItemStates(item);
      var hasStates = states.length > 0;
      if (hasStates) {
        var children = subGroup.getChildren();
        var itemStates_1 = this.get("itemStates");
        each_default(children, function(element) {
          var name = element.get("name");
          var elName = name.split("-")[2];
          var statesStyle = getStatesStyle(item, elName, itemStates_1);
          if (statesStyle) {
            element.attr(statesStyle);
            if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
              if (element.get("isStroke")) {
                element.attr("fill", null);
              }
              if (element.get("isFill")) {
                element.attr("stroke", null);
              }
            }
          }
        });
      }
    };
    Category3.prototype.getLimitItemWidth = function() {
      var itemWidth = this.get("itemWidth");
      var maxItemWidth = this.get("maxItemWidth");
      if (maxItemWidth) {
        if (itemWidth) {
          maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
        }
      } else if (itemWidth) {
        maxItemWidth = itemWidth;
      }
      return maxItemWidth;
    };
    return Category3;
  }(base_default11)
);
var category_default = Category2;

// node_modules/@antv/component/esm/legend/continuous.js
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = (
  /** @class */
  function(_super) {
    __extends(ContinueLegend2, _super);
    function ContinueLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ContinueLegend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
        label: {
          align: "rail",
          spacing: 5,
          formatter: null,
          style: {
            fontSize: 12,
            fill: theme_default.textColor,
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        handler: {
          size: 10,
          style: {
            fill: "#fff",
            stroke: "#333"
          }
        },
        track: {},
        rail: {
          type: "color",
          size: 20,
          defaultLength: 100,
          style: {
            fill: "#DCDEE2"
          }
        },
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        }
      } });
    };
    ContinueLegend2.prototype.isSlider = function() {
      return true;
    };
    ContinueLegend2.prototype.getValue = function() {
      return this.getCurrentValue();
    };
    ContinueLegend2.prototype.getRange = function() {
      return {
        min: this.get("min"),
        max: this.get("max")
      };
    };
    ContinueLegend2.prototype.setRange = function(min5, max5) {
      this.update({
        min: min5,
        max: max5
      });
    };
    ContinueLegend2.prototype.setValue = function(value2) {
      var originValue = this.getValue();
      this.set("value", value2);
      var group2 = this.get("group");
      this.resetTrackClip();
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value: value2
      });
    };
    ContinueLegend2.prototype.initEvent = function() {
      var group2 = this.get("group");
      this.bindSliderEvent(group2);
      this.bindRailEvent(group2);
      this.bindTrackEvent(group2);
    };
    ContinueLegend2.prototype.drawLegendContent = function(group2) {
      this.drawRail(group2);
      this.drawLabels(group2);
      this.fixedElements(group2);
      this.resetTrack(group2);
      this.resetTrackClip(group2);
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
    };
    ContinueLegend2.prototype.bindSliderEvent = function(group2) {
      this.bindHandlersEvent(group2);
    };
    ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
      var _this = this;
      group2.on("legend-handler-min:drag", function(ev) {
        var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var maxValue = currentValue[1];
        if (maxValue < minValue) {
          maxValue = minValue;
        }
        _this.setValue([minValue, maxValue]);
      });
      group2.on("legend-handler-max:drag", function(ev) {
        var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var minValue = currentValue[0];
        if (minValue > maxValue) {
          minValue = maxValue;
        }
        _this.setValue([minValue, maxValue]);
      });
    };
    ContinueLegend2.prototype.bindRailEvent = function(group2) {
    };
    ContinueLegend2.prototype.bindTrackEvent = function(group2) {
      var _this = this;
      var prePoint = null;
      group2.on("legend-track:dragstart", function(ev) {
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:drag", function(ev) {
        if (!prePoint) {
          return;
        }
        var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
        var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var curDiff = currentValue[1] - currentValue[0];
        var range2 = _this.getRange();
        var dValue = curValue - preValue;
        if (dValue < 0) {
          if (currentValue[0] + dValue > range2.min) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range2.min, range2.min + curDiff]);
          }
        } else if (dValue > 0) {
          if (dValue > 0 && currentValue[1] + dValue < range2.max) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range2.max - curDiff, range2.max]);
          }
        }
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:dragend", function(ev) {
        prePoint = null;
      });
    };
    ContinueLegend2.prototype.drawLabels = function(group2) {
      this.drawLabel("min", group2);
      this.drawLabel("max", group2);
    };
    ContinueLegend2.prototype.drawLabel = function(name, group2) {
      var labelCfg = this.get("label");
      var style = labelCfg.style;
      var labelAlign = labelCfg.align;
      var labelFormatter = labelCfg.formatter;
      var value2 = this.get(name);
      var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
      var localId = "label-" + name;
      this.addShape(group2, {
        type: "text",
        id: this.getElementId(localId),
        name: "legend-label-" + name,
        attrs: __assign(__assign({ x: 0, y: 0, text: is_function_default(labelFormatter) ? labelFormatter(value2) : value2 }, style), alignAttrs)
      });
    };
    ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
      var isVertical2 = this.isVertical();
      var textAlign = "center";
      var textBaseline = "middle";
      if (isVertical2) {
        textAlign = "start";
        if (align !== "rail") {
          if (name === "min") {
            textBaseline = "top";
          } else {
            textBaseline = "bottom";
          }
        } else {
          textBaseline = "top";
        }
      } else {
        if (align !== "rail") {
          textBaseline = "top";
          if (name === "min") {
            textAlign = "start";
          } else {
            textAlign = "end";
          }
        } else {
          textAlign = "start";
          textBaseline = "middle";
        }
      }
      return {
        textAlign,
        textBaseline
      };
    };
    ContinueLegend2.prototype.getRailPath = function(x, y, w, h) {
      var railCfg = this.get("rail");
      var size3 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
      var isVertical2 = this.isVertical();
      var length5 = defaultLength;
      var width = w;
      var height = h;
      if (!width) {
        width = isVertical2 ? size3 : length5;
      }
      if (!height) {
        height = isVertical2 ? length5 : size3;
      }
      var path = [];
      if (type === "color") {
        path.push(["M", x, y]);
        path.push(["L", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      } else {
        path.push(["M", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      }
      return path;
    };
    ContinueLegend2.prototype.drawRail = function(group2) {
      var railCfg = this.get("rail");
      var style = railCfg.style;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("rail"),
        name: "legend-rail",
        attrs: __assign({ path: this.getRailPath(0, 0) }, style)
      });
    };
    ContinueLegend2.prototype.getTrackColor = function(colors) {
      var count2 = colors.length;
      if (!count2) {
        return null;
      }
      if (count2 === 1) {
        return colors[0];
      }
      var color3;
      if (this.isVertical()) {
        color3 = "l(90)";
      } else {
        color3 = "l(0)";
      }
      for (var i = 0; i < count2; i++) {
        var percent2 = i / (count2 - 1);
        color3 += " " + percent2 + ":" + colors[i];
      }
      return color3;
    };
    ContinueLegend2.prototype.getTrackPath = function(group2) {
      var railShape = this.getRailShape(group2);
      var path = railShape.attr("path");
      return clone_default(path);
    };
    ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
      var value2 = this.getCurrentValue();
      var min5 = value2[0], max5 = value2[1];
      var railBBox = this.getRailBBox(group2);
      var startPoint = this.getPointByValue(min5, group2);
      var endPoint = this.getPointByValue(max5, group2);
      var isVertical2 = this.isVertical();
      var x;
      var y;
      var width;
      var height;
      if (isVertical2) {
        x = railBBox.minX;
        y = startPoint.y;
        width = railBBox.width;
        height = endPoint.y - startPoint.y;
      } else {
        x = startPoint.x;
        y = railBBox.minY;
        width = endPoint.x - startPoint.x;
        height = railBBox.height;
      }
      return {
        x,
        y,
        width,
        height
      };
    };
    ContinueLegend2.prototype.getTrackAttrs = function(group2) {
      var trackCfg = this.get("track");
      var colors = this.get("colors");
      var path = this.getTrackPath(group2);
      return mix({
        path,
        fill: this.getTrackColor(colors)
      }, trackCfg.style);
    };
    ContinueLegend2.prototype.resetTrackClip = function(group2) {
      var container = group2 || this.get("group");
      var trackId = this.getElementId("track");
      var trackShape = container.findById(trackId);
      var clipShape = trackShape.getClip();
      var attrs = this.getClipTrackAttrs(group2);
      if (!clipShape) {
        trackShape.setClip({
          type: "rect",
          attrs
        });
      } else {
        clipShape.attr(attrs);
      }
    };
    ContinueLegend2.prototype.resetTrack = function(group2) {
      var trackId = this.getElementId("track");
      var trackShape = group2.findById(trackId);
      var trackAttrs = this.getTrackAttrs(group2);
      if (trackShape) {
        trackShape.attr(trackAttrs);
      } else {
        this.addShape(group2, {
          type: "path",
          id: trackId,
          draggable: this.get("slidable"),
          name: "legend-track",
          attrs: trackAttrs
        });
      }
    };
    ContinueLegend2.prototype.getPointByValue = function(value2, group2) {
      var _a6 = this.getRange(), min5 = _a6.min, max5 = _a6.max;
      var percent2 = (value2 - min5) / (max5 - min5);
      var bbox = this.getRailBBox(group2);
      var isVertcal = this.isVertical();
      var point2 = { x: 0, y: 0 };
      if (isVertcal) {
        point2.x = bbox.minX + bbox.width / 2;
        point2.y = getValueByPercent(bbox.minY, bbox.maxY, percent2);
      } else {
        point2.x = getValueByPercent(bbox.minX, bbox.maxX, percent2);
        point2.y = bbox.minY + bbox.height / 2;
      }
      return point2;
    };
    ContinueLegend2.prototype.getRailShape = function(group2) {
      var container = group2 || this.get("group");
      return container.findById(this.getElementId("rail"));
    };
    ContinueLegend2.prototype.getRailBBox = function(group2) {
      var railShape = this.getRailShape(group2);
      var bbox = railShape.getBBox();
      return bbox;
    };
    ContinueLegend2.prototype.getRailCanvasBBox = function() {
      var container = this.get("group");
      var railShape = container.findById(this.getElementId("rail"));
      var bbox = railShape.getCanvasBBox();
      return bbox;
    };
    ContinueLegend2.prototype.isVertical = function() {
      return this.get("layout") === "vertical";
    };
    ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
      var _a6 = this.getRange(), min5 = _a6.min, max5 = _a6.max;
      var bbox = this.getRailCanvasBBox();
      var isVertcal = this.isVertical();
      var step = this.get("step");
      var percent2;
      if (isVertcal) {
        percent2 = (y - bbox.minY) / bbox.height;
      } else {
        percent2 = (x - bbox.minX) / bbox.width;
      }
      var value2 = getValueByPercent(min5, max5, percent2);
      if (step) {
        var count2 = Math.round((value2 - min5) / step);
        value2 = min5 + count2 * step;
      }
      if (value2 > max5) {
        value2 = max5;
      }
      if (value2 < min5) {
        value2 = min5;
      }
      return value2;
    };
    ContinueLegend2.prototype.getCurrentValue = function() {
      var value2 = this.get("value");
      if (!value2) {
        var values3 = this.get("values");
        if (!values3) {
          return [this.get("min"), this.get("max")];
        }
        return [Math.max(Math.min.apply(Math, __spreadArrays(values3, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values3, [this.get("min")])), this.get("max"))];
      }
      return value2;
    };
    ContinueLegend2.prototype.resetHandlers = function(group2) {
      var currentValue = this.getCurrentValue();
      var min5 = currentValue[0], max5 = currentValue[1];
      this.resetHandler(group2, "min", min5);
      this.resetHandler(group2, "max", max5);
    };
    ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point2) {
      var isVertical2 = this.isVertical();
      var path = [];
      var width = handlerCfg.size;
      var x = point2.x, y = point2.y;
      var height = width * HANDLER_HEIGHT_RATIO;
      var halfWidth = width / 2;
      var oneSixthWidth = width / 6;
      if (isVertical2) {
        var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", triangleX, y + halfWidth]);
        path.push(["L", x + height, y + halfWidth]);
        path.push(["L", x + height, y - halfWidth]);
        path.push(["L", triangleX, y - halfWidth]);
        path.push(["Z"]);
        path.push(["M", triangleX, y + oneSixthWidth]);
        path.push(["L", x + height - 2, y + oneSixthWidth]);
        path.push(["M", triangleX, y - oneSixthWidth]);
        path.push(["L", x + height - 2, y - oneSixthWidth]);
      } else {
        var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", x - halfWidth, triangleY]);
        path.push(["L", x - halfWidth, y + height]);
        path.push(["L", x + halfWidth, y + height]);
        path.push(["L", x + halfWidth, triangleY]);
        path.push(["Z"]);
        path.push(["M", x - oneSixthWidth, triangleY]);
        path.push(["L", x - oneSixthWidth, y + height - 2]);
        path.push(["M", x + oneSixthWidth, triangleY]);
        path.push(["L", x + oneSixthWidth, y + height - 2]);
      }
      return path;
    };
    ContinueLegend2.prototype.resetHandler = function(group2, name, value2) {
      var point2 = this.getPointByValue(value2, group2);
      var handlerCfg = this.get("handler");
      var path = this.getHandlerPath(handlerCfg, point2);
      var id = this.getElementId("handler-" + name);
      var handlerShape = group2.findById(id);
      var isVertical2 = this.isVertical();
      if (handlerShape) {
        handlerShape.attr("path", path);
      } else {
        this.addShape(group2, {
          type: "path",
          name: "legend-handler-" + name,
          draggable: true,
          id,
          attrs: __assign(__assign({ path }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
        });
      }
    };
    ContinueLegend2.prototype.fixedElements = function(group2) {
      var railShape = group2.findById(this.getElementId("rail"));
      var minLabel = group2.findById(this.getElementId("label-min"));
      var maxLabel = group2.findById(this.getElementId("label-max"));
      var startPoint = this.getDrawPoint();
      if (this.isVertical()) {
        this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
      } else {
        this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
      }
    };
    ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
      var isVertical2 = this.isVertical();
      var lengthField = isVertical2 ? "height" : "width";
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var maxLength = this.get("max" + upper_first_default(lengthField));
      if (maxLength) {
        var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
        var diff2 = elementsLength - maxLength;
        if (diff2 > 0) {
          this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
        }
      }
    };
    ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length5) {
      var bbox = railShape.getBBox();
      var path;
      if (lengthField === "height") {
        path = this.getRailPath(bbox.x, bbox.y, bbox.width, length5);
      } else {
        path = this.getRailPath(bbox.x, bbox.y, length5, bbox.height);
      }
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
      var bbox = railShape.getBBox();
      var path = this.getRailPath(x, y, bbox.width, bbox.height);
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      var railHeight = railBBox.height;
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railHeight / 2
        });
        this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
          y: startPoint.y + railHeight / 2
        });
      } else if (labelAlign === "top") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      } else {
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height + spacing
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y + railBBox.height + spacing
        });
      }
    };
    ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
        });
      } else if (labelAlign === "right") {
        minLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y + railBBox.height
        });
      } else {
        var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height
        });
      }
    };
    return ContinueLegend2;
  }(base_default11)
);
var continuous_default = ContinueLegend;

// node_modules/@antv/component/esm/tooltip/index.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Html: () => html_default3
});

// node_modules/@antv/component/esm/tooltip/css-const.js
var css_const_exports2 = {};
__export(css_const_exports2, {
  CONTAINER_CLASS: () => CONTAINER_CLASS2,
  CROSSHAIR_X: () => CROSSHAIR_X,
  CROSSHAIR_Y: () => CROSSHAIR_Y,
  LIST_CLASS: () => LIST_CLASS,
  LIST_ITEM_CLASS: () => LIST_ITEM_CLASS,
  MARKER_CLASS: () => MARKER_CLASS,
  NAME_CLASS: () => NAME_CLASS,
  TITLE_CLASS: () => TITLE_CLASS,
  VALUE_CLASS: () => VALUE_CLASS
});
var CONTAINER_CLASS2 = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";

// node_modules/@antv/component/esm/tooltip/html-theme.js
var _a2;
var html_theme_default2 = (_a2 = {}, // css style for tooltip
_a2["" + CONTAINER_CLASS2] = {
  position: "absolute",
  visibility: "visible",
  // @2018-07-25 by blue.lb 
  // whiteSpace: 'nowrap',
  zIndex: 8,
  transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
  backgroundColor: "rgba(255, 255, 255, 0.9)",
  boxShadow: "0px 0px 10px #aeaeae",
  borderRadius: "3px",
  color: "rgb(87, 87, 87)",
  fontSize: "12px",
  fontFamily: theme_default.fontFamily,
  lineHeight: "20px",
  padding: "10px 10px 6px 10px"
}, _a2["" + TITLE_CLASS] = {
  marginBottom: "4px"
}, _a2["" + LIST_CLASS] = {
  margin: "0px",
  listStyleType: "none",
  padding: "0px"
}, _a2["" + LIST_ITEM_CLASS] = {
  listStyleType: "none",
  marginBottom: "4px"
}, _a2["" + MARKER_CLASS] = {
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  display: "inline-block",
  marginRight: "8px"
}, _a2["" + VALUE_CLASS] = {
  display: "inline-block",
  float: "right",
  marginLeft: "30px"
}, _a2["" + CROSSHAIR_X] = {
  position: "absolute",
  width: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a2["" + CROSSHAIR_Y] = {
  position: "absolute",
  height: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a2);

// node_modules/@antv/component/esm/util/align.js
function getOutSides(x, y, width, height, limitBox) {
  var hits = {
    left: x < limitBox.x,
    right: x + width > limitBox.x + limitBox.width,
    top: y < limitBox.y,
    bottom: y + height > limitBox.y + limitBox.height
  };
  return hits;
}
function getPointByPosition(x, y, offset, width, height, position) {
  var px = x;
  var py = y;
  switch (position) {
    case "left":
      px = x - width - offset;
      py = y - height / 2;
      break;
    case "right":
      px = x + offset;
      py = y - height / 2;
      break;
    case "top":
      px = x - width / 2;
      py = y - height - offset;
      break;
    case "bottom":
      px = x - width / 2;
      py = y + offset;
      break;
    default:
      px = x + offset;
      py = y - height - offset;
      break;
  }
  return {
    x: px,
    y: py
  };
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
  var point2 = getPointByPosition(x, y, offset, width, height, position);
  if (limitBox) {
    var outSides = getOutSides(point2.x, point2.y, width, height, limitBox);
    if (position === "auto") {
      if (outSides.right) {
        point2.x = Math.max(0, x - width - offset);
      }
      if (outSides.top) {
        point2.y = Math.max(0, y - height - offset);
      }
    } else if (position === "top" || position === "bottom") {
      if (outSides.left) {
        point2.x = limitBox.x;
      }
      if (outSides.right) {
        point2.x = limitBox.x + limitBox.width - width;
      }
      if (position === "top" && outSides.top) {
        point2.y = y + offset;
      }
      if (position === "bottom" && outSides.bottom) {
        point2.y = y - height - offset;
      }
    } else {
      if (outSides.top) {
        point2.y = limitBox.y;
      }
      if (outSides.bottom) {
        point2.y = limitBox.y + limitBox.height - height;
      }
      if (position === "left" && outSides.left) {
        point2.x = x + offset;
      }
      if (position === "right" && outSides.right) {
        point2.x = x - width - offset;
      }
    }
  }
  return point2;
}

// node_modules/@antv/component/esm/tooltip/html.js
function hasOneKey(obj, keys3) {
  var result2 = false;
  each_default(keys3, function(key) {
    if (has_key_default(obj, key)) {
      result2 = true;
      return false;
    }
  });
  return result2;
}
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), {
        name: "tooltip",
        type: "html",
        x: 0,
        y: 0,
        items: [],
        customContent: null,
        containerTpl: '<div class="' + CONTAINER_CLASS2 + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
        itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
        xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
        yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
        title: null,
        showTitle: true,
        /**
         * tooltip 
         * @type {Region}
         */
        region: null,
        // crosshair 
        crosshairsRegion: null,
        containerClassName: CONTAINER_CLASS2,
        // x, y, xy
        crosshairs: null,
        offset: 10,
        position: "right",
        domStyles: null,
        defaultStyles: html_theme_default2
      });
    };
    Tooltip3.prototype.render = function() {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        this.resetTitle();
        this.renderItems();
      }
      this.resetPosition();
    };
    Tooltip3.prototype.clear = function() {
      this.clearCrosshairs();
      this.setTitle("");
      this.clearItemDoms();
    };
    Tooltip3.prototype.show = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", true);
      modifyCSS(container, {
        visibility: "visible"
      });
      this.setCrossHairsVisible(true);
    };
    Tooltip3.prototype.hide = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", false);
      modifyCSS(container, {
        visibility: "hidden"
      });
      this.setCrossHairsVisible(false);
    };
    Tooltip3.prototype.getLocation = function() {
      return { x: this.get("x"), y: this.get("y") };
    };
    Tooltip3.prototype.setLocation = function(point2) {
      this.set("x", point2.x);
      this.set("y", point2.y);
      this.resetPosition();
    };
    Tooltip3.prototype.setCrossHairsVisible = function(visible) {
      var display = visible ? "" : "none";
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && modifyCSS(xCrosshairDom, {
        display
      });
      yCrosshairDom && modifyCSS(yCrosshairDom, {
        display
      });
    };
    Tooltip3.prototype.initContainer = function() {
      _super.prototype.initContainer.call(this);
      if (this.get("customContent")) {
        if (this.get("container")) {
          this.get("container").remove();
        }
        var container = this.getHtmlContentNode();
        this.get("parent").appendChild(container);
        this.set("container", container);
        this.resetStyles();
        this.applyStyles();
      }
    };
    Tooltip3.prototype.updateInner = function(cfg) {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        if (hasOneKey(cfg, ["title", "showTitle"])) {
          this.resetTitle();
        }
        if (has_key_default(cfg, "items")) {
          this.renderItems();
        }
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    Tooltip3.prototype.initDom = function() {
      this.cacheDoms();
    };
    Tooltip3.prototype.removeDom = function() {
      _super.prototype.removeDom.call(this);
      this.clearCrosshairs();
    };
    Tooltip3.prototype.resetPosition = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offset = this.get("offset");
      var _a6 = this.getOffset(), offsetX = _a6.offsetX, offsetY = _a6.offsetY;
      var position = this.get("position");
      var region = this.get("region");
      var container = this.getContainer();
      var bbox = this.getBBox();
      var width = bbox.width, height = bbox.height;
      var limitBox;
      if (region) {
        limitBox = regionToBBox(region);
      }
      var point2 = getAlignPoint(x, y, offset, width, height, position, limitBox);
      modifyCSS(container, {
        left: toPx(point2.x + offsetX),
        top: toPx(point2.y + offsetY)
      });
      this.resetCrosshairs();
    };
    Tooltip3.prototype.renderCustomContent = function() {
      var node = this.getHtmlContentNode();
      var parent2 = this.get("parent");
      var curContainer = this.get("container");
      if (curContainer && curContainer.parentNode === parent2) {
        parent2.replaceChild(node, curContainer);
      } else {
        parent2.appendChild(node);
      }
      this.set("container", node);
      this.resetStyles();
      this.applyStyles();
    };
    Tooltip3.prototype.getHtmlContentNode = function() {
      var node;
      var customContent = this.get("customContent");
      if (customContent) {
        var elem = customContent(this.get("title"), this.get("items"));
        if (is_element_default(elem)) {
          node = elem;
        } else {
          node = createDom(elem);
        }
      }
      return node;
    };
    Tooltip3.prototype.cacheDoms = function() {
      var container = this.getContainer();
      var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
      var listDom = container.getElementsByClassName(LIST_CLASS)[0];
      this.set("titleDom", titleDom);
      this.set("listDom", listDom);
    };
    Tooltip3.prototype.resetTitle = function() {
      var title = this.get("title");
      var showTitle = this.get("showTitle");
      if (showTitle && title) {
        this.setTitle(title);
      } else {
        this.setTitle("");
      }
    };
    Tooltip3.prototype.setTitle = function(text) {
      var titleDom = this.get("titleDom");
      if (titleDom) {
        titleDom.innerText = text;
      }
    };
    Tooltip3.prototype.resetCrosshairs = function() {
      var crosshairsRegion = this.get("crosshairsRegion");
      var crosshairs = this.get("crosshairs");
      if (!crosshairsRegion || !crosshairs) {
        this.clearCrosshairs();
      } else {
        var crosshairBox = regionToBBox(crosshairsRegion);
        var xCrosshairDom = this.get("xCrosshairDom");
        var yCrosshairDom = this.get("yCrosshairDom");
        if (crosshairs === "x") {
          this.resetCrosshair("x", crosshairBox);
          if (yCrosshairDom) {
            yCrosshairDom.remove();
            this.set("yCrosshairDom", null);
          }
        } else if (crosshairs === "y") {
          this.resetCrosshair("y", crosshairBox);
          if (xCrosshairDom) {
            xCrosshairDom.remove();
            this.set("xCrosshairDom", null);
          }
        } else {
          this.resetCrosshair("x", crosshairBox);
          this.resetCrosshair("y", crosshairBox);
        }
        this.setCrossHairsVisible(this.get("visible"));
      }
    };
    Tooltip3.prototype.resetCrosshair = function(name, bbox) {
      var croshairDom = this.checkCrosshair(name);
      var value2 = this.get(name);
      if (name === "x") {
        modifyCSS(croshairDom, {
          left: toPx(value2),
          top: toPx(bbox.y),
          height: toPx(bbox.height)
        });
      } else {
        modifyCSS(croshairDom, {
          top: toPx(value2),
          left: toPx(bbox.x),
          width: toPx(bbox.width)
        });
      }
    };
    Tooltip3.prototype.checkCrosshair = function(name) {
      var domName = name + "CrosshairDom";
      var tplName = name + "CrosshairTpl";
      var constName = "CROSSHAIR_" + name.toUpperCase();
      var styleName = css_const_exports2[constName];
      var croshairDom = this.get(domName);
      var parent2 = this.get("parent");
      if (!croshairDom) {
        croshairDom = createDom(this.get(tplName));
        this.applyStyle(styleName, croshairDom);
        parent2.appendChild(croshairDom);
        this.set(domName, croshairDom);
      }
      return croshairDom;
    };
    Tooltip3.prototype.renderItems = function() {
      this.clearItemDoms();
      var items = this.get("items");
      var itemTpl = this.get("itemTpl");
      var listDom = this.get("listDom");
      if (listDom) {
        each_default(items, function(item) {
          var color3 = esm_default2.toCSSGradient(item.color);
          var substituteObj = __assign(__assign({}, item), { color: color3 });
          var domStr = substitute_default(itemTpl, substituteObj);
          var itemDom = createDom(domStr);
          listDom.appendChild(itemDom);
        });
        this.applyChildrenStyles(listDom, this.get("domStyles"));
      }
    };
    Tooltip3.prototype.clearItemDoms = function() {
      if (this.get("listDom")) {
        clearDom(this.get("listDom"));
      }
    };
    Tooltip3.prototype.clearCrosshairs = function() {
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && xCrosshairDom.remove();
      yCrosshairDom && yCrosshairDom.remove();
      this.set("xCrosshairDom", null);
      this.set("yCrosshairDom", null);
    };
    return Tooltip3;
  }(html_component_default)
);
var html_default3 = Tooltip;

// node_modules/@antv/component/esm/trend/constant.js
var BACKGROUND_STYLE = {
  // fill: 'red',
  opacity: 0
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};

// node_modules/@antv/component/esm/trend/path.js
function pointsToPath(points2) {
  return map_default(points2, function(p, idx) {
    var command = idx === 0 ? "M" : "L";
    var x = p[0], y = p[1];
    return [command, x, y];
  });
}
function getLinePath(points2) {
  return pointsToPath(points2);
}
function getSmoothLinePath(points2) {
  if (points2.length <= 2) {
    return getLinePath(points2);
  }
  var data3 = [];
  each_default(points2, function(p) {
    if (!is_equal_default(p, data3.slice(data3.length - 2))) {
      data3.push(p[0], p[1]);
    }
  });
  var path = catmull_rom_2_bezier_default(data3, false);
  var _a6 = head(points2), x = _a6[0], y = _a6[1];
  path.unshift(["M", x, y]);
  return path;
}
function dataToPath(data3, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y = new linear_default({
    values: data3
  });
  var x = new base_default5({
    values: map_default(data3, function(v, idx) {
      return idx;
    })
  });
  var points2 = map_default(data3, function(v, idx) {
    return [x.scale(idx) * width, height - y.scale(v) * height];
  });
  return smooth ? getSmoothLinePath(points2) : getLinePath(points2);
}
function getAreaLineY(data3, height) {
  var y = new linear_default({
    values: data3
  });
  var lineY = y.max < 0 ? y.max : Math.max(0, y.min);
  return height - y.scale(lineY) * height;
}
function linePathToAreaPath(path, width, height, data3) {
  var areaPath = __spreadArrays(path);
  var lineYPx = getAreaLineY(data3, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}

// node_modules/@antv/component/esm/trend/trend.js
var Trend = (
  /** @class */
  function(_super) {
    __extends(Trend2, _super);
    function Trend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Trend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
    };
    Trend2.prototype.renderInner = function(group2) {
      var _a6 = this.cfg, width = _a6.width, height = _a6.height, data3 = _a6.data, smooth = _a6.smooth, isArea = _a6.isArea, backgroundStyle = _a6.backgroundStyle, lineStyle = _a6.lineStyle, areaStyle = _a6.areaStyle;
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var path = dataToPath(data3, width, height, smooth);
      this.addShape(group2, {
        id: this.getElementId("line"),
        type: "path",
        attrs: __assign({ path }, lineStyle)
      });
      if (isArea) {
        var areaPath = linePathToAreaPath(path, width, height, data3);
        this.addShape(group2, {
          id: this.getElementId("area"),
          type: "path",
          attrs: __assign({ path: areaPath }, areaStyle)
        });
      }
    };
    Trend2.prototype.applyOffset = function() {
      var _a6 = this.cfg, x = _a6.x, y = _a6.y;
      this.moveElementTo(this.get("group"), {
        x,
        y
      });
    };
    return Trend2;
  }(group_component_default)
);

// node_modules/@antv/component/esm/slider/handler.js
var DEFAULT_HANDLER_STYLE = {
  fill: "#F7F7F7",
  stroke: "#BFBFBF",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  // 
  highLightFill: "#FFF"
};
var Handler = (
  /** @class */
  function(_super) {
    __extends(Handler2, _super);
    function Handler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Handler2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
    };
    Handler2.prototype.renderInner = function(group2) {
      var _a6 = this.cfg, width = _a6.width, height = _a6.height, style = _a6.style;
      var fill2 = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        attrs: {
          x: 0,
          y: 0,
          width,
          height,
          fill: fill2,
          stroke,
          radius,
          opacity,
          cursor
        }
      });
      var x1 = 1 / 3 * width;
      var x2 = 2 / 3 * width;
      var y1 = 1 / 4 * height;
      var y2 = 3 / 4 * height;
      this.addShape(group2, {
        id: this.getElementId("line-left"),
        type: "line",
        attrs: {
          x1,
          y1,
          x2: x1,
          y2,
          stroke,
          cursor
        }
      });
      this.addShape(group2, {
        id: this.getElementId("line-right"),
        type: "line",
        attrs: {
          x1: x2,
          y1,
          x2,
          y2,
          stroke,
          cursor
        }
      });
    };
    Handler2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Handler2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Handler2.prototype.bindEvents = function() {
      var _this = this;
      this.get("group").on("mouseenter", function() {
        var highLightFill = _this.get("style").highLightFill;
        _this.getElementByLocalId("background").attr("fill", highLightFill);
        _this.draw();
      });
      this.get("group").on("mouseleave", function() {
        var fill2 = _this.get("style").fill;
        _this.getElementByLocalId("background").attr("fill", fill2);
        _this.draw();
      });
    };
    Handler2.prototype.draw = function() {
      var canvas = this.get("container").get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    return Handler2;
  }(group_component_default)
);

// node_modules/@antv/component/esm/slider/constant.js
var BACKGROUND_STYLE2 = {
  fill: "#416180",
  opacity: 0.05
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.15,
  cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var SLIDER_CHANGE = "sliderchange";

// node_modules/@antv/component/esm/slider/slider.js
var Slider = (
  /** @class */
  function(_super) {
    __extends(Slider3, _super);
    function Slider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(target) {
        return function(e) {
          _this.currentTarget = target;
          var event = e.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
          _this.prevY = get_default(event, "touches.0.pageY", event.pageY);
          var containerDOM = _this.getContainerDOM();
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      _this.onMouseMove = function(event) {
        var width = _this.cfg.width;
        var originValue = [_this.get("start"), _this.get("end")];
        event.stopPropagation();
        event.preventDefault();
        var x = get_default(event, "touches.0.pageX", event.pageX);
        var y = get_default(event, "touches.0.pageY", event.pageY);
        var offsetX = x - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
        _this.prevX = x;
        _this.prevY = y;
        _this.draw();
        _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
        _this.delegateEmit("valuechanged", {
          originValue,
          value: [_this.get("start"), _this.get("end")]
        });
      };
      _this.onMouseUp = function() {
        if (_this.currentTarget) {
          _this.currentTarget = void 0;
        }
        var containerDOM = _this.getContainerDOM();
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      return _this;
    }
    Slider3.prototype.setRange = function(min5, max5) {
      this.set("minLimit", min5);
      this.set("maxLimit", max5);
      var oldStart = this.get("start");
      var oldEnd = this.get("end");
      var newStart = clamp_default(oldStart, min5, max5);
      var newEnd = clamp_default(oldEnd, min5, max5);
      if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
        this.setValue([newStart, newEnd]);
      }
    };
    Slider3.prototype.getRange = function() {
      return {
        min: this.get("minLimit") || 0,
        max: this.get("maxLimit") || 1
      };
    };
    Slider3.prototype.setValue = function(value2) {
      var range2 = this.getRange();
      if (is_array_default(value2) && value2.length === 2) {
        var originValue = [this.get("start"), this.get("end")];
        this.update({
          start: clamp_default(value2[0], range2.min, range2.max),
          end: clamp_default(value2[1], range2.min, range2.max)
        });
        if (!this.get("updateAutoRender")) {
          this.render();
        }
        this.delegateEmit("valuechanged", {
          originValue,
          value: value2
        });
      }
    };
    Slider3.prototype.getValue = function() {
      return [this.get("start"), this.get("end")];
    };
    Slider3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
        backgroundStyle: BACKGROUND_STYLE2,
        foregroundStyle: FOREGROUND_STYLE,
        handlerStyle: HANDLER_STYLE,
        textStyle: TEXT_STYLE
      } });
    };
    Slider3.prototype.update = function(cfg) {
      var start = cfg.start, end = cfg.end;
      var validCfg = __assign({}, cfg);
      if (!is_nil_default(start)) {
        validCfg.start = clamp_default(start, 0, 1);
      }
      if (!is_nil_default(end)) {
        validCfg.end = clamp_default(end, 0, 1);
      }
      _super.prototype.update.call(this, validCfg);
      this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
      this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
      this.trend = this.getChildComponentById(this.getElementId("trend"));
    };
    Slider3.prototype.init = function() {
      this.set("start", clamp_default(this.get("start"), 0, 1));
      this.set("end", clamp_default(this.get("end"), 0, 1));
      _super.prototype.init.call(this);
    };
    Slider3.prototype.render = function() {
      _super.prototype.render.call(this);
      this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
    };
    Slider3.prototype.renderInner = function(group2) {
      var _a6 = this.cfg, start = _a6.start, end = _a6.end, width = _a6.width, height = _a6.height, _b = _a6.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a6.minText, maxText = _a6.maxText, _c = _a6.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a6.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a6.textStyle, textStyle2 = _e === void 0 ? {} : _e;
      var handlerStyle = deep_mix_default({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
      var min5 = start * width;
      var max5 = end * width;
      if (size(get_default(trendCfg, "data"))) {
        this.trend = this.addComponent(group2, __assign({
          component: Trend,
          id: this.getElementId("trend"),
          x: 0,
          y: 0,
          width,
          height
        }, trendCfg));
      }
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var minTextShape = this.addShape(group2, {
        id: this.getElementId("minText"),
        type: "text",
        attrs: __assign({
          // x: 0,
          y: height / 2,
          textAlign: "right",
          text: minText,
          silent: false
        }, textStyle2)
      });
      var maxTextShape = this.addShape(group2, {
        id: this.getElementId("maxText"),
        type: "text",
        attrs: __assign({
          // x: 0,
          y: height / 2,
          textAlign: "left",
          text: maxText,
          silent: false
        }, textStyle2)
      });
      var foregroundShape = this.addShape(group2, {
        id: this.getElementId("foreground"),
        name: "foreground",
        type: "rect",
        attrs: __assign({
          // x: 0,
          y: 0,
          // width: 0,
          height
        }, foregroundStyle)
      });
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var handlerHeight = get_default(handlerStyle, "height", 24);
      this.minHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("minHandler"),
        name: "handler-min",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
      this.maxHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("maxHandler"),
        name: "handler-max",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
    };
    Slider3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Slider3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Slider3.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
      var _a6 = this.cfg, start = _a6.start, end = _a6.end, width = _a6.width, minText = _a6.minText, maxText = _a6.maxText, handlerStyle = _a6.handlerStyle, height = _a6.height;
      var min5 = start * width;
      var max5 = end * width;
      if (this.trend) {
        this.trend.update({
          width,
          height
        });
        if (!this.get("updateAutoRender")) {
          this.trend.render();
        }
      }
      foregroundShape.attr("x", min5);
      foregroundShape.attr("width", max5 - min5);
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      minTextShape.attr("text", minText);
      maxTextShape.attr("text", maxText);
      var _b = this._dodgeText([min5, max5], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
      if (this.minHandler) {
        this.minHandler.update({
          x: min5 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.minHandler.render();
        }
      }
      each_default(minAttrs, function(v, k) {
        return minTextShape.attr(k, v);
      });
      if (this.maxHandler) {
        this.maxHandler.update({
          x: max5 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.maxHandler.render();
        }
      }
      each_default(maxAttrs, function(v, k) {
        return maxTextShape.attr(k, v);
      });
    };
    Slider3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
      group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
      group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
      group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
      var foreground = group2.findById(this.getElementId("foreground"));
      foreground.on("mousedown", this.onMouseDown("foreground"));
      foreground.on("touchstart", this.onMouseDown("foreground"));
    };
    Slider3.prototype.adjustOffsetRange = function(offsetRange) {
      var _a6 = this.cfg, start = _a6.start, end = _a6.end;
      switch (this.currentTarget) {
        case "minHandler": {
          var min5 = 0 - start;
          var max5 = 1 - start;
          return Math.min(max5, Math.max(min5, offsetRange));
        }
        case "maxHandler": {
          var min5 = 0 - end;
          var max5 = 1 - end;
          return Math.min(max5, Math.max(min5, offsetRange));
        }
        case "foreground": {
          var min5 = 0 - start;
          var max5 = 1 - end;
          return Math.min(max5, Math.max(min5, offsetRange));
        }
      }
    };
    Slider3.prototype.updateStartEnd = function(offsetRange) {
      var _a6 = this.cfg, start = _a6.start, end = _a6.end;
      switch (this.currentTarget) {
        case "minHandler":
          start += offsetRange;
          break;
        case "maxHandler":
          end += offsetRange;
          break;
        case "foreground":
          start += offsetRange;
          end += offsetRange;
          break;
      }
      this.set("start", start);
      this.set("end", end);
    };
    Slider3.prototype._dodgeText = function(range2, minTextShape, maxTextShape) {
      var _a6, _b;
      var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
      var PADDING2 = 2;
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var min5 = range2[0], max5 = range2[1];
      var sorted = false;
      if (min5 > max5) {
        _a6 = [max5, min5], min5 = _a6[0], max5 = _a6[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = minBBox.width > min5 - PADDING2 ? { x: min5 + handlerWidth / 2 + PADDING2, textAlign: "left" } : { x: min5 - handlerWidth / 2 - PADDING2, textAlign: "right" };
      var maxAttrs = maxBBox.width > width - max5 - PADDING2 ? { x: max5 - handlerWidth / 2 - PADDING2, textAlign: "right" } : { x: max5 + handlerWidth / 2 + PADDING2, textAlign: "left" };
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    Slider3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Slider3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    return Slider3;
  }(group_component_default)
);

// node_modules/@antv/component/esm/scrollbar/scrollbar.js
var DEFAULT_STYLE = {
  trackColor: "rgba(0,0,0,0)",
  thumbColor: "rgba(0,0,0,0.15)",
  size: 8,
  lineCap: "round"
};
var DEFAULT_THEME = {
  // 
  default: DEFAULT_STYLE,
  //  hover 
  hover: {
    thumbColor: "rgba(0,0,0,0.2)"
  }
};
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clearEvents = noop_default;
      _this.onStartEvent = function(isMobile) {
        return function(e) {
          _this.isMobile = isMobile;
          e.originalEvent.preventDefault();
          var clientX = isMobile ? get_default(e.originalEvent, "touches.0.clientX") : e.clientX;
          var clientY = isMobile ? get_default(e.originalEvent, "touches.0.clientY") : e.clientY;
          _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
          _this.bindLaterEvent();
        };
      };
      _this.bindLaterEvent = function() {
        var containerDOM = _this.getContainerDOM();
        var events = [];
        if (_this.isMobile) {
          events = [
            addEventListener(containerDOM, "touchmove", _this.onMouseMove),
            addEventListener(containerDOM, "touchend", _this.onMouseUp),
            addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
          ];
        } else {
          events = [
            addEventListener(containerDOM, "mousemove", _this.onMouseMove),
            addEventListener(containerDOM, "mouseup", _this.onMouseUp),
            //  canvas containerDom  mouseup
            addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
          ];
        }
        _this.clearEvents = function() {
          events.forEach(function(e) {
            e.remove();
          });
        };
      };
      _this.onMouseMove = function(e) {
        var _a6 = _this.cfg, isHorizontal2 = _a6.isHorizontal, thumbOffset = _a6.thumbOffset;
        e.preventDefault();
        var clientX = _this.isMobile ? get_default(e, "touches.0.clientX") : e.clientX;
        var clientY = _this.isMobile ? get_default(e, "touches.0.clientY") : e.clientY;
        var endPos = isHorizontal2 ? clientX : clientY;
        var diff2 = endPos - _this.startPos;
        _this.startPos = endPos;
        _this.updateThumbOffset(thumbOffset + diff2);
      };
      _this.onMouseUp = function(e) {
        e.preventDefault();
        _this.clearEvents();
      };
      _this.onTrackClick = function(e) {
        var _a6 = _this.cfg, isHorizontal2 = _a6.isHorizontal, x = _a6.x, y = _a6.y, thumbLen = _a6.thumbLen;
        var containerDOM = _this.getContainerDOM();
        var rect2 = containerDOM.getBoundingClientRect();
        var clientX = e.clientX, clientY = e.clientY;
        var offset = isHorizontal2 ? clientX - rect2.left - x - thumbLen / 2 : clientY - rect2.top - y - thumbLen / 2;
        var newOffset = _this.validateRange(offset);
        _this.updateThumbOffset(newOffset);
      };
      _this.onThumbMouseOver = function() {
        var thumbColor = _this.cfg.theme.hover.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      _this.onThumbMouseOut = function() {
        var thumbColor = _this.cfg.theme.default.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      return _this;
    }
    Scrollbar3.prototype.setRange = function(min5, max5) {
      this.set("minLimit", min5);
      this.set("maxLimit", max5);
      var curValue = this.getValue();
      var newValue = clamp_default(curValue, min5, max5);
      if (curValue !== newValue && !this.get("isInit")) {
        this.setValue(newValue);
      }
    };
    Scrollbar3.prototype.getRange = function() {
      var min5 = this.get("minLimit") || 0;
      var max5 = this.get("maxLimit") || 1;
      return { min: min5, max: max5 };
    };
    Scrollbar3.prototype.setValue = function(value2) {
      var range2 = this.getRange();
      var originalValue = this.getValue();
      this.update({
        thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp_default(value2, range2.min, range2.max)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: this.getValue()
      });
    };
    Scrollbar3.prototype.getValue = function() {
      return clamp_default(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
    };
    Scrollbar3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign(__assign({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
    };
    Scrollbar3.prototype.renderInner = function(group2) {
      this.renderTrackShape(group2);
      this.renderThumbShape(group2);
    };
    Scrollbar3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Scrollbar3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Scrollbar3.prototype.renderTrackShape = function(group2) {
      var _a6 = this.cfg, trackLen = _a6.trackLen, _b = _a6.theme, theme4 = _b === void 0 ? { default: {} } : _b;
      var _c = deep_mix_default({}, DEFAULT_THEME, theme4).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: 0 + size3 / 2,
        y1: size3 / 2,
        x2: trackLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      } : {
        x1: size3 / 2,
        y1: 0 + size3 / 2,
        x2: size3 / 2,
        y2: trackLen - size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      };
      return this.addShape(group2, {
        id: this.getElementId("track"),
        name: "track",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.renderThumbShape = function(group2) {
      var _a6 = this.cfg, thumbOffset = _a6.thumbOffset, thumbLen = _a6.thumbLen, theme4 = _a6.theme;
      var _b = deep_mix_default({}, DEFAULT_THEME, theme4).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: thumbOffset + size3 / 2,
        y1: size3 / 2,
        x2: thumbOffset + thumbLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      } : {
        x1: size3 / 2,
        y1: thumbOffset + size3 / 2,
        x2: size3 / 2,
        y2: thumbOffset + thumbLen - size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      };
      return this.addShape(group2, {
        id: this.getElementId("thumb"),
        name: "thumb",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("mousedown", this.onStartEvent(false));
      group2.on("mouseup", this.onMouseUp);
      group2.on("touchstart", this.onStartEvent(true));
      group2.on("touchend", this.onMouseUp);
      var trackShape = group2.findById(this.getElementId("track"));
      trackShape.on("click", this.onTrackClick);
      var thumbShape = group2.findById(this.getElementId("thumb"));
      thumbShape.on("mouseover", this.onThumbMouseOver);
      thumbShape.on("mouseout", this.onThumbMouseOut);
    };
    Scrollbar3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    Scrollbar3.prototype.validateRange = function(offset) {
      var _a6 = this.cfg, thumbLen = _a6.thumbLen, trackLen = _a6.trackLen;
      var newOffset = offset;
      if (offset + thumbLen > trackLen) {
        newOffset = trackLen - thumbLen;
      } else if (offset + thumbLen < thumbLen) {
        newOffset = 0;
      }
      return newOffset;
    };
    Scrollbar3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Scrollbar3.prototype.updateThumbOffset = function(offset) {
      var _a6 = this.cfg, thumbOffset = _a6.thumbOffset, isHorizontal2 = _a6.isHorizontal, thumbLen = _a6.thumbLen, size3 = _a6.size;
      var newOffset = this.validateRange(offset);
      if (newOffset === thumbOffset) {
        return;
      }
      var thumbShape = this.getElementByLocalId("thumb");
      if (isHorizontal2) {
        thumbShape.attr({
          x1: newOffset + size3 / 2,
          x2: newOffset + thumbLen - size3 / 2
        });
      } else {
        thumbShape.attr({
          y1: newOffset + size3 / 2,
          y2: newOffset + thumbLen - size3 / 2
        });
      }
      this.emitOffsetChange(newOffset);
    };
    Scrollbar3.prototype.emitOffsetChange = function(offset) {
      var _a6 = this.cfg, originalValue = _a6.thumbOffset, trackLen = _a6.trackLen, thumbLen = _a6.thumbLen;
      this.cfg.thumbOffset = offset;
      this.emit("scrollchange", {
        thumbOffset: offset,
        ratio: clamp_default(offset / (trackLen - thumbLen), 0, 1)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: offset
      });
    };
    return Scrollbar3;
  }(group_component_default)
);

// node_modules/@antv/g2/esm/dependents.js
var LineAxis = axis_exports.Line;
var CircleAxis = axis_exports.Circle;
var LineGrid = grid_exports.Line;
var CircleGrid = grid_exports.Circle;
var CategoryLegend = legend_exports.Category;
var ContinuousLegend = legend_exports.Continuous;
var HtmlTooltip = tooltip_exports.Html;

// node_modules/@antv/g2/esm/util/graphics.js
function getPointsBox(points2) {
  if (is_empty_default(points2)) {
    return null;
  }
  var minX = points2[0].x;
  var maxX = points2[0].x;
  var minY = points2[0].y;
  var maxY2 = points2[0].y;
  each_default(points2, function(point2) {
    minX = minX > point2.x ? point2.x : minX;
    maxX = maxX < point2.x ? point2.x : maxX;
    minY = minY > point2.y ? point2.y : minY;
    maxY2 = maxY2 < point2.y ? point2.y : maxY2;
  });
  return {
    minX,
    maxX,
    minY,
    maxY: maxY2,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY2) / 2
  };
}
function uniqueValues(array) {
  return Array.from(new Set(array)).length === 1;
}
function mid(array) {
  return (min_default(array) + max_default(array)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, end.x, end.y],
      ["M", innerStart.x, innerStart.y]
    ];
    if (innerRadius) {
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(["M", start.x, start.y]);
    circlePathCommands.push(["Z"]);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
    ["L", innerEnd.x, innerEnd.y]
  ];
  if (innerRadius) {
    sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(["L", start.x, start.y]);
  sectorPathCommands.push(["Z"]);
  return sectorPathCommands;
}
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, start.x, start.y],
      ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 0, start.x, start.y],
      ["Z"]
    ];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
  ];
}
function getAngle2(shapeModel, coordinate11) {
  var points2 = shapeModel.points;
  var box2 = getPointsBox(points2);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate11.startAngle, coordEndAngle = coordinate11.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate11.isTransposed) {
    endAngle = box2.maxY * diffAngle;
    startAngle = box2.minY * diffAngle;
  } else {
    endAngle = box2.maxX * diffAngle;
    startAngle = box2.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle,
    endAngle
  };
}
function getPolygonCentroid(xs, ys) {
  if (is_number_default(xs) && is_number_default(ys)) {
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  if (uniqueValues(xs) || uniqueValues(ys))
    return [mid(xs), mid(ys)];
  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff2;
  var k = 0;
  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff2;
    y += (ys[former] + ys[current]) * diff2;
  }
  k *= 3;
  return [x / k, y / k];
}
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  each_default(originAttrs, function(v, k) {
    if (newAttrs[k] === void 0) {
      newAttrs[k] = void 0;
    }
  });
  return newAttrs;
}

// node_modules/@antv/g2/esm/util/helper.js
function isBetween2(value2, start, end) {
  var min5 = Math.min(start, end);
  var max5 = Math.max(start, end);
  return value2 >= min5 && value2 <= max5;
}
function padEnd(source, targetLength, padValue) {
  if (is_string_default(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (is_array_default(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff2 = targetLength - sourceLength;
      for (var i = 0; i < diff2; i++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
function omit(obj, keys3) {
  if (typeof obj === "object") {
    keys3.forEach(function(key) {
      delete obj[key];
    });
  }
  return obj;
}
function uniq2(sourceArray, targetArray, map5) {
  var e_1, _a6;
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map5 === void 0) {
    map5 = /* @__PURE__ */ new Map();
  }
  try {
    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
      var source = sourceArray_1_1.value;
      if (!map5.has(source)) {
        targetArray.push(source);
        map5.set(source, true);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a6 = sourceArray_1.return))
        _a6.call(sourceArray_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return targetArray;
}

// node_modules/@antv/g2/esm/util/bbox.js
var BBox = (
  /** @class */
  function() {
    function BBox2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = x;
      this.y = y;
      this.height = height;
      this.width = width;
    }
    BBox2.fromRange = function(minX, minY, maxX, maxY2) {
      return new BBox2(minX, minY, maxX - minX, maxY2 - minY);
    };
    BBox2.fromObject = function(bbox) {
      return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
    };
    Object.defineProperty(BBox2.prototype, "minX", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxX", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "minY", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxY", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tl", {
      get: function() {
        return { x: this.x, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tr", {
      get: function() {
        return { x: this.maxX, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bl", {
      get: function() {
        return { x: this.x, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "br", {
      get: function() {
        return { x: this.maxX, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.minY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return {
          x: this.maxX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.maxY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return {
          x: this.minX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    BBox2.prototype.isEqual = function(bbox) {
      return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
    };
    BBox2.prototype.contains = function(child) {
      return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
    };
    BBox2.prototype.clone = function() {
      return new BBox2(this.x, this.y, this.width, this.height);
    };
    BBox2.prototype.add = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.min(b.x, bbox.x);
        bbox.y = Math.min(b.y, bbox.y);
        bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.merge = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.max(b.x, bbox.x);
        bbox.y = Math.max(b.y, bbox.y);
        bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.cut = function(subBBox, direction2) {
      var width = subBBox.width;
      var height = subBBox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
        default:
          return this;
      }
    };
    BBox2.prototype.shrink = function(gap) {
      var _a6 = __read(gap, 4), top = _a6[0], right2 = _a6[1], bottom = _a6[2], left2 = _a6[3];
      return new BBox2(this.x + left2, this.y + top, this.width - left2 - right2, this.height - top - bottom);
    };
    BBox2.prototype.expand = function(gap) {
      var _a6 = __read(gap, 4), top = _a6[0], right2 = _a6[1], bottom = _a6[2], left2 = _a6[3];
      return new BBox2(this.x - left2, this.y - top, this.width + left2 + right2, this.height + top + bottom);
    };
    BBox2.prototype.exceed = function(bbox) {
      return [
        Math.max(-this.minY + bbox.minY, 0),
        Math.max(this.maxX - bbox.maxX, 0),
        Math.max(this.maxY - bbox.maxY, 0),
        Math.max(-this.minX + bbox.minX, 0)
      ];
    };
    BBox2.prototype.collide = function(bbox) {
      return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
    };
    BBox2.prototype.size = function() {
      return this.width * this.height;
    };
    BBox2.prototype.isPointIn = function(p) {
      return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
    };
    return BBox2;
  }()
);
function toPoints(bbox) {
  return [
    [bbox.minX, bbox.minY],
    [bbox.maxX, bbox.minY],
    [bbox.maxX, bbox.maxY],
    [bbox.minX, bbox.maxY]
  ];
}

// node_modules/@antv/g2/esm/util/coordinate.js
function getXDimensionLength(coordinate11) {
  if (coordinate11.isPolar && !coordinate11.isTransposed) {
    return (coordinate11.endAngle - coordinate11.startAngle) * coordinate11.getRadius();
  }
  var start = coordinate11.convert({ x: 0, y: 0 });
  var end = coordinate11.convert({ x: 1, y: 0 });
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
function isFullCircle(coordinate11) {
  if (coordinate11.isPolar) {
    var startAngle = coordinate11.startAngle, endAngle = coordinate11.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
function getDistanceToCenter(coordinate11, point2) {
  var center2 = coordinate11.getCenter();
  return Math.sqrt(Math.pow(point2.x - center2.x, 2) + Math.pow(point2.y - center2.y, 2));
}
function isPointInCoordinate(coordinate11, point2) {
  var result2 = false;
  if (coordinate11) {
    if (coordinate11.type === "theta") {
      var start = coordinate11.start, end = coordinate11.end;
      result2 = isBetween2(point2.x, start.x, end.x) && isBetween2(point2.y, start.y, end.y);
    } else {
      var invertPoint = coordinate11.invert(point2);
      result2 = isBetween2(invertPoint.x, 0, 1) && isBetween2(invertPoint.y, 0, 1);
    }
  }
  return result2;
}
function getAngleByPoint(coordinate11, point2) {
  var center2 = coordinate11.getCenter();
  return Math.atan2(point2.y - center2.y, point2.x - center2.x);
}
function getCoordinateClipCfg(coordinate11, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate11.start, end = coordinate11.end;
  var width = coordinate11.getWidth();
  var height = coordinate11.getHeight();
  if (coordinate11.isPolar) {
    var startAngle_1 = coordinate11.startAngle, endAngle_1 = coordinate11.endAngle;
    var center_1 = coordinate11.getCenter();
    var radius_1 = coordinate11.getRadius();
    return {
      type: "path",
      startState: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function(ratio) {
        var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
        return {
          path
        };
      },
      attrs: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate11.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: "rect",
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate11.isTransposed ? width + margin * 2 : 0,
      height: coordinate11.isTransposed ? 0 : height + margin * 2
    },
    endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
function getCoordinateBBox(coordinate11, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate11.start, end = coordinate11.end;
  var width = coordinate11.getWidth();
  var height = coordinate11.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}

// node_modules/@antv/g2/esm/util/scale.js
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value2) {
  var type = "linear";
  if (dateRegex.test(value2)) {
    type = "timeCat";
  } else if (is_string_default(value2)) {
    type = "cat";
  }
  return type;
}
function inferScaleType(scale8, scaleDef, attrType, geometryType) {
  if (scaleDef === void 0) {
    scaleDef = {};
  }
  if (scaleDef.type)
    return scaleDef.type;
  if (scale8.type !== "identity" && GROUP_ATTRS.includes(attrType) && ["interval"].includes(geometryType)) {
    return "cat";
  }
  return scale8.isCategory ? "cat" : scale8.type;
}
function createScaleByField(field6, data3, scaleDef) {
  var validData = data3 || [];
  if (is_number_default(field6) || is_nil_default(first_value_default(validData, field6)) && is_empty_default(scaleDef)) {
    var Identity2 = getClass("identity");
    return new Identity2({
      field: field6.toString(),
      values: [field6]
    });
  }
  var values3 = values_of_key_default(validData, field6);
  var type = get_default(scaleDef, "type", getDefaultType(values3[0]));
  var ScaleCtor = getClass(type);
  return new ScaleCtor(__assign({ field: field6, values: values3 }, scaleDef));
}
function syncScale(scale8, newScale) {
  if (scale8.type !== "identity" && newScale.type !== "identity") {
    var obj = {};
    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }
    scale8.change(obj);
  }
}
function getName(scale8) {
  return scale8.alias || scale8.field;
}
function getDefaultCategoryScaleRange(scale8, coordinate11, theme4) {
  var values3 = scale8.values;
  var count2 = values3.length;
  var range2;
  if (count2 === 1) {
    range2 = [0.5, 1];
  } else {
    var widthRatio = 1;
    var offset = 0;
    if (isFullCircle(coordinate11)) {
      if (!coordinate11.isTransposed) {
        range2 = [0, 1 - 1 / count2];
      } else {
        widthRatio = get_default(theme4, "widthRatio.multiplePie", 1 / 1.3);
        offset = 1 / count2 * widthRatio;
        range2 = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count2 / 2;
      range2 = [offset, 1 - offset];
    }
  }
  return range2;
}
function getMaxScale(scale8) {
  var values3 = scale8.values.filter(function(item) {
    return !is_nil_default(item) && !isNaN(item);
  });
  return Math.max.apply(Math, __spreadArray(__spreadArray([], __read(values3), false), [is_nil_default(scale8.max) ? -Infinity : scale8.max], false));
}

// node_modules/@antv/g2/esm/util/axis.js
function getLineAxisRelativeRegion(direction2) {
  var start;
  var end;
  switch (direction2) {
    case DIRECTION.TOP:
      start = { x: 0, y: 1 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.RIGHT:
      start = { x: 1, y: 0 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.BOTTOM:
      start = { x: 0, y: 0 };
      end = { x: 1, y: 0 };
      break;
    case DIRECTION.LEFT:
      start = { x: 0, y: 0 };
      end = { x: 0, y: 1 };
      break;
    default:
      start = end = { x: 0, y: 0 };
  }
  return { start, end };
}
function getCircleAxisRelativeRegion(coordinate11) {
  var start;
  var end;
  if (coordinate11.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return { start, end };
}
function getAxisRegion(coordinate11, direction2) {
  var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
  if (coordinate11.isRect) {
    region = getLineAxisRelativeRegion(direction2);
  } else if (coordinate11.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate11);
  }
  var start = region.start, end = region.end;
  return {
    start: coordinate11.convert(start),
    end: coordinate11.convert(end)
  };
}
function isVertical(region) {
  var start = region.start, end = region.end;
  return start.x === end.x;
}
function getAxisFactorByRegion(region, center2) {
  var start = region.start, end = region.end;
  var isAxisVertical = isVertical(region);
  if (isAxisVertical) {
    if ((start.y - end.y) * (center2.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    if ((end.x - start.x) * (start.y - center2.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
function getAxisThemeCfg(theme4, direction2) {
  var axisTheme = get_default(theme4, ["components", "axis"], {});
  return deep_mix_default({}, get_default(axisTheme, ["common"], {}), deep_mix_default({}, get_default(axisTheme, [direction2], {})));
}
function getAxisTitleOptions(theme4, direction2, axisOptions) {
  var axisTheme = get_default(theme4, ["components", "axis"], {});
  return deep_mix_default({}, get_default(axisTheme, ["common", "title"], {}), deep_mix_default({}, get_default(axisTheme, [direction2, "title"], {})), axisOptions);
}
function getCircleAxisCenterRadius(coordinate11) {
  var x = coordinate11.x, y = coordinate11.y, center2 = coordinate11.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate11.isTransposed ? coordinate11.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate11.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center2.x, start.y - center2.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center2.y ? vec2_exports.angle(startVector, normalVector) : vec2_exports.angle(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center2.x, 2) + Math.pow(start.y - center2.y, 2));
  return {
    center: center2,
    radius,
    startAngle,
    endAngle
  };
}
function getAxisOption(axes, field6) {
  if (is_boolean_default(axes)) {
    return axes === false ? false : {};
  }
  return get_default(axes, [field6]);
}
function getAxisDirection(axisOption, def) {
  return get_default(axisOption, "position", def);
}
function getAxisTitleText(scale8, axisOption) {
  return get_default(axisOption, ["title", "text"], getName(scale8));
}

// node_modules/@antv/g2/esm/facet/facet.js
var Facet = (
  /** @class */
  function() {
    function Facet3(view, cfg) {
      this.destroyed = false;
      this.facets = [];
      this.view = view;
      this.cfg = deep_mix_default({}, this.getDefaultCfg(), cfg);
    }
    Facet3.prototype.init = function() {
      if (!this.container) {
        this.container = this.createContainer();
      }
      var data3 = this.view.getData();
      this.facets = this.generateFacets(data3);
    };
    Facet3.prototype.render = function() {
      this.renderViews();
    };
    Facet3.prototype.update = function() {
    };
    Facet3.prototype.clear = function() {
      this.clearFacetViews();
    };
    Facet3.prototype.destroy = function() {
      this.clear();
      if (this.container) {
        this.container.remove(true);
        this.container = void 0;
      }
      this.destroyed = true;
      this.view = void 0;
      this.facets = [];
    };
    Facet3.prototype.facetToView = function(facet) {
      var region = facet.region, data3 = facet.data, _a6 = facet.padding, padding3 = _a6 === void 0 ? this.cfg.padding : _a6;
      var view = this.view.createView({
        region,
        padding: padding3
      });
      view.data(data3 || []);
      facet.view = view;
      this.beforeEachView(view, facet);
      var eachView = this.cfg.eachView;
      if (eachView) {
        eachView(view, facet);
      }
      this.afterEachView(view, facet);
      return view;
    };
    Facet3.prototype.createContainer = function() {
      var foregroundGroup = this.view.getLayer(LAYER.FORE);
      return foregroundGroup.addGroup();
    };
    Facet3.prototype.renderViews = function() {
      this.createFacetViews();
    };
    Facet3.prototype.createFacetViews = function() {
      var _this = this;
      return this.facets.map(function(facet) {
        return _this.facetToView(facet);
      });
    };
    Facet3.prototype.clearFacetViews = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        if (facet.view) {
          _this.view.removeView(facet.view);
          facet.view = void 0;
        }
      });
    };
    Facet3.prototype.parseSpacing = function() {
      var _a6 = this.view.viewBBox, width = _a6.width, height = _a6.height;
      var spacing = this.cfg.spacing;
      return spacing.map(function(s, idx) {
        if (is_number_default(s))
          return s / (idx === 0 ? width : height);
        else
          return parseFloat(s) / 100;
      });
    };
    Facet3.prototype.getFieldValues = function(data3, field6) {
      var rst = [];
      var cache3 = {};
      each_default(data3, function(d) {
        var value2 = d[field6];
        if (!is_nil_default(value2) && !cache3[value2]) {
          rst.push(value2);
          cache3[value2] = true;
        }
      });
      return rst;
    };
    Facet3.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var _a6 = __read(this.parseSpacing(), 2), xSpacing = _a6[0], ySpacing = _a6[1];
      var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
      var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
      var start = {
        x: (xRatio + xSpacing) * xIndex,
        y: (yRatio + ySpacing) * yIndex
      };
      var end = {
        x: start.x + xRatio,
        y: start.y + yRatio
      };
      return { start, end };
    };
    Facet3.prototype.getDefaultCfg = function() {
      return {
        eachView: void 0,
        showTitle: true,
        spacing: [0, 0],
        padding: 10,
        fields: []
      };
    };
    Facet3.prototype.getDefaultTitleCfg = function() {
      var fontFamily = this.view.getTheme().fontFamily;
      return {
        style: {
          fontSize: 14,
          fill: "#666",
          fontFamily
        }
      };
    };
    Facet3.prototype.processAxis = function(view, facet) {
      var options = view.getOptions();
      var coordinateOption = options.coordinate;
      var geometries = view.geometries;
      var coordinateType = get_default(coordinateOption, "type", "rect");
      if (coordinateType === "rect" && geometries.length) {
        if (is_nil_default(options.axes)) {
          options.axes = {};
        }
        var axes = options.axes;
        var _a6 = __read(geometries[0].getXYFields(), 2), x = _a6[0], y = _a6[1];
        var xOption = getAxisOption(axes, x);
        var yOption = getAxisOption(axes, y);
        if (xOption !== false) {
          options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
        }
        if (yOption !== false) {
          options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
        }
      }
    };
    Facet3.prototype.getFacetDataFilter = function(conditions) {
      return function(datum) {
        return every_default(conditions, function(condition) {
          var field6 = condition.field, value2 = condition.value;
          if (!is_nil_default(value2) && field6) {
            return datum[field6] === value2;
          }
          return true;
        });
      };
    };
    return Facet3;
  }()
);

// node_modules/@antv/g2/esm/facet/index.js
var Facets = {};
var getFacet = function(type) {
  return Facets[lower_case_default(type)];
};
var registerFacet = function(type, ctor) {
  Facets[lower_case_default(type)] = ctor;
};

// node_modules/@antv/g2/esm/interaction/action/base.js
var Action = (
  /** @class */
  function() {
    function Action2(context, cfg) {
      this.context = context;
      this.cfg = cfg;
      context.addAction(this);
    }
    Action2.prototype.applyCfg = function(cfg) {
      mix(this, cfg);
    };
    Action2.prototype.init = function() {
      this.applyCfg(this.cfg);
    };
    Action2.prototype.destroy = function() {
      this.context.removeAction(this);
      this.context = null;
    };
    return Action2;
  }()
);
var base_default12 = Action;

// node_modules/@antv/g2/esm/interaction/action/callback.js
var CallbackAction = (
  /** @class */
  function(_super) {
    __extends(CallbackAction2, _super);
    function CallbackAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CallbackAction2.prototype.execute = function() {
      if (this.callback) {
        this.callback(this.context);
      }
    };
    CallbackAction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.callback = null;
    };
    return CallbackAction2;
  }(base_default12)
);
var callback_default = CallbackAction;

// node_modules/@antv/g2/esm/interaction/action/register.js
var ActionCache = {};
function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return get_default(actionOption, "ActionClass");
}
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass,
    cfg
  };
}
function createCallbackAction(callback, context) {
  var action = new callback_default(context);
  action.callback = callback;
  action.name = "callback";
  return action;
}

// node_modules/@antv/g2/esm/geometry/shape/util/path.js
function _points2path(points2, isInCircle) {
  var path = [];
  if (points2.length) {
    path.push(["M", points2[0].x, points2[0].y]);
    for (var i = 1, length_1 = points2.length; i < length_1; i += 1) {
      var item = points2[i];
      path.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path.push(["Z"]);
    }
  }
  return path;
}
function _convertArr(arr, coord2) {
  var tmp = [arr[0]];
  for (var i = 1, len3 = arr.length; i < len3; i = i + 2) {
    var point2 = coord2.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point2.x, point2.y);
  }
  return tmp;
}
function _convertArcPath(path, coord2) {
  var isTransposed = coord2.isTransposed;
  var r = path[1];
  var x = path[6];
  var y = path[7];
  var point2 = coord2.convert({ x, y });
  var direction2 = isTransposed ? 0 : 1;
  return ["A", r, r, 0, 0, direction2, point2.x, point2.y];
}
function _convertPolarPath(pre, cur, coord2) {
  var isTransposed = coord2.isTransposed, startAngle = coord2.startAngle, endAngle = coord2.endAngle;
  var prePoint = pre[0].toLowerCase() === "a" ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? "y" : "x";
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
  var flag = angleRange > Math.PI ? 1 : 0;
  var convertPoint = coord2.convert(curPoint);
  var r = getDistanceToCenter(coord2, convertPoint);
  if (r >= 0.5) {
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord2.convert(middlePoint);
      rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}
function _filterFullCirleLine(path) {
  each_default(path, function(subPath, index) {
    var cur = subPath;
    if (cur[0].toLowerCase() === "a") {
      var pre = path[index - 1];
      var next = path[index + 1];
      if (next && next[0].toLowerCase() === "a") {
        if (pre && pre[0].toLowerCase() === "l") {
          pre[0] = "M";
        }
      } else if (pre && pre[0].toLowerCase() === "a") {
        if (next && next[0].toLowerCase() === "l") {
          next[0] = "M";
        }
      }
    }
  });
}
var smoothBezier2 = function(points2, smooth, isLoop, constraint) {
  var _a6;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min5;
  var max5;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a6 = __read(constraint, 2), min5 = _a6[0], max5 = _a6[1];
    for (var i = 0, l = points2.length; i < l; i++) {
      var point2 = points2[i];
      min5 = vec2_exports.min([0, 0], min5, point2);
      max5 = vec2_exports.max([0, 0], max5, point2);
    }
  }
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var point2 = points2[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len3 - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points2[isLoop ? i ? i - 1 : len3 - 1 : i - 1];
      nextPoint = points2[isLoop ? (i + 1) % len3 : i + 1];
      var v = [0, 0];
      v = vec2_exports.sub(v, nextPoint, prevPoint);
      v = vec2_exports.scale(v, v, smooth);
      var d0 = vec2_exports.distance(point2, prevPoint);
      var d1 = vec2_exports.distance(point2, nextPoint);
      var sum2 = d0 + d1;
      if (sum2 !== 0) {
        d0 /= sum2;
        d1 /= sum2;
      }
      var v1 = vec2_exports.scale([0, 0], v, -d0);
      var v2 = vec2_exports.scale([0, 0], v, d1);
      cp1 = vec2_exports.add([0, 0], point2, v1);
      nextCp0 = vec2_exports.add([0, 0], point2, v2);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point2));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point2));
      v1 = vec2_exports.sub([0, 0], nextCp0, point2);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point2, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point2));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point2));
      v2 = vec2_exports.sub([0, 0], point2, cp1);
      v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min5);
        cp1 = vec2_exports.min([0, 0], cp1, max5);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min5);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max5);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier2(pointList, 0.4, isLoop, constraint);
  var len3 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len3 - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len3];
    cp2 = controlPointList[len3 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getLinePath2(points2, isInCircle) {
  return _points2path(points2, isInCircle);
}
function getSplinePath(points2, isInCircle, constaint) {
  var data3 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return getLinePath2(points2, isInCircle);
  }
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var point2 = points2[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data3.push(point2.x);
      data3.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    // 
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier(data3, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
function convertNormalPath(coord2, path) {
  var tmp = [];
  each_default(path, function(subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "l":
      case "c":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
function convertPolarPath(coord2, path) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals5;
  each_default(path, function(subPath, index) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "c":
      case "q":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "l":
        pre = path[index - 1];
        cur = subPath;
        transposed = coord2.isTransposed;
        equals5 = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals5) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord2));
        } else {
          tmp.push(_convertArr(subPath, coord2));
        }
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp);
  return tmp;
}

// node_modules/@antv/g2/esm/interaction/action/util.js
function getMaskBBox(context, tolerance3) {
  var event = context.event;
  var maskShape = event.target;
  return getMaskBBoxByShape(maskShape, tolerance3);
}
function isValidMaskBBox(maskShape, tolerance3) {
  var maskBBox = maskShape.getCanvasBBox();
  var width = maskBBox.width, height = maskBBox.height;
  return width > 0 && height > 0 && (width >= tolerance3 || height >= tolerance3);
}
function getMaskBBoxByShape(maskShape, tolerance3) {
  var maskBBox = maskShape.getCanvasBBox();
  return isValidMaskBBox(maskShape, tolerance3) ? maskBBox : null;
}
function getMultiMaskBBoxList(context, tolerance3) {
  var maskShapes = context.event.maskShapes;
  return maskShapes.map(function(maskShape) {
    return getMaskBBoxByShape(maskShape, tolerance3);
  }).filter(function(bBox) {
    return !!bBox;
  });
}
function getMaskPath(context, tolerance3) {
  var event = context.event;
  var maskShape = event.target;
  return getMaskPathByMaskShape(maskShape, tolerance3);
}
function getMaskPathByMaskShape(maskShape, tolerance3) {
  return isValidMaskBBox(maskShape, tolerance3) ? maskShape.attr("path") : null;
}
function getMultiMaskPathList(context, tolerance3) {
  var maskShapes = context.event.maskShapes;
  return maskShapes.map(function(maskShape) {
    return getMaskPathByMaskShape(maskShape, tolerance3);
  });
}
function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
function getDelegationObject(context) {
  var event = context.event;
  var target = event.target;
  var delegateObject;
  if (target) {
    delegateObject = target.get("delegateObject");
  }
  return delegateObject;
}
function isElementChange(context) {
  var event = context.event.gEvent;
  if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
    return false;
  }
  return true;
}
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
function isMask(context) {
  var event = context.event;
  var target = event.target;
  return target && (target === null || target === void 0 ? void 0 : target.get("name")) === "mask" || isMultipleMask(context);
}
function isMultipleMask(context) {
  var _a6;
  return ((_a6 = context.event.target) === null || _a6 === void 0 ? void 0 : _a6.get("name")) === "multi-mask";
}
function getMaskedElements(context, tolerance3) {
  var target = context.event.target;
  if (isMultipleMask(context)) {
    return getMultiMaskedElements(context, tolerance3);
  }
  if (target.get("type") === "path") {
    var maskPath = getMaskPath(context, tolerance3);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context.view, maskPath);
  }
  var maskBBox = getMaskBBox(context, tolerance3);
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context.view, maskBBox);
}
function getMultiMaskedElements(context, tolerance3) {
  var target = context.event.target;
  if (target.get("type") === "path") {
    var maskPathList = getMultiMaskPathList(context, tolerance3);
    if (maskPathList.length > 0) {
      return maskPathList.flatMap(function(maskPath) {
        return getElementsByPath(context.view, maskPath);
      });
    }
    return null;
  }
  var maskBBoxList = getMultiMaskBBoxList(context, tolerance3);
  if (maskBBoxList.length > 0) {
    return maskBBoxList.flatMap(function(maskBBox) {
      return getIntersectElements(context.view, maskBBox);
    });
  }
  return null;
}
function getSiblingMaskElements(context, sibling, tolerance3) {
  if (isMultipleMask(context)) {
    return getSiblingMultiMaskedElements(context, sibling, tolerance3);
  }
  var maskBBox = getMaskBBox(context, tolerance3);
  if (!maskBBox) {
    return null;
  }
  return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
}
function getSiblingMaskElementsByBBox(maskBBox, context, sibling) {
  var view = context.view;
  var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
  var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
  var box2 = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box2);
}
function getSiblingMultiMaskedElements(context, sibling, tolerance3) {
  var maskBBoxList = getMultiMaskBBoxList(context, tolerance3);
  if (maskBBoxList.length > 0) {
    return maskBBoxList.flatMap(function(maskBBox) {
      return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
    });
  }
  return null;
}
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  each_default(geometries, function(geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    each_default(view.views, function(subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
function getElementsByField(view, field6, value2) {
  var elements = getElements(view);
  return elements.filter(function(el) {
    return getElementValue(el, field6) === value2;
  });
}
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  each_default(geometries, function(geom) {
    var elements = geom.getElementsBy(function(el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
function getElementValue(element, field6) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (is_array_default(record)) {
    value2 = record[0][field6];
  } else {
    value2 = record[field6];
  }
  return value2;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function getIntersectElements(view, box2) {
  var elements = getElements(view);
  var rst = [];
  each_default(elements, function(el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect(box2, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
function pathToPoints(path) {
  var points2 = [];
  each_default(path, function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i = 1; i < seg.length; i = i + 2) {
        points2.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points2.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points2;
}
function getElementsByPath(view, path) {
  var elements = getElements(view);
  var points2 = pathToPoints(path);
  var rst = elements.filter(function(el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = toPoints(shapeBBox);
    }
    return isPolygonsIntersect(points2, shapePoints);
  });
  return rst;
}
function getComponents(view) {
  return view.getComponents().map(function(co) {
    return co.component;
  });
}
function distance6(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSpline(points2, z) {
  if (points2.length <= 2) {
    return getLinePath2(points2, false);
  }
  var first = points2[0];
  var arr = [];
  each_default(points2, function(point2) {
    arr.push(point2.x);
    arr.push(point2.y);
  });
  var path = catmullRom2bezier(arr, z, null);
  path.unshift(["M", first.x, first.y]);
  return path;
}
function isInBox(box2, point2) {
  return box2.x <= point2.x && box2.maxX >= point2.x && box2.y <= point2.y && box2.maxY > point2.y;
}
function getSilbings(view) {
  var parent2 = view.parent;
  var siblings = null;
  if (parent2) {
    siblings = parent2.views.filter(function(sub4) {
      return sub4 !== view;
    });
  }
  return siblings;
}
function point2Normalize(view, point2) {
  var coord2 = view.getCoordinate();
  return coord2.invert(point2);
}
function getSiblingPoint(view, sibling, point2) {
  var normalPoint = point2Normalize(view, point2);
  return sibling.getCoordinate().convert(normalPoint);
}
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  each_default(records, function(r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
function getScaleByField(view, field6) {
  var scale8 = view.getScaleByField(field6);
  if (!scale8 && view.views) {
    each_default(view.views, function(subView) {
      scale8 = getScaleByField(subView, field6);
      if (scale8) {
        return false;
      }
    });
  }
  return scale8;
}

// node_modules/@antv/g2/esm/interaction/context.js
var Context = (
  /** @class */
  function() {
    function Context2(view) {
      this.actions = [];
      this.event = null;
      this.cacheMap = {};
      this.view = view;
    }
    Context2.prototype.cache = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 1) {
        return this.cacheMap[params[0]];
      } else if (params.length === 2) {
        this.cacheMap[params[0]] = params[1];
      }
    };
    Context2.prototype.getAction = function(name) {
      return this.actions.find(function(action) {
        return action.name === name;
      });
    };
    Context2.prototype.addAction = function(action) {
      this.actions.push(action);
    };
    Context2.prototype.removeAction = function(action) {
      var actions = this.actions;
      var index = this.actions.indexOf(action);
      if (index >= 0) {
        actions.splice(index, 1);
      }
    };
    Context2.prototype.getCurrentPoint = function() {
      var event = this.event;
      if (event) {
        if (event.target instanceof HTMLElement) {
          var canvas = this.view.getCanvas();
          var point2 = canvas.getPointByClient(event.clientX, event.clientY);
          return point2;
        } else {
          return {
            x: event.x,
            y: event.y
          };
        }
      }
      return null;
    };
    Context2.prototype.getCurrentShape = function() {
      return get_default(this.event, ["gEvent", "shape"]);
    };
    Context2.prototype.isInPlot = function() {
      var point2 = this.getCurrentPoint();
      if (point2) {
        return this.view.isPointInPlot(point2);
      }
      return false;
    };
    Context2.prototype.isInShape = function(name) {
      var shape = this.getCurrentShape();
      if (shape) {
        return shape.get("name") === name;
      }
      return false;
    };
    Context2.prototype.isInComponent = function(name) {
      var components = getComponents(this.view);
      var point2 = this.getCurrentPoint();
      if (point2) {
        return !!components.find(function(component2) {
          var bbox = component2.getBBox();
          if (name) {
            return component2.get("name") === name && isInBox(bbox, point2);
          } else {
            return isInBox(bbox, point2);
          }
        });
      }
      return false;
    };
    Context2.prototype.destroy = function() {
      each_default(this.actions.slice(), function(action) {
        action.destroy();
      });
      this.view = null;
      this.event = null;
      this.actions = null;
      this.cacheMap = null;
    };
    return Context2;
  }()
);
var context_default = Context;

// node_modules/@antv/g2/esm/interaction/interaction.js
var Interaction = (
  /** @class */
  function() {
    function Interaction2(view, cfg) {
      this.view = view;
      this.cfg = cfg;
    }
    Interaction2.prototype.init = function() {
      this.initEvents();
    };
    Interaction2.prototype.initEvents = function() {
    };
    Interaction2.prototype.clearEvents = function() {
    };
    Interaction2.prototype.destroy = function() {
      this.clearEvents();
    };
    return Interaction2;
  }()
);
var interaction_default = Interaction;

// node_modules/@antv/g2/esm/interaction/grammar-interaction.js
function parseAction(actionStr, context, arg) {
  var arr = actionStr.split(":");
  var actionName = arr[0];
  var action = context.getAction(actionName) || createAction(actionName, context);
  if (!action) {
    throw new Error("There is no action named ".concat(actionName));
  }
  var methodName = arr[1];
  return {
    action,
    methodName,
    arg
  };
}
function executeAction(actionObject) {
  var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
  if (action[methodName]) {
    action[methodName](arg);
  } else {
    throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
  }
}
var STEP_NAMES = {
  START: "start",
  SHOW_ENABLE: "showEnable",
  END: "end",
  ROLLBACK: "rollback",
  PROCESSING: "processing"
};
var GrammarInteraction = (
  /** @class */
  function(_super) {
    __extends(GrammarInteraction2, _super);
    function GrammarInteraction2(view, steps) {
      var _this = _super.call(this, view, steps) || this;
      _this.callbackCaches = {};
      _this.emitCaches = {};
      _this.steps = steps;
      return _this;
    }
    GrammarInteraction2.prototype.init = function() {
      this.initContext();
      _super.prototype.init.call(this);
    };
    GrammarInteraction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.steps = null;
      if (this.context) {
        this.context.destroy();
        this.context = null;
      }
      this.callbackCaches = null;
      this.view = null;
    };
    GrammarInteraction2.prototype.initEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.bindEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.clearEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.offEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.initContext = function() {
      var view = this.view;
      var context = new context_default(view);
      this.context = context;
      var steps = this.steps;
      each_default(steps, function(subSteps) {
        each_default(subSteps, function(step) {
          if (is_function_default(step.action)) {
            step.actionObject = {
              action: createCallbackAction(step.action, context),
              methodName: "execute"
            };
          } else if (is_string_default(step.action)) {
            step.actionObject = parseAction(step.action, context, step.arg);
          } else if (is_array_default(step.action)) {
            var actionArr = step.action;
            var argArr_1 = is_array_default(step.arg) ? step.arg : [step.arg];
            step.actionObject = [];
            each_default(actionArr, function(actionStr, idx) {
              step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
            });
          }
        });
      });
    };
    GrammarInteraction2.prototype.isAllowStep = function(stepName) {
      var currentStepName = this.currentStepName;
      var steps = this.steps;
      if (currentStepName === stepName) {
        return true;
      }
      if (stepName === STEP_NAMES.SHOW_ENABLE) {
        return true;
      }
      if (stepName === STEP_NAMES.PROCESSING) {
        return currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.START) {
        return currentStepName !== STEP_NAMES.PROCESSING;
      }
      if (stepName === STEP_NAMES.END) {
        return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.ROLLBACK) {
        if (steps[STEP_NAMES.END]) {
          return currentStepName === STEP_NAMES.END;
        } else if (currentStepName === STEP_NAMES.START) {
          return true;
        }
      }
      return false;
    };
    GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
      if (this.isAllowStep(stepName)) {
        var key = this.getKey(stepName, step);
        if (step.once && this.emitCaches[key]) {
          return false;
        }
        if (step.isEnable) {
          return step.isEnable(this.context);
        }
        return true;
      }
      return false;
    };
    GrammarInteraction2.prototype.enterStep = function(stepName) {
      this.currentStepName = stepName;
      this.emitCaches = {};
    };
    GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
      if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
        this.enterStep(stepName);
      }
      var key = this.getKey(stepName, step);
      this.emitCaches[key] = true;
    };
    GrammarInteraction2.prototype.getKey = function(stepName, step) {
      return stepName + step.trigger + step.action;
    };
    GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
      var _this = this;
      var context = this.context;
      var callbackCaches = this.callbackCaches;
      var actionObject = step.actionObject;
      if (step.action && actionObject) {
        var key = this.getKey(stepName, step);
        if (!callbackCaches[key]) {
          var actionCallback = function(event) {
            context.event = event;
            if (_this.isAllowExecute(stepName, step)) {
              if (is_array_default(actionObject)) {
                each_default(actionObject, function(obj) {
                  context.event = event;
                  executeAction(obj);
                });
              } else {
                context.event = event;
                executeAction(actionObject);
              }
              _this.afterExecute(stepName, step);
              if (step.callback) {
                context.event = event;
                step.callback(context);
              }
            } else {
              context.event = null;
            }
          };
          if (step.debounce) {
            callbackCaches[key] = debounce_default(actionCallback, step.debounce.wait, step.debounce.immediate);
          } else if (step.throttle) {
            callbackCaches[key] = throttle_default(actionCallback, step.throttle.wait, {
              leading: step.throttle.leading,
              trailing: step.throttle.trailing
            });
          } else {
            callbackCaches[key] = actionCallback;
          }
        }
        return callbackCaches[key];
      }
      return null;
    };
    GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.addEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.addEventListener(nameArr[1], callback);
      } else {
        this.view.on(eventName, callback);
      }
    };
    GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.removeEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.removeEventListener(nameArr[1], callback);
      } else {
        this.view.off(eventName, callback);
      }
    };
    return GrammarInteraction2;
  }(interaction_default)
);
var grammar_interaction_default = GrammarInteraction;

// node_modules/@antv/g2/esm/interaction/index.js
var Interactions = {};
function getInteraction(name) {
  return Interactions[lower_case_default(name)];
}
function registerInteraction(name, interaction10) {
  Interactions[lower_case_default(name)] = interaction10;
}
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if (is_plain_object_default(interaciton)) {
    var steps = mix(clone_default(interaciton), cfg);
    return new grammar_interaction_default(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}

// node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: "center",
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: "middle",
        fontFamily: styleSheet.fontFamily
      },
      iconStyle: {
        fill: styleSheet.axisDescriptionIconFillColor
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: { type: "equidistance", cfg: { minGap: 6 } },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: "line",
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: "circle",
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: "start",
        textBaseline: "middle"
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8"
        }
      },
      inactive: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
    // 
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a6;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: "round",
        lineJoin: "round"
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: "auto",
    fontFamily: styleSheet.fontFamily,
    // Theme
    /** geometrygeometrynull */
    columnWidthRatio: 1 / 2,
    /**  */
    maxColumnWidth: null,
    /**  */
    minColumnWidth: null,
    /**  */
    roseWidthRatio: 0.9999999,
    /** / */
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: [
        "hollow-circle",
        "hollow-square",
        "hollow-bowtie",
        "hollow-diamond",
        "hollow-hexagon",
        "hollow-triangle",
        "hollow-triangle-down",
        "circle",
        "square",
        "bowtie",
        "diamond",
        "hexagon",
        "triangle",
        "triangle-down",
        "cross",
        "tick",
        "plus",
        "hyphen",
        "line"
      ],
      line: ["line", "dash", "dot", "smooth"],
      area: ["area", "smooth", "line", "smooth-line"],
      interval: ["rect", "hollow-rect", "line", "tick"]
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function(element) {
              var coordinate11 = element.geometry.coordinate;
              if (coordinate11.isPolar && coordinate11.isTransposed) {
                var _a7 = getAngle2(element.getModel(), coordinate11), startAngle = _a7.startAngle, endAngle = _a7.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: ext_exports.transform(null, [["t", x, y]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        "hollow-rect": {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
          },
          active: {
            style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
          },
          inactive: {
            style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
          },
          selected: {
            style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
          }
        },
        dash: {
          default: {
            style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
          },
          active: {
            style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
          },
          inactive: {
            style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
          },
          selected: {
            style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "triangle-down": {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "hollow-circle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-square": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-bowtie": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-diamond": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-hexagon": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle-down": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "smooth-line": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "hollow-smooth": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: "top",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: "bottom",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: "left",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: "right",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: deep_mix_default({}, axisStyles.grid, { line: { type: "line" } })
        },
        radius: {
          title: null,
          grid: deep_mix_default({}, axisStyles.grid, { line: { type: "circle" } })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: "color",
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: "rail",
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: "middle",
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: "auto",
        marker: {
          symbol: "circle",
          stroke: "#fff",
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: "rgba(0,0,0,0.09)",
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: "rgba(0, 0, 0, 0.25)",
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        // tooltip dom 
        domStyles: (_a6 = {}, _a6["".concat(css_const_exports2.CONTAINER_CLASS)] = {
          position: "absolute",
          visibility: "hidden",
          zIndex: 8,
          transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
          color: styleSheet.tooltipTextFillColor,
          fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
          fontFamily: styleSheet.fontFamily,
          lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
          padding: "0 12px 0 12px"
        }, _a6["".concat(css_const_exports2.TITLE_CLASS)] = {
          marginBottom: "12px",
          marginTop: "12px"
        }, _a6["".concat(css_const_exports2.LIST_CLASS)] = {
          margin: 0,
          listStyleType: "none",
          padding: 0
        }, _a6["".concat(css_const_exports2.LIST_ITEM_CLASS)] = {
          listStyleType: "none",
          padding: 0,
          marginBottom: "12px",
          marginTop: "12px",
          marginLeft: 0,
          marginRight: 0
        }, _a6["".concat(css_const_exports2.MARKER_CLASS)] = {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          display: "inline-block",
          marginRight: "8px"
        }, _a6["".concat(css_const_exports2.VALUE_CLASS)] = {
          display: "inline-block",
          float: "right",
          marginLeft: "30px"
        }, _a6)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: "start",
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: "start",
              fontFamily: styleSheet.fontFamily,
              textBaseline: "bottom"
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: "middle",
            textAlign: "start",
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: "start",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: "upward",
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: "center",
              textBaseline: "bottom",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            // 
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}

// node_modules/@antv/g2/esm/theme/style-sheet/light.js
var BLACK_COLORS = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var WHITE_COLORS = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#6F5EF9",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#6F5EF9",
  "#D3CEFD",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createLightStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a6 = cfg.paletteQualitative10, paletteQualitative10 = _a6 === void 0 ? QUALITATIVE_10 : _a6, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    /**  */
    backgroundColor: "transparent",
    /**  */
    brandColor,
    /**  */
    subColor: "rgba(0,0,0,0.05)",
    /**  1 10  */
    paletteQualitative10,
    /**  2 10  */
    paletteQualitative20,
    /**  */
    paletteSemanticRed: "#F4664A",
    /**  */
    paletteSemanticGreen: "#30BF78",
    /**  */
    paletteSemanticYellow: "#FAAD14",
    /** () */
    paletteSequence: SINGLE_SEQUENCE,
    /**  */
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    // --------------------  --------------------
    /**  */
    axisLineBorderColor: BLACK_COLORS[25],
    /**  */
    axisLineBorder: 1,
    /**  lineDash  */
    axisLineDash: null,
    /**  */
    axisTitleTextFillColor: BLACK_COLORS[65],
    /**  */
    axisTitleTextFontSize: 12,
    /**  */
    axisTitleTextLineHeight: 12,
    /**  */
    axisTitleTextFontWeight: "normal",
    /**  */
    axisTitleSpacing: 12,
    /** icon */
    axisDescriptionIconFillColor: WHITE_COLORS[85],
    /**  */
    axisTickLineBorderColor: BLACK_COLORS[25],
    /**  */
    axisTickLineLength: 4,
    /**  */
    axisTickLineBorder: 1,
    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS[15],
    /**  */
    axisSubTickLineLength: 2,
    /**  */
    axisSubTickLineBorder: 1,
    /**  */
    axisLabelFillColor: BLACK_COLORS[45],
    /**  */
    axisLabelFontSize: 12,
    /**  */
    axisLabelLineHeight: 12,
    /**  */
    axisLabelFontWeight: "normal",
    /**  */
    axisLabelOffset: 8,
    /**  */
    axisGridBorderColor: BLACK_COLORS[15],
    /**  */
    axisGridBorder: 1,
    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------
    /**  */
    legendTitleTextFillColor: BLACK_COLORS[45],
    /**  */
    legendTitleTextFontSize: 12,
    /**  */
    legendTitleTextLineHeight: 21,
    /**  */
    legendTitleTextFontWeight: "normal",
    /**  marker  */
    legendMarkerColor: brandColor,
    /**  marker  */
    legendMarkerSpacing: 8,
    /**  marker  */
    legendMarkerSize: 4,
    /**  'circle' marker  */
    legendCircleMarkerSize: 4,
    /**  'square' marker  */
    legendSquareMarkerSize: 4,
    /**  'line' marker  */
    legendLineMarkerSize: 5,
    /**  */
    legendItemNameFillColor: BLACK_COLORS[65],
    /**  */
    legendItemNameFontSize: 12,
    /**  */
    legendItemNameLineHeight: 12,
    /**  */
    legendItemNameFontWeight: "normal",
    /**  */
    legendItemSpacing: 24,
    /**  */
    legendItemMarginBottom: 12,
    /**   */
    legendPadding: [8, 8, 8, 8],
    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],
    /**  */
    legendVerticalPadding: [0, 8, 0, 8],
    // 
    /**  marker  */
    legendPageNavigatorMarkerSize: 12,
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    /**  marker  */
    legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
    /**  marker  */
    legendPageNavigatorMarkerFillOpacity: 1,
    /**  */
    legendPageNavigatorTextFillColor: BLACK_COLORS[45],
    /**  */
    legendPageNavigatorTextFontSize: 12,
    /**  */
    sliderRailFillColor: BLACK_COLORS[15],
    /**  */
    sliderRailBorder: 0,
    /**  */
    sliderRailBorderColor: null,
    /**  */
    sliderRailWidth: 100,
    /**  */
    sliderRailHeight: 12,
    /**  */
    sliderLabelTextFillColor: BLACK_COLORS[45],
    /**  */
    sliderLabelTextFontSize: 12,
    /**  */
    sliderLabelTextLineHeight: 12,
    /**  */
    sliderLabelTextFontWeight: "normal",
    /**  */
    sliderHandlerFillColor: BLACK_COLORS[6],
    /**  */
    sliderHandlerWidth: 10,
    /**  */
    sliderHandlerHeight: 14,
    /**  */
    sliderHandlerBorder: 1,
    /**  */
    sliderHandlerBorderColor: BLACK_COLORS[25],
    // -------------------- Annotation --------------------
    /** arc  */
    annotationArcBorderColor: BLACK_COLORS[15],
    /** arc  */
    annotationArcBorder: 1,
    /** line  */
    annotationLineBorderColor: BLACK_COLORS[25],
    /** line  */
    annotationLineBorder: 1,
    /** lube  */
    annotationLineDash: null,
    /** text  */
    annotationTextFillColor: BLACK_COLORS[65],
    /** text  */
    annotationTextFontSize: 12,
    /** text  */
    annotationTextLineHeight: 12,
    /** text  */
    annotationTextFontWeight: "normal",
    /** text  */
    annotationTextBorderColor: null,
    /** text  */
    annotationTextBorder: 0,
    /** region  */
    annotationRegionFillColor: BLACK_COLORS[100],
    /** region  */
    annotationRegionFillOpacity: 0.06,
    /** region  */
    annotationRegionBorder: 0,
    /** region  */
    annotationRegionBorderColor: null,
    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------
    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],
    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,
    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,
    /** tooltip  */
    tooltipContainerFillColor: "rgb(255, 255, 255)",
    tooltipContainerFillOpacity: 0.95,
    /** tooltip  */
    tooltipContainerShadow: "0px 0px 10px #aeaeae",
    /** tooltip  */
    tooltipContainerBorderRadius: 3,
    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS[65],
    /** tooltip  */
    tooltipTextFontSize: 12,
    /** tooltip  */
    tooltipTextLineHeight: 12,
    /** tooltip  */
    tooltipTextFontWeight: "bold",
    // -------------------- Geometry labels --------------------
    /** Geometry label  */
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    /** Geometry label  */
    labelFontSize: 12,
    /** Geometry label  */
    labelLineHeight: 12,
    /** Geometry label  */
    labelFontWeight: "normal",
    /** Geometry label  */
    labelBorderColor: null,
    /** Geometry label  */
    labelBorder: 0,
    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS[100],
    /** Geometry innerLabel  */
    innerLabelFontSize: 12,
    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,
    /** Geometry innerLabel  */
    innerLabelFontWeight: "normal",
    /** Geometry innerLabel  */
    innerLabelBorderColor: null,
    /** Geometry innerLabel  */
    innerLabelBorder: 0,
    /** Geometry overflowLabel  */
    overflowLabelFillColor: BLACK_COLORS[65],
    /** Geometry overflowLabel  */
    overflowLabelFontSize: 12,
    /** Geometry overflowLabel  */
    overflowLabelLineHeight: 12,
    /** Geometry overflowLabel  */
    overflowLabelFontWeight: "normal",
    /** Geometry overflowLabel  */
    overflowLabelBorderColor: WHITE_COLORS[100],
    /** Geometry overflowLabel  */
    overflowLabelBorder: 1,
    /** Geometry label  */
    labelLineBorder: 1,
    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS[25],
    // -------------------- Slider --------------------
    /** slider  */
    cSliderRailHieght: 16,
    /** slider  */
    cSliderBackgroundFillColor: "#416180",
    /** slider  */
    cSliderBackgroundFillOpacity: 0.05,
    /** slider  */
    cSliderForegroundFillColor: "#5B8FF9",
    /** slider  */
    cSliderForegroundFillOpacity: 0.15,
    // slider handlerStyle 
    /** slider  */
    cSliderHandlerHeight: 24,
    /** Slider  */
    cSliderHandlerWidth: 10,
    /** Slider  */
    cSliderHandlerFillColor: "#F7F7F7",
    /** Slider  */
    cSliderHandlerFillOpacity: 1,
    /** Slider  */
    cSliderHandlerHighlightFillColor: "#FFF",
    /** Slider  */
    cSliderHandlerBorderColor: "#BFBFBF",
    /** Slider  */
    cSliderHandlerBorder: 1,
    /** Slider  */
    cSliderHandlerBorderRadius: 2,
    // slider textStyle 
    /** Slider  */
    cSliderTextFillColor: "#000",
    /** Slider  */
    cSliderTextFillOpacity: 0.45,
    /** Slider  */
    cSliderTextFontSize: 12,
    /** Slider  */
    cSliderTextLineHeight: 12,
    /** Slider  */
    cSliderTextFontWeight: "normal",
    /** Slider  */
    cSliderTextBorderColor: null,
    /** Slider  */
    cSliderTextBorder: 0,
    // -------------------- Scrollbar --------------------
    /**   */
    scrollbarTrackFillColor: "rgba(0,0,0,0)",
    /**   */
    scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
    /**   */
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
    // -------------------- Geometry --------------------
    /**  */
    pointFillColor: brandColor,
    /**  */
    pointFillOpacity: 0.95,
    /**  */
    pointSize: 4,
    /**  */
    pointBorder: 1,
    /**  */
    pointBorderColor: WHITE_COLORS[100],
    /**  */
    pointBorderOpacity: 1,
    /**  active  */
    pointActiveBorderColor: BLACK_COLORS[100],
    /**  selected  */
    pointSelectedBorder: 2,
    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS[100],
    /**  inactive  */
    pointInactiveFillOpacity: 0.3,
    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,
    /**  */
    hollowPointSize: 4,
    /**  */
    hollowPointBorder: 1,
    /**  */
    hollowPointBorderColor: brandColor,
    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
    /**  active  */
    hollowPointActiveBorder: 1,
    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS[100],
    /**  active  */
    hollowPointActiveBorderOpacity: 1,
    /**  selected  */
    hollowPointSelectedBorder: 2,
    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS[100],
    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,
    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,
    /**  */
    lineBorder: 2,
    /**  */
    lineBorderColor: brandColor,
    /**  */
    lineBorderOpacity: 1,
    /**  Active  */
    lineActiveBorder: 3,
    /**  selected  */
    lineSelectedBorder: 3,
    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,
    /** area  */
    areaFillColor: brandColor,
    /** area  */
    areaFillOpacity: 0.25,
    /** area  active  */
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
    /** area  selected  */
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
    /** area inactive  */
    areaInactiveFillOpacity: 0.3,
    /** hollowArea  */
    hollowAreaBorderColor: brandColor,
    /** hollowArea  */
    hollowAreaBorder: 2,
    /** hollowArea  */
    hollowAreaBorderOpacity: 1,
    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,
    /** interval  */
    intervalFillColor: brandColor,
    /** interval  */
    intervalFillOpacity: 0.95,
    /** interval active  */
    intervalActiveBorder: 1,
    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
    /** interval selected  */
    intervalSelectedBorder: 2,
    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS[100],
    /** interval selected  */
    intervalSelectedBorderOpacity: 1,
    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,
    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,
    /** interval  */
    hollowIntervalBorder: 2,
    /** hollowInterval  */
    hollowIntervalBorderColor: brandColor,
    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,
    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,
    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign(__assign({}, token2), cfg);
};
var antvLight = createLightStyleSheet();

// node_modules/@antv/g2/esm/theme/util/create-theme.js
function createTheme(themeCfg) {
  var _a6 = themeCfg.styleSheet, styleSheetCfg = _a6 === void 0 ? {} : _a6, themeObject = __rest(themeCfg, ["styleSheet"]);
  var styleSheet = createLightStyleSheet(styleSheetCfg);
  return deep_mix_default({}, createThemeByStyleSheet(styleSheet), themeObject);
}

// node_modules/@antv/g2/esm/theme/index.js
var defaultTheme = createTheme({});
var Themes = {
  default: defaultTheme
};
function getTheme(theme4) {
  return get_default(Themes, lower_case_default(theme4), Themes.default);
}
function registerTheme(theme4, value2) {
  Themes[lower_case_default(theme4)] = createTheme(value2);
}

// node_modules/@antv/g2/esm/util/tooltip.js
function snapEqual(v1, v2, scale8) {
  var value1 = scale8.translate(v1);
  var value2 = scale8.translate(v2);
  return isNumberEqual(value1, value2);
}
function getXValueByPoint(point2, geometry35) {
  var coordinate11 = geometry35.coordinate;
  var xScale = geometry35.getXScale();
  var range2 = xScale.range;
  var rangeMax = range2[range2.length - 1];
  var rangeMin = range2[0];
  var invertPoint = coordinate11.invert(point2);
  var xValue = invertPoint.x;
  if (coordinate11.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin;
  }
  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data3, point2, geometry35) {
  var coordinate11 = geometry35.coordinate;
  var yScale = geometry35.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate11.invert(point2);
  var yValue = yScale.invert(invertPoint.y);
  var result2 = find_default(data3, function(obj) {
    var originData = obj[FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result2 || data3[data3.length - 1];
}
var getXDistance = memoize_default(function(scale8) {
  if (scale8.isCategory) {
    return 1;
  }
  var scaleValues = scale8.values;
  var length5 = scaleValues.length;
  var min5 = scale8.translate(scaleValues[0]);
  var max5 = min5;
  for (var index = 0; index < length5; index++) {
    var value2 = scaleValues[index];
    var numericValue = scale8.translate(value2);
    if (numericValue < min5) {
      min5 = numericValue;
    }
    if (numericValue > max5) {
      max5 = numericValue;
    }
  }
  return (max5 - min5) / (length5 - 1);
});
function getTooltipTitle(originData, geometry35, title) {
  var positionAttr = geometry35.getAttribute("position");
  var fields = positionAttr.getFields();
  var scales = geometry35.scales;
  var titleField = is_function_default(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return is_function_default(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry35) {
  var attributes = values_default(geometry35.attributes);
  return filter_default(attributes, function(attribute) {
    return contains_default(GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry35) {
  var e_1, _a6;
  var attributes = getAttributesForLegend(geometry35);
  var scale8;
  try {
    for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
      var attribute = attributes_1_1.value;
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        var tmpScaleDef = get_default(geometry35.scaleDefs, tmpScale.field);
        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry35.type);
        if (inferedScaleType !== "cat") {
          scale8 = tmpScale;
          break;
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (attributes_1_1 && !attributes_1_1.done && (_a6 = attributes_1.return))
        _a6.call(attributes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var xScale = geometry35.getXScale();
  var yScale = geometry35.getYScale();
  return scale8 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field6 = valueScale.field;
  var value2 = originData[field6];
  if (is_array_default(value2)) {
    var texts = value2.map(function(eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join("-");
  }
  return valueScale.getText(value2);
}
function getTooltipName(originData, geometry35) {
  var nameScale;
  var groupScales = geometry35.getGroupScales();
  if (groupScales.length) {
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field6 = nameScale.field;
    return nameScale.getText(originData[field6]);
  }
  var valueScale = getTooltipValueScale(geometry35);
  return getName(valueScale);
}
function findDataByPoint(point2, data3, geometry35) {
  if (data3.length === 0) {
    return null;
  }
  var geometryType = geometry35.type;
  var xScale = geometry35.getXScale();
  var yScale = geometry35.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  if (geometryType === "heatmap" || geometryType === "point") {
    var coordinate11 = geometry35.coordinate;
    var invertPoint = coordinate11.invert(point2);
    var x = xScale.invert(invertPoint.x);
    var y = yScale.invert(invertPoint.y);
    var min5 = Infinity;
    for (var index = 0; index < data3.length; index++) {
      var obj = data3[index];
      var originData = obj[FIELD_ORIGIN];
      var range2 = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
      if (range2 < min5) {
        min5 = range2;
        rst = obj;
      }
    }
    return rst;
  }
  var first = data3[0];
  var last3 = data3[data3.length - 1];
  var xValue = getXValueByPoint(point2, geometry35);
  var firstXValue = first[FIELD_ORIGIN][xField];
  var firstYValue = first[FIELD_ORIGIN][yField];
  var lastXValue = last3[FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && is_array_default(firstYValue);
  if (is_array_default(firstXValue)) {
    for (var index = 0; index < data3.length; index++) {
      var record = data3[index];
      var originData = record[FIELD_ORIGIN];
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          if (!is_array_default(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if (is_array_default(rst)) {
      rst = filterYValue(rst, point2, geometry35);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== "timeCat") {
      for (var index = 0; index < data3.length; index++) {
        var record = data3[index];
        var originData = record[FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!is_array_default(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last3 = record;
          next = data3[index + 1];
        }
      }
      if (is_array_default(rst)) {
        rst = filterYValue(rst, point2, geometry35);
      }
    } else {
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data3.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data3[middleIdx][FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data3[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last3 = data3[middleIdx];
          next = data3[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last3 = data3[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last3 && next) {
      if (Math.abs(xScale.translate(last3[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
        last3 = next;
      }
    }
  }
  var distance9 = getXDistance(geometry35.getXScale());
  if (!rst && Math.abs(xScale.translate(last3[FIELD_ORIGIN][xField]) - xValue) <= distance9 / 2) {
    rst = last3;
  }
  return rst;
}
function getTooltipItems(data3, geometry35, title, showNil) {
  var e_2, _a6;
  if (title === void 0) {
    title = "";
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data3[FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry35, title);
  var tooltipOption = geometry35.tooltipOption;
  var defaultColor = geometry35.theme.defaultColor;
  var items = [];
  var name;
  var value2;
  function addItem(itemName, itemValue) {
    if (showNil || !is_nil_default(itemValue) && itemValue !== "") {
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data3,
        name: itemName,
        value: itemValue,
        color: data3.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if (is_object_default(tooltipOption)) {
    var fields = tooltipOption.fields, callback = tooltipOption.callback;
    if (callback) {
      var callbackParams = fields.map(function(field7) {
        return data3[FIELD_ORIGIN][field7];
      });
      var cfg = callback.apply(void 0, __spreadArray([], __read(callbackParams), false));
      var itemCfg = __assign({ data: data3[FIELD_ORIGIN], mappingData: data3, title: tooltipTitle, color: data3.color || defaultColor, marker: true }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry35.scales;
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field6 = fields_1_1.value;
          if (!is_nil_default(originData[field6])) {
            var scale8 = scales[field6];
            name = getName(scale8);
            value2 = scale8.getText(originData[field6]);
            addItem(name, value2);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a6 = fields_1.return))
            _a6.call(fields_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry35);
    value2 = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry35);
    addItem(name, value2);
  }
  return items;
}
function getTooltipItemsByFindData(geometry35, point2, title, tooltipCfg) {
  var e_3, _a6;
  var showNil = tooltipCfg.showNil;
  var result2 = [];
  var dataArray = geometry35.dataArray;
  if (!is_empty_default(dataArray)) {
    geometry35.sort(dataArray);
    try {
      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
        var data3 = dataArray_1_1.value;
        var record = findDataByPoint(point2, data3, geometry35);
        if (record) {
          var elementId = geometry35.getElementId(record);
          var element = geometry35.elementsMap[elementId];
          if (geometry35.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry35, title, showNil);
            if (items.length) {
              result2.push(items);
            }
          }
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (dataArray_1_1 && !dataArray_1_1.done && (_a6 = dataArray_1.return))
          _a6.call(dataArray_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  }
  return result2;
}
function getTooltipItemsByHitShape(geometry35, point2, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result2 = [];
  var container = geometry35.container;
  var shape = container.getShape(point2.x, point2.y);
  if (shape && shape.get("visible") && shape.get("origin")) {
    var mappingData = shape.get("origin").mappingData;
    var items = getTooltipItems(mappingData, geometry35, title, showNil);
    if (items.length) {
      result2.push(items);
    }
  }
  return result2;
}
function findItemsFromView(view, point2, tooltipCfg) {
  var e_4, _a6;
  var result2 = [];
  var geometries = view.geometries;
  var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
  try {
    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
      var geometry35 = geometries_1_1.value;
      if (geometry35.visible && geometry35.tooltipOption !== false) {
        var geometryType = geometry35.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry35, point2, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry35, point2, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry35, point2, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry35, point2, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result2.push(tooltipItems);
        }
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (geometries_1_1 && !geometries_1_1.done && (_a6 = geometries_1.return))
        _a6.call(geometries_1);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return result2;
}
function findItemsFromViewRecurisive(view, point2, tooltipCfg) {
  var e_5, _a6;
  var result2 = findItemsFromView(view, point2, tooltipCfg);
  try {
    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
      var childView = _c.value;
      result2 = result2.concat(findItemsFromView(childView, point2, tooltipCfg));
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a6 = _b.return))
        _a6.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return result2;
}

// node_modules/@antv/g2/esm/util/padding.js
function isAutoPadding(padding3) {
  return !is_number_default(padding3) && !is_array_default(padding3);
}
function parsePadding(padding3) {
  if (padding3 === void 0) {
    padding3 = 0;
  }
  var paddingArray = is_array_default(padding3) ? padding3 : [padding3];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), __read(paddingArray), false);
      break;
    case 3:
      paddingArray = __spreadArray(__spreadArray([], __read(paddingArray), false), [paddingArray[1]], false);
      break;
    default:
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}

// node_modules/@antv/g2/esm/chart/controller/index.js
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}

// node_modules/@antv/g2/esm/chart/controller/coordinate.js
var CoordinateController = (
  /** @class */
  function() {
    function CoordinateController2(option) {
      this.option = this.wrapperOption(option);
    }
    CoordinateController2.prototype.update = function(option) {
      this.option = this.wrapperOption(option);
      return this;
    };
    CoordinateController2.prototype.hasAction = function(actionName) {
      var actions = this.option.actions;
      return some_default(actions, function(action) {
        return action[0] === actionName;
      });
    };
    CoordinateController2.prototype.create = function(start, end) {
      var _a6 = this.option, type = _a6.type, cfg = _a6.cfg;
      var isTheta = type === "theta";
      var props = __assign({ start, end }, cfg);
      var C2 = getCoordinate(isTheta ? "polar" : type);
      this.coordinate = new C2(props);
      this.coordinate.type = type;
      if (isTheta) {
        if (!this.hasAction("transpose")) {
          this.transpose();
        }
      }
      this.execActions();
      return this.coordinate;
    };
    CoordinateController2.prototype.adjust = function(start, end) {
      this.coordinate.update({
        start,
        end
      });
      this.coordinate.resetMatrix();
      this.execActions(["scale", "rotate", "translate"]);
      return this.coordinate;
    };
    CoordinateController2.prototype.rotate = function(angle4) {
      this.option.actions.push(["rotate", angle4]);
      return this;
    };
    CoordinateController2.prototype.reflect = function(dim) {
      this.option.actions.push(["reflect", dim]);
      return this;
    };
    CoordinateController2.prototype.scale = function(sx, sy) {
      this.option.actions.push(["scale", sx, sy]);
      return this;
    };
    CoordinateController2.prototype.transpose = function() {
      this.option.actions.push(["transpose"]);
      return this;
    };
    CoordinateController2.prototype.getOption = function() {
      return this.option;
    };
    CoordinateController2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    CoordinateController2.prototype.wrapperOption = function(option) {
      return __assign({ type: "rect", actions: [], cfg: {} }, option);
    };
    CoordinateController2.prototype.execActions = function(includeActions) {
      var _this = this;
      var actions = this.option.actions;
      each_default(actions, function(action) {
        var _a6;
        var _b = __read(action), actionName = _b[0], args = _b.slice(1);
        var shouldExec = is_nil_default(includeActions) ? true : includeActions.includes(actionName);
        if (shouldExec) {
          (_a6 = _this.coordinate)[actionName].apply(_a6, __spreadArray([], __read(args), false));
        }
      });
    };
    return CoordinateController2;
  }()
);
var coordinate_default = CoordinateController;

// node_modules/@antv/g2/esm/chart/event.js
var Event = (
  /** @class */
  function() {
    function Event2(view, gEvent, data3) {
      this.view = view;
      this.gEvent = gEvent;
      this.data = data3;
      this.type = gEvent.type;
    }
    Event2.fromData = function(view, type, data3) {
      return new Event2(view, new graph_event_default(type, {}), data3);
    };
    Object.defineProperty(Event2.prototype, "target", {
      // below props are proxy props of G.event convenient
      /** the real trigger shape of the event */
      get: function() {
        return this.gEvent.target;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "event", {
      /**  dom  */
      get: function() {
        return this.gEvent.originalEvent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "x", {
      /** x  */
      get: function() {
        return this.gEvent.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "y", {
      /** y  */
      get: function() {
        return this.gEvent.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientX", {
      /** x  */
      get: function() {
        return this.gEvent.clientX;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientY", {
      /** y  */
      get: function() {
        return this.gEvent.clientY;
      },
      enumerable: false,
      configurable: true
    });
    Event2.prototype.toString = function() {
      return "[Event (type=".concat(this.type, ")]");
    };
    Event2.prototype.clone = function() {
      return new Event2(this.view, this.gEvent, this.data);
    };
    return Event2;
  }()
);
var event_default = Event;

// node_modules/@antv/g2/esm/chart/layout/index.js
function defaultLayout(view) {
  var axis22 = view.getController("axis");
  var legend18 = view.getController("legend");
  var annotation4 = view.getController("annotation");
  var slider4 = view.getController("slider");
  var scrollbar2 = view.getController("scrollbar");
  [axis22, slider4, scrollbar2, legend18, annotation4].forEach(function(controller) {
    if (controller) {
      controller.layout();
    }
  });
}

// node_modules/@antv/g2/esm/chart/util/scale-pool.js
var ScalePool = (
  /** @class */
  function() {
    function ScalePool2() {
      this.scales = /* @__PURE__ */ new Map();
      this.syncScales = /* @__PURE__ */ new Map();
    }
    ScalePool2.prototype.createScale = function(field6, data3, scaleDef, key) {
      var finalScaleDef = scaleDef;
      var cacheScaleMeta = this.getScaleMeta(key);
      if (data3.length === 0 && cacheScaleMeta) {
        var cacheScale = cacheScaleMeta.scale;
        var cacheScaleDef = {
          type: cacheScale.type
        };
        if (cacheScale.isCategory) {
          cacheScaleDef.values = cacheScale.values;
        }
        finalScaleDef = deep_mix_default(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
      }
      var scale8 = createScaleByField(field6, data3, finalScaleDef);
      this.cacheScale(scale8, scaleDef, key);
      return scale8;
    };
    ScalePool2.prototype.sync = function(coordinate11, theme4) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var min5 = Number.MAX_SAFE_INTEGER;
        var max5 = Number.MIN_SAFE_INTEGER;
        var values3 = [];
        each_default(scaleKeys, function(key) {
          var scale8 = _this.getScale(key);
          max5 = is_number_default(scale8.max) ? Math.max(max5, scale8.max) : max5;
          min5 = is_number_default(scale8.min) ? Math.min(min5, scale8.min) : min5;
          each_default(scale8.values, function(v) {
            if (!values3.includes(v)) {
              values3.push(v);
            }
          });
        });
        each_default(scaleKeys, function(key) {
          var scale8 = _this.getScale(key);
          if (scale8.isContinuous) {
            scale8.change({
              min: min5,
              max: max5,
              values: values3
            });
          } else if (scale8.isCategory) {
            var range2 = scale8.range;
            var cacheScaleMeta = _this.getScaleMeta(key);
            if (values3 && !get_default(cacheScaleMeta, ["scaleDef", "range"])) {
              range2 = getDefaultCategoryScaleRange(deep_mix_default({}, scale8, {
                values: values3
              }), coordinate11, theme4);
            }
            scale8.change({
              values: values3,
              range: range2
            });
          }
        });
      });
    };
    ScalePool2.prototype.cacheScale = function(scale8, scaleDef, key) {
      var sm = this.getScaleMeta(key);
      if (sm && sm.scale.type === scale8.type) {
        syncScale(sm.scale, scale8);
        sm.scaleDef = scaleDef;
      } else {
        sm = {
          key,
          scale: scale8,
          scaleDef
        };
        this.scales.set(key, sm);
      }
      var syncKey = this.getSyncKey(sm);
      sm.syncKey = syncKey;
      this.removeFromSyncScales(key);
      if (syncKey) {
        var scaleKeys = this.syncScales.get(syncKey);
        if (!scaleKeys) {
          scaleKeys = [];
          this.syncScales.set(syncKey, scaleKeys);
        }
        scaleKeys.push(key);
      }
    };
    ScalePool2.prototype.getScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (!scaleMeta) {
        var field6 = last(key.split("-"));
        var scaleKeys = this.syncScales.get(field6);
        if (scaleKeys && scaleKeys.length) {
          scaleMeta = this.getScaleMeta(scaleKeys[0]);
        }
      }
      return scaleMeta && scaleMeta.scale;
    };
    ScalePool2.prototype.deleteScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (scaleMeta) {
        var syncKey = scaleMeta.syncKey;
        var scaleKeys = this.syncScales.get(syncKey);
        if (scaleKeys && scaleKeys.length) {
          var idx = scaleKeys.indexOf(key);
          if (idx !== -1) {
            scaleKeys.splice(idx, 1);
          }
        }
      }
      this.scales.delete(key);
    };
    ScalePool2.prototype.clear = function() {
      this.scales.clear();
      this.syncScales.clear();
    };
    ScalePool2.prototype.removeFromSyncScales = function(key) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
          if (scaleKeys.length === 0) {
            _this.syncScales.delete(syncKey);
          }
          return false;
        }
      });
    };
    ScalePool2.prototype.getSyncKey = function(sm) {
      var scale8 = sm.scale, scaleDef = sm.scaleDef;
      var field6 = scale8.field;
      var sync = get_default(scaleDef, ["sync"]);
      return sync === true ? field6 : sync === false ? void 0 : sync;
    };
    ScalePool2.prototype.getScaleMeta = function(key) {
      return this.scales.get(key);
    };
    return ScalePool2;
  }()
);

// node_modules/@antv/g2/esm/chart/layout/padding-cal.js
var PaddingCal = (
  /** @class */
  function() {
    function PaddingCal2(top, right2, bottom, left2) {
      if (top === void 0) {
        top = 0;
      }
      if (right2 === void 0) {
        right2 = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left2 === void 0) {
        left2 = 0;
      }
      this.top = top;
      this.right = right2;
      this.bottom = bottom;
      this.left = left2;
    }
    PaddingCal2.instance = function(top, right2, bottom, left2) {
      if (top === void 0) {
        top = 0;
      }
      if (right2 === void 0) {
        right2 = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left2 === void 0) {
        left2 = 0;
      }
      return new PaddingCal2(top, right2, bottom, left2);
    };
    PaddingCal2.prototype.max = function(padding3) {
      var _a6 = __read(padding3, 4), top = _a6[0], right2 = _a6[1], bottom = _a6[2], left2 = _a6[3];
      this.top = Math.max(this.top, top);
      this.right = Math.max(this.right, right2);
      this.bottom = Math.max(this.bottom, bottom);
      this.left = Math.max(this.left, left2);
      return this;
    };
    PaddingCal2.prototype.shrink = function(padding3) {
      var _a6 = __read(padding3, 4), top = _a6[0], right2 = _a6[1], bottom = _a6[2], left2 = _a6[3];
      this.top += top;
      this.right += right2;
      this.bottom += bottom;
      this.left += left2;
      return this;
    };
    PaddingCal2.prototype.inc = function(bbox, direction2) {
      var width = bbox.width, height = bbox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          this.top += height;
          break;
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          this.right += width;
          break;
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          this.bottom += height;
          break;
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          this.left += width;
          break;
        default:
          break;
      }
      return this;
    };
    PaddingCal2.prototype.getPadding = function() {
      return [this.top, this.right, this.bottom, this.left];
    };
    PaddingCal2.prototype.clone = function() {
      return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray([void 0], __read(this.getPadding()), false)))();
    };
    return PaddingCal2;
  }()
);

// node_modules/@antv/g2/esm/chart/layout/auto.js
function calculatePadding(view) {
  var padding3 = view.padding;
  if (!isAutoPadding(padding3)) {
    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], __read(parsePadding(padding3)), false)))();
  }
  var viewBBox = view.viewBBox;
  var paddingCal = new PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  each_default(view.getComponents(), function(co) {
    var type = co.type;
    if (type === COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
      paddingComponents.push(co);
    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  });
  each_default(axisComponents, function(co) {
    var component2 = co.component;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox);
    paddingCal.max(exceed);
  });
  each_default(paddingComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentPadding = component2.get("padding");
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
    paddingCal.inc(componentBBox, direction2);
  });
  each_default(otherComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    paddingCal.inc(componentBBox, direction2);
  });
  return paddingCal;
}

// node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance();
  views.forEach(function(v) {
    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
  });
}

// node_modules/@antv/g2/esm/chart/view.js
var View = (
  /** @class */
  function(_super) {
    __extends(View2, _super);
    function View2(props) {
      var _this = _super.call(this, { visible: props.visible }) || this;
      _this.views = [];
      _this.geometries = [];
      _this.controllers = [];
      _this.interactions = {};
      _this.limitInPlot = false;
      _this.options = {
        data: [],
        animate: true
        // 
      };
      _this.usedControllers = getComponentControllerNames();
      _this.scalePool = new ScalePool();
      _this.layoutFunc = defaultLayout;
      _this.isPreMouseInPlot = false;
      _this.isDataChanged = false;
      _this.isCoordinateChanged = false;
      _this.createdScaleKeys = /* @__PURE__ */ new Map();
      _this.onCanvasEvent = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          var e = _this.createViewEvent(evt);
          _this.doPlotEvent(e);
          _this.emit(name, e);
        }
      };
      _this.onDelegateEvents = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          return;
        }
        var e = _this.createViewEvent(evt);
        _this.emit(name, e);
      };
      var _a6 = props.id, id = _a6 === void 0 ? unique_id_default("view") : _a6, parent2 = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding3 = props.padding, appendPadding = props.appendPadding, theme4 = props.theme, options = props.options, limitInPlot5 = props.limitInPlot, syncViewPadding2 = props.syncViewPadding;
      _this.parent = parent2;
      _this.canvas = canvas;
      _this.backgroundGroup = backgroundGroup;
      _this.middleGroup = middleGroup;
      _this.foregroundGroup = foregroundGroup;
      _this.region = region;
      _this.padding = padding3;
      _this.appendPadding = appendPadding;
      _this.options = __assign(__assign({}, _this.options), options);
      _this.limitInPlot = limitInPlot5;
      _this.id = id;
      _this.syncViewPadding = syncViewPadding2;
      _this.themeObject = is_object_default(theme4) ? deep_mix_default({}, getTheme("default"), createTheme(theme4)) : getTheme(theme4);
      _this.init();
      return _this;
    }
    View2.prototype.setLayout = function(layout2) {
      this.layoutFunc = layout2;
    };
    View2.prototype.init = function() {
      this.calculateViewBBox();
      this.initEvents();
      this.initComponentController();
      this.initOptions();
    };
    View2.prototype.render = function(isUpdate, payload) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
      this.paint(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    View2.prototype.clear = function() {
      var _this = this;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
      this.filteredData = [];
      this.coordinateInstance = void 0;
      this.isDataChanged = false;
      this.isCoordinateChanged = false;
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        geometries[i].clear();
        geometries[i].container.remove(true);
        geometries[i].labelsContainer.remove(true);
      }
      this.geometries = [];
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        if (controllers[i].name === "annotation") {
          controllers[i].clear(true);
        } else {
          controllers[i].clear();
        }
      }
      this.createdScaleKeys.forEach(function(v, k) {
        _this.getRootView().scalePool.deleteScale(k);
      });
      this.createdScaleKeys.clear();
      var views = this.views;
      for (var i = 0; i < views.length; i++) {
        views[i].clear();
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
    };
    View2.prototype.destroy = function() {
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
      var interactions = this.interactions;
      each_default(interactions, function(interaction10) {
        if (interaction10) {
          interaction10.destroy();
        }
      });
      this.clear();
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.destroy();
      }
      this.backgroundGroup.remove(true);
      this.middleGroup.remove(true);
      this.foregroundGroup.remove(true);
      _super.prototype.destroy.call(this);
    };
    View2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry35 = geometries[i];
        geometry35.changeVisible(visible);
      }
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.changeVisible(visible);
      }
      this.foregroundGroup.set("visible", visible);
      this.middleGroup.set("visible", visible);
      this.backgroundGroup.set("visible", visible);
      this.getCanvas().draw();
      return this;
    };
    View2.prototype.data = function(data3) {
      set_default(this.options, "data", data3);
      this.isDataChanged = true;
      return this;
    };
    View2.prototype.source = function(data3) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
      return this.data(data3);
    };
    View2.prototype.filter = function(field6, condition) {
      if (is_function_default(condition)) {
        set_default(this.options, ["filters", field6], condition);
        return this;
      }
      if (!condition && get_default(this.options, ["filters", field6])) {
        delete this.options.filters[field6];
      }
      return this;
    };
    View2.prototype.axis = function(field6, axisOption) {
      if (is_boolean_default(field6)) {
        set_default(this.options, ["axes"], field6);
      } else {
        set_default(this.options, ["axes", field6], axisOption);
      }
      return this;
    };
    View2.prototype.legend = function(field6, legendOption) {
      if (is_boolean_default(field6)) {
        set_default(this.options, ["legends"], field6);
      } else if (is_string_default(field6)) {
        set_default(this.options, ["legends", field6], legendOption);
        if (is_plain_object_default(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
          set_default(this.options, ["filters", field6], function(name) {
            var _a6;
            return (_a6 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a6 !== void 0 ? _a6 : true;
          });
        }
      } else {
        set_default(this.options, ["legends"], field6);
      }
      return this;
    };
    View2.prototype.scale = function(field6, scaleOption) {
      var _this = this;
      if (is_string_default(field6)) {
        set_default(this.options, ["scales", field6], scaleOption);
      } else if (is_object_default(field6)) {
        each_default(field6, function(v, k) {
          set_default(_this.options, ["scales", k], v);
        });
      }
      return this;
    };
    View2.prototype.tooltip = function(cfg) {
      set_default(this.options, "tooltip", cfg);
      return this;
    };
    View2.prototype.annotation = function() {
      return this.getController("annotation");
    };
    View2.prototype.guide = function() {
      console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
      return this.annotation();
    };
    View2.prototype.coordinate = function(type, coordinateCfg) {
      if (is_string_default(type)) {
        set_default(this.options, "coordinate", { type, cfg: coordinateCfg });
      } else {
        set_default(this.options, "coordinate", type);
      }
      this.coordinateController.update(this.options.coordinate);
      return this.coordinateController;
    };
    View2.prototype.coord = function(type, coordinateCfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
      return this.coordinate(type, coordinateCfg);
    };
    View2.prototype.facet = function(type, cfg) {
      if (this.facetInstance) {
        this.facetInstance.destroy();
      }
      var Ctor = getFacet(type);
      if (!Ctor) {
        throw new Error("facet '".concat(type, "' is not exist!"));
      }
      this.facetInstance = new Ctor(this, __assign(__assign({}, cfg), { type }));
      return this;
    };
    View2.prototype.animate = function(status) {
      set_default(this.options, "animate", status);
      return this;
    };
    View2.prototype.updateOptions = function(options) {
      this.clear();
      mix(this.options, options);
      this.views.forEach(function(view) {
        return view.destroy();
      });
      this.views = [];
      this.initOptions();
      this.coordinateBBox = this.viewBBox;
      return this;
    };
    View2.prototype.option = function(name, opt) {
      if (View2.prototype[name]) {
        throw new Error(`Can't use built in variable name "`.concat(name, '", please change another one.'));
      }
      set_default(this.options, name, opt);
      return this;
    };
    View2.prototype.theme = function(theme4) {
      this.themeObject = is_object_default(theme4) ? deep_mix_default({}, this.themeObject, createTheme(theme4)) : getTheme(theme4);
      return this;
    };
    View2.prototype.interaction = function(name, cfg) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
      }
      var interaction10 = createInteraction(name, this, cfg);
      if (interaction10) {
        interaction10.init();
        this.interactions[name] = interaction10;
      }
      return this;
    };
    View2.prototype.removeInteraction = function(name) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
        this.interactions[name] = void 0;
      }
    };
    View2.prototype.changeData = function(data3) {
      this.isDataChanged = true;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.data(data3);
      this.paint(true);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.changeData(data3);
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    View2.prototype.createView = function(cfg) {
      if (this.parent && this.parent.parent) {
        console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
      }
      var sharedOptions = {
        data: this.options.data,
        scales: clone_default(this.options.scales),
        axes: clone_default(this.options.axes),
        coordinate: clone_default(this.coordinateController.getOption()),
        tooltip: clone_default(this.options.tooltip),
        legends: clone_default(this.options.legends),
        animate: this.options.animate,
        visible: this.visible
      };
      var v = new View2(__assign(__assign({
        parent: this,
        canvas: this.canvas,
        //  view  group
        backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        theme: this.themeObject,
        padding: this.padding
      }, cfg), { options: __assign(__assign({}, sharedOptions), get_default(cfg, "options", {})) }));
      this.views.push(v);
      return v;
    };
    View2.prototype.view = function(cfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
      return this.createView(cfg);
    };
    View2.prototype.removeView = function(view) {
      var removedView = remove_default(this.views, function(v) {
        return v === view;
      })[0];
      if (removedView) {
        removedView.destroy();
      }
      return removedView;
    };
    View2.prototype.getCoordinate = function() {
      return this.coordinateInstance;
    };
    View2.prototype.getTheme = function() {
      return this.themeObject;
    };
    View2.prototype.getXScale = function() {
      var g = this.geometries[0];
      return g ? g.getXScale() : null;
    };
    View2.prototype.getYScales = function() {
      var tmpMap = {};
      var yScales = [];
      this.geometries.forEach(function(g) {
        var yScale = g.getYScale();
        var field6 = yScale.field;
        if (!tmpMap[field6]) {
          tmpMap[field6] = true;
          yScales.push(yScale);
        }
      });
      return yScales;
    };
    View2.prototype.getScalesByDim = function(dimType) {
      var geometries = this.geometries;
      var scales = {};
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry35 = geometries[i];
        var scale8 = dimType === "x" ? geometry35.getXScale() : geometry35.getYScale();
        if (scale8 && !scales[scale8.field]) {
          scales[scale8.field] = scale8;
        }
      }
      return scales;
    };
    View2.prototype.getScale = function(field6, key) {
      var defaultKey = key ? key : this.getScaleKey(field6);
      return this.getRootView().scalePool.getScale(defaultKey);
    };
    View2.prototype.getScaleByField = function(field6, key) {
      return this.getScale(field6, key);
    };
    View2.prototype.getOptions = function() {
      return this.options;
    };
    View2.prototype.getData = function() {
      return this.filteredData;
    };
    View2.prototype.getOriginalData = function() {
      return this.options.data;
    };
    View2.prototype.getPadding = function() {
      return this.autoPadding.getPadding();
    };
    View2.prototype.getGeometries = function() {
      return this.geometries;
    };
    View2.prototype.getElements = function() {
      return reduce_default(this.geometries, function(elements, geometry35) {
        return elements.concat(geometry35.getElements());
      }, []);
    };
    View2.prototype.getElementsBy = function(condition) {
      return this.getElements().filter(function(el) {
        return condition(el);
      });
    };
    View2.prototype.getLayer = function(layer) {
      return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
    };
    View2.prototype.isPointInPlot = function(point2) {
      return isPointInCoordinate(this.getCoordinate(), point2);
    };
    View2.prototype.getLegendAttributes = function() {
      return flatten_default(this.geometries.map(function(g) {
        return g.getGroupAttributes();
      }));
    };
    View2.prototype.getGroupScales = function() {
      var scales = this.geometries.map(function(g) {
        return g.getGroupScales();
      });
      return uniq2(flatten_default(scales));
    };
    View2.prototype.getCanvas = function() {
      return this.getRootView().canvas;
    };
    View2.prototype.getRootView = function() {
      var v = this;
      while (true) {
        if (v.parent) {
          v = v.parent;
          continue;
        }
        break;
      }
      return v;
    };
    View2.prototype.getXY = function(data3) {
      var coordinate11 = this.getCoordinate();
      var xScales = this.getScalesByDim("x");
      var yScales = this.getScalesByDim("y");
      var x;
      var y;
      each_default(data3, function(value2, key) {
        if (xScales[key]) {
          x = xScales[key].scale(value2);
        }
        if (yScales[key]) {
          y = yScales[key].scale(value2);
        }
      });
      if (!is_nil_default(x) && !is_nil_default(y)) {
        return coordinate11.convert({ x, y });
      }
    };
    View2.prototype.getController = function(name) {
      return find_default(this.controllers, function(c) {
        return c.name === name;
      });
    };
    View2.prototype.showTooltip = function(point2) {
      var tooltip11 = this.getController("tooltip");
      if (tooltip11) {
        tooltip11.showTooltip(point2);
      }
      return this;
    };
    View2.prototype.hideTooltip = function() {
      var tooltip11 = this.getController("tooltip");
      if (tooltip11) {
        tooltip11.hideTooltip();
      }
      return this;
    };
    View2.prototype.lockTooltip = function() {
      var tooltip11 = this.getController("tooltip");
      if (tooltip11) {
        tooltip11.lockTooltip();
      }
      return this;
    };
    View2.prototype.unlockTooltip = function() {
      var tooltip11 = this.getController("tooltip");
      if (tooltip11) {
        tooltip11.unlockTooltip();
      }
      return this;
    };
    View2.prototype.isTooltipLocked = function() {
      var tooltip11 = this.getController("tooltip");
      return tooltip11 && tooltip11.isTooltipLocked();
    };
    View2.prototype.getTooltipItems = function(point2) {
      var tooltip11 = this.getController("tooltip");
      return tooltip11 ? tooltip11.getTooltipItems(point2) : [];
    };
    View2.prototype.getSnapRecords = function(point2) {
      var geometries = this.geometries;
      var rst = [];
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geom = geometries[i];
        var dataArray = geom.dataArray;
        geom.sort(dataArray);
        var record = void 0;
        for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
          var data3 = dataArray[j];
          record = findDataByPoint(point2, data3, geom);
          if (record) {
            rst.push(record);
          }
        }
      }
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        var snapRecords = view.getSnapRecords(point2);
        rst = rst.concat(snapRecords);
      }
      return rst;
    };
    View2.prototype.getComponents = function() {
      var components = [];
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        components = components.concat(controller.getComponents());
      }
      return components;
    };
    View2.prototype.filterData = function(data3) {
      var filters = this.options.filters;
      if (size(filters) === 0) {
        return data3;
      }
      return filter_default(data3, function(datum, idx) {
        var fields = Object.keys(filters);
        return fields.every(function(field6) {
          var condition = filters[field6];
          return condition(datum[field6], datum, idx);
        });
      });
    };
    View2.prototype.filterFieldData = function(field6, data3) {
      var filters = this.options.filters;
      var condition = get_default(filters, field6);
      if (is_undefined_default(condition)) {
        return data3;
      }
      return data3.filter(function(datum, idx) {
        return condition(datum[field6], datum, idx);
      });
    };
    View2.prototype.adjustCoordinate = function() {
      var _a6 = this.getCoordinate(), curStart = _a6.start, curEnd = _a6.end;
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      if (is_equal_default(curStart, start) && is_equal_default(curEnd, end)) {
        this.isCoordinateChanged = false;
        return;
      }
      this.isCoordinateChanged = true;
      this.coordinateInstance = this.coordinateController.adjust(start, end);
    };
    View2.prototype.paint = function(isUpdate) {
      this.renderDataRecursive(isUpdate);
      this.syncScale();
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
      this.renderPaddingRecursive(isUpdate);
      this.renderLayoutRecursive(isUpdate);
      this.renderBackgroundStyleShape();
      this.renderPaintRecursive(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
      this.isDataChanged = false;
    };
    View2.prototype.renderBackgroundStyleShape = function() {
      if (this.parent) {
        return;
      }
      var background = get_default(this.themeObject, "background");
      if (background) {
        if (!this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
            attrs: {},
            zIndex: -1,
            //  shape 
            capture: false
          });
          this.backgroundStyleRectShape.toBack();
        }
        var _a6 = this.viewBBox, x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
        this.backgroundStyleRectShape.attr({
          fill: background,
          x,
          y,
          width,
          height
        });
      } else {
        if (this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape.remove(true);
          this.backgroundStyleRectShape = void 0;
        }
      }
    };
    View2.prototype.renderPaddingRecursive = function(isUpdate) {
      this.calculateViewBBox();
      this.adjustCoordinate();
      this.initComponents(isUpdate);
      this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
      this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
      this.adjustCoordinate();
      var tooltipController = this.controllers.find(function(c) {
        return c.name === "tooltip";
      });
      tooltipController.update();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaddingRecursive(isUpdate);
      }
    };
    View2.prototype.renderLayoutRecursive = function(isUpdate) {
      var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : is_function_default(this.syncViewPadding) ? this.syncViewPadding : void 0;
      if (syncViewPaddingFn) {
        syncViewPaddingFn(this, this.views, PaddingCal);
        this.views.forEach(function(v) {
          v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
          v.adjustCoordinate();
        });
      }
      this.doLayout();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderLayoutRecursive(isUpdate);
      }
    };
    View2.prototype.renderPaintRecursive = function(isUpdate) {
      var middleGroup = this.middleGroup;
      if (this.limitInPlot) {
        var _a6 = getCoordinateClipCfg(this.coordinateInstance), type = _a6.type, attrs = _a6.attrs;
        middleGroup.setClip({
          type,
          attrs
        });
      } else {
        middleGroup.setClip(void 0);
      }
      this.paintGeometries(isUpdate);
      this.renderComponents(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaintRecursive(isUpdate);
      }
    };
    View2.prototype.createScale = function(field6, data3, scaleDef, key) {
      var currentScaleDef = get_default(this.options.scales, [field6]);
      var mergedScaleDef = __assign(__assign({}, currentScaleDef), scaleDef);
      if (this.parent) {
        return this.parent.createScale(field6, data3, mergedScaleDef, key);
      }
      return this.scalePool.createScale(field6, data3, mergedScaleDef, key);
    };
    View2.prototype.renderDataRecursive = function(isUpdate) {
      this.doFilterData();
      this.createCoordinate();
      this.initGeometries(isUpdate);
      this.renderFacet(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderDataRecursive(isUpdate);
      }
    };
    View2.prototype.calculateViewBBox = function() {
      var x;
      var y;
      var width;
      var height;
      if (this.parent) {
        var bbox = this.parent.coordinateBBox;
        x = bbox.x;
        y = bbox.y;
        width = bbox.width;
        height = bbox.height;
      } else {
        x = 0;
        y = 0;
        width = this.canvas.get("width");
        height = this.canvas.get("height");
      }
      var _a6 = this.region, start = _a6.start, end = _a6.end;
      var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
        this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      }
      this.coordinateBBox = this.viewBBox;
    };
    View2.prototype.initEvents = function() {
      this.foregroundGroup.on("*", this.onDelegateEvents);
      this.middleGroup.on("*", this.onDelegateEvents);
      this.backgroundGroup.on("*", this.onDelegateEvents);
      this.canvas.on("*", this.onCanvasEvent);
    };
    View2.prototype.initComponentController = function() {
      var usedControllers = this.usedControllers;
      for (var i = 0, len3 = usedControllers.length; i < len3; i++) {
        var controllerName = usedControllers[i];
        var Ctor = getComponentController(controllerName);
        if (Ctor) {
          this.controllers.push(new Ctor(this));
        }
      }
    };
    View2.prototype.createViewEvent = function(evt) {
      var shape = evt.shape, name = evt.name;
      var data3 = shape ? shape.get("origin") : null;
      var e = new event_default(this, evt, data3);
      e.type = name;
      return e;
    };
    View2.prototype.doPlotEvent = function(e) {
      var type = e.type, x = e.x, y = e.y;
      var point2 = { x, y };
      var ALL_EVENTS = [
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseleave",
        "mousewheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "click",
        "dblclick",
        "contextmenu"
      ];
      if (ALL_EVENTS.includes(type)) {
        var currentInPlot = this.isPointInPlot(point2);
        var newEvent = e.clone();
        if (currentInPlot) {
          var TYPE = "plot:".concat(type);
          newEvent.type = TYPE;
          this.emit(TYPE, newEvent);
          if (type === "mouseleave" || type === "touchend") {
            this.isPreMouseInPlot = false;
          }
        }
        if (type === "mousemove" || type === "touchmove") {
          if (this.isPreMouseInPlot && !currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
          } else if (!this.isPreMouseInPlot && currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
              this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
            }
            newEvent.type = PLOT_EVENTS.ENTER;
            this.emit(PLOT_EVENTS.ENTER, newEvent);
          }
          this.isPreMouseInPlot = currentInPlot;
        } else if (type === "mouseleave" || type === "touchend") {
          if (this.isPreMouseInPlot) {
            if (type === "mouseleave") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
            this.isPreMouseInPlot = false;
          }
        }
      }
    };
    View2.prototype.doFilterData = function() {
      var data3 = this.options.data;
      this.filteredData = this.filterData(data3);
    };
    View2.prototype.initGeometries = function(isUpdate) {
      this.createOrUpdateScales();
      var coordinate11 = this.getCoordinate();
      var scaleDefs = get_default(this.options, "scales", {});
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry35 = geometries[i];
        geometry35.scales = this.getGeometryScales();
        var cfg = {
          coordinate: coordinate11,
          scaleDefs,
          data: this.filteredData,
          theme: this.themeObject,
          isDataChanged: this.isDataChanged,
          isCoordinateChanged: this.isCoordinateChanged
        };
        if (isUpdate) {
          geometry35.update(cfg);
        } else {
          geometry35.init(cfg);
        }
      }
      this.adjustScales();
    };
    View2.prototype.createOrUpdateScales = function() {
      var fields = this.getScaleFields();
      var groupedFields = this.getGroupedFields();
      var _a6 = this.getOptions(), data3 = _a6.data, _b = _a6.scales, scales = _b === void 0 ? {} : _b;
      var filteredData = this.filteredData;
      for (var i = 0, len3 = fields.length; i < len3; i++) {
        var field6 = fields[i];
        var scaleDef = scales[field6];
        var key = this.getScaleKey(field6);
        this.createScale(
          field6,
          //  scale 
          groupedFields.includes(field6) ? data3 : filteredData,
          scaleDef,
          key
        );
        this.createdScaleKeys.set(key, true);
      }
    };
    View2.prototype.syncScale = function() {
      this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
    };
    View2.prototype.getGeometryScales = function() {
      var fields = this.getScaleFields();
      var scales = {};
      for (var i = 0; i < fields.length; i++) {
        var field6 = fields[i];
        scales[field6] = this.getScaleByField(field6);
      }
      return scales;
    };
    View2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry35 = geometries[i];
        var geometryScales = geometry35.getScaleFields();
        uniq2(geometryScales, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.getGroupedFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry35 = geometries[i];
        var groupFields = geometry35.getGroupFields();
        uniq2(groupFields, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.adjustScales = function() {
      this.adjustCategoryScaleRange();
    };
    View2.prototype.adjustCategoryScaleRange = function() {
      var _this = this;
      var xyScales = __spreadArray([this.getXScale()], __read(this.getYScales()), false).filter(function(e) {
        return !!e;
      });
      var coordinate11 = this.getCoordinate();
      var scaleOptions = this.options.scales;
      each_default(xyScales, function(scale8) {
        var field6 = scale8.field, values3 = scale8.values, isCategory = scale8.isCategory, isIdentity = scale8.isIdentity;
        if (isCategory || isIdentity) {
          if (values3 && !get_default(scaleOptions, [field6, "range"])) {
            scale8.range = getDefaultCategoryScaleRange(scale8, coordinate11, _this.theme);
          }
        }
      });
    };
    View2.prototype.initComponents = function(isUpdate) {
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        if (isUpdate) {
          controller.update();
        } else {
          controller.clear();
          controller.render();
        }
      }
    };
    View2.prototype.doLayout = function() {
      this.layoutFunc(this);
    };
    View2.prototype.createCoordinate = function() {
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      this.coordinateInstance = this.coordinateController.create(start, end);
    };
    View2.prototype.paintGeometries = function(isUpdate) {
      var doAnimation = this.options.animate;
      var coordinate11 = this.getCoordinate();
      var canvasRegion = {
        x: this.viewBBox.x,
        y: this.viewBBox.y,
        minX: this.viewBBox.minX,
        minY: this.viewBBox.minY,
        maxX: this.viewBBox.maxX,
        maxY: this.viewBBox.maxY,
        width: this.viewBBox.width,
        height: this.viewBBox.height
      };
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry35 = geometries[i];
        geometry35.coordinate = coordinate11;
        geometry35.canvasRegion = canvasRegion;
        if (!doAnimation) {
          geometry35.animate(false);
        }
        geometry35.paint(isUpdate);
      }
    };
    View2.prototype.renderComponents = function(isUpdate) {
      var components = this.getComponents();
      for (var i = 0; i < components.length; i++) {
        var co = components[i];
        co.component.render();
      }
    };
    View2.prototype.renderFacet = function(isUpdate) {
      if (this.facetInstance) {
        if (isUpdate) {
          this.facetInstance.update();
        } else {
          this.facetInstance.clear();
          this.facetInstance.init();
          this.facetInstance.render();
        }
      }
    };
    View2.prototype.initOptions = function() {
      var _this = this;
      var _a6 = this.options, _b = _a6.geometries, geometries = _b === void 0 ? [] : _b, _c = _a6.interactions, interactions = _c === void 0 ? [] : _c, _d = _a6.views, views = _d === void 0 ? [] : _d, _e = _a6.annotations, annotations = _e === void 0 ? [] : _e, coordinate11 = _a6.coordinate, events = _a6.events, facets = _a6.facets;
      if (this.coordinateController) {
        coordinate11 && this.coordinateController.update(coordinate11);
      } else {
        this.coordinateController = new coordinate_default(coordinate11);
      }
      for (var i = 0; i < geometries.length; i++) {
        var geometryOption = geometries[i];
        this.createGeometry(geometryOption);
      }
      for (var j = 0; j < interactions.length; j++) {
        var interactionOption = interactions[j];
        var type = interactionOption.type, cfg = interactionOption.cfg;
        this.interaction(type, cfg);
      }
      for (var k = 0; k < views.length; k++) {
        var viewOption = views[k];
        this.createView(viewOption);
      }
      var annotationComponent = this.getController("annotation");
      for (var l = 0; l < annotations.length; l++) {
        var annotationOption = annotations[l];
        annotationComponent.annotation(annotationOption);
      }
      if (events) {
        each_default(events, function(eventCallback, eventName) {
          _this.on(eventName, eventCallback);
        });
      }
      if (facets) {
        each_default(facets, function(facet) {
          var type2 = facet.type, rest2 = __rest(facet, ["type"]);
          _this.facet(type2, rest2);
        });
      }
    };
    View2.prototype.createGeometry = function(geometryOption) {
      var type = geometryOption.type, _a6 = geometryOption.cfg, cfg = _a6 === void 0 ? {} : _a6;
      if (this[type]) {
        var geometry_1 = this[type](cfg);
        each_default(geometryOption, function(v, k) {
          if (is_function_default(geometry_1[k])) {
            geometry_1[k](v);
          }
        });
      }
    };
    View2.prototype.getScaleKey = function(field6) {
      return "".concat(this.id, "-").concat(field6);
    };
    return View2;
  }(base_default)
);
function registerGeometry(name, Ctor) {
  View.prototype[name.toLowerCase()] = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = __assign({
      /**  */
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry35 = new Ctor(props);
    this.geometries.push(geometry35);
    return geometry35;
  };
}
var view_default = View;

// node_modules/@antv/g2/esm/chart/chart.js
var Chart = (
  /** @class */
  function(_super) {
    __extends(Chart2, _super);
    function Chart2(props) {
      var _this = this;
      var container = props.container, width = props.width, height = props.height, _a6 = props.autoFit, autoFit = _a6 === void 0 ? false : _a6, padding3 = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text", "axis-description"] : _f, options = props.options, limitInPlot5 = props.limitInPlot, theme4 = props.theme, syncViewPadding2 = props.syncViewPadding;
      var ele = is_string_default(container) ? document.getElementById(container) : container;
      var wrapperElement = createDom('<div style="position:relative;"></div>');
      ele.appendChild(wrapperElement);
      var size3 = getChartSize(ele, autoFit, width, height);
      var G = getEngine(renderer);
      var canvas = new G.Canvas(__assign({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size3));
      _this = _super.call(this, {
        parent: null,
        canvas,
        // create 3 group layers for views.
        backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        padding: padding3,
        appendPadding,
        visible,
        options,
        limitInPlot: limitInPlot5,
        theme: theme4,
        syncViewPadding: syncViewPadding2
      }) || this;
      _this.onResize = debounce_default(function() {
        _this.forceFit();
      }, 300);
      _this.ele = ele;
      _this.canvas = canvas;
      _this.width = size3.width;
      _this.height = size3.height;
      _this.autoFit = autoFit;
      _this.localRefresh = localRefresh;
      _this.renderer = renderer;
      _this.wrapperElement = wrapperElement;
      _this.updateCanvasStyle();
      _this.bindAutoFit();
      _this.initDefaultInteractions(defaultInteractions);
      return _this;
    }
    Chart2.prototype.initDefaultInteractions = function(interactions) {
      var _this = this;
      each_default(interactions, function(interaction10) {
        _this.interaction(interaction10);
      });
    };
    Chart2.prototype.aria = function(ariaOption) {
      var ATTR = "aria-label";
      if (ariaOption === false) {
        this.ele.removeAttribute(ATTR);
      } else {
        this.ele.setAttribute(ATTR, ariaOption.label);
      }
    };
    Chart2.prototype.changeSize = function(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
      this.width = width;
      this.height = height;
      this.canvas.changeSize(width, height);
      this.render(true);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
      return this;
    };
    Chart2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.aria(false);
    };
    Chart2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unbindAutoFit();
      this.canvas.destroy();
      removeDom(this.wrapperElement);
      this.wrapperElement = null;
    };
    Chart2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      this.wrapperElement.style.display = visible ? "" : "none";
      return this;
    };
    Chart2.prototype.forceFit = function() {
      if (!this.destroyed) {
        var _a6 = getChartSize(this.ele, true, this.width, this.height), width = _a6.width, height = _a6.height;
        this.changeSize(width, height);
      }
    };
    Chart2.prototype.updateCanvasStyle = function() {
      modifyCSS(this.canvas.get("el"), {
        display: "inline-block",
        verticalAlign: "middle"
      });
    };
    Chart2.prototype.bindAutoFit = function() {
      if (this.autoFit) {
        window.addEventListener("resize", this.onResize);
      }
    };
    Chart2.prototype.unbindAutoFit = function() {
      if (this.autoFit) {
        window.removeEventListener("resize", this.onResize);
      }
    };
    return Chart2;
  }(view_default)
);
var chart_default = Chart;

// node_modules/@antv/g2/esm/chart/controller/base.js
var Controller = (
  /** @class */
  function() {
    function Controller2(view) {
      this.visible = true;
      this.components = [];
      this.view = view;
    }
    Controller2.prototype.clear = function(includeOption) {
      each_default(this.components, function(co) {
        co.component.destroy();
      });
      this.components = [];
    };
    Controller2.prototype.destroy = function() {
      this.clear();
    };
    Controller2.prototype.getComponents = function() {
      return this.components;
    };
    Controller2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.components.forEach(function(co) {
        if (visible) {
          co.component.show();
        } else {
          co.component.hide();
        }
      });
      this.visible = visible;
    };
    return Controller2;
  }()
);

// node_modules/@antv/g2/esm/chart/controller/tooltip.js
function uniq3(items) {
  var uniqItems = [];
  var _loop_1 = function(index2) {
    var item = items[index2];
    var result2 = find_default(uniqItems, function(subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result2) {
      uniqItems.push(item);
    }
  };
  for (var index = 0; index < items.length; index++) {
    _loop_1(index);
  }
  return uniqItems;
}
var Tooltip2 = (
  /** @class */
  function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isLocked = false;
      return _this;
    }
    Object.defineProperty(Tooltip3.prototype, "name", {
      get: function() {
        return "tooltip";
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.init = function() {
    };
    Tooltip3.prototype.isVisible = function() {
      var option = this.view.getOptions().tooltip;
      return option !== false;
    };
    Tooltip3.prototype.render = function() {
    };
    Tooltip3.prototype.showTooltip = function(point2) {
      this.point = point2;
      if (!this.isVisible()) {
        return;
      }
      var view = this.view;
      var items = this.getTooltipItems(point2);
      if (!items.length) {
        this.hideTooltip();
        return;
      }
      var title = this.getTitle(items);
      var dataPoint = {
        x: items[0].x,
        y: items[0].y
      };
      view.emit("tooltip:show", event_default.fromData(view, "tooltip:show", __assign({ items, title }, point2)));
      var cfg = this.getTooltipCfg();
      var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
      var lastItems = this.items;
      var lastTitle = this.title;
      if (!is_equal_default(lastTitle, title) || !is_equal_default(lastItems, items)) {
        view.emit("tooltip:change", event_default.fromData(view, "tooltip:change", __assign({ items, title }, point2)));
        if (is_function_default(showContent) ? showContent(items) : showContent) {
          if (!this.tooltip) {
            this.renderTooltip();
          }
          this.tooltip.update(mix({}, cfg, {
            items: this.getItemsAfterProcess(items),
            title
          }, follow ? point2 : {}));
          this.tooltip.show();
        }
        if (showMarkers) {
          this.renderTooltipMarkers(items, marker);
        }
      } else {
        if (this.tooltip && follow) {
          this.tooltip.update(point2);
          this.tooltip.show();
        }
        if (this.tooltipMarkersGroup) {
          this.tooltipMarkersGroup.show();
        }
      }
      this.items = items;
      this.title = title;
      if (showCrosshairs) {
        var isCrosshairsFollowCursor = get_default(cfg, ["crosshairs", "follow"], false);
        this.renderCrosshairs(isCrosshairsFollowCursor ? point2 : dataPoint, cfg);
      }
    };
    Tooltip3.prototype.hideTooltip = function() {
      var follow = this.getTooltipCfg().follow;
      if (!follow) {
        this.point = null;
        return;
      }
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      var xCrosshair = this.xCrosshair;
      var yCrosshair = this.yCrosshair;
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
      var tooltip11 = this.tooltip;
      if (tooltip11) {
        tooltip11.hide();
      }
      this.view.emit("tooltip:hide", event_default.fromData(this.view, "tooltip:hide", {}));
      this.point = null;
    };
    Tooltip3.prototype.lockTooltip = function() {
      this.isLocked = true;
      if (this.tooltip) {
        this.tooltip.setCapture(true);
      }
    };
    Tooltip3.prototype.unlockTooltip = function() {
      this.isLocked = false;
      var cfg = this.getTooltipCfg();
      if (this.tooltip) {
        this.tooltip.setCapture(cfg.capture);
      }
    };
    Tooltip3.prototype.isTooltipLocked = function() {
      return this.isLocked;
    };
    Tooltip3.prototype.clear = function() {
      var _a6 = this, tooltip11 = _a6.tooltip, xCrosshair = _a6.xCrosshair, yCrosshair = _a6.yCrosshair, tooltipMarkersGroup = _a6.tooltipMarkersGroup;
      if (tooltip11) {
        tooltip11.hide();
        tooltip11.clear();
      }
      if (xCrosshair) {
        xCrosshair.clear();
      }
      if (yCrosshair) {
        yCrosshair.clear();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.clear();
      }
      if (tooltip11 === null || tooltip11 === void 0 ? void 0 : tooltip11.get("customContent")) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
      this.title = null;
      this.items = null;
    };
    Tooltip3.prototype.destroy = function() {
      if (this.tooltip) {
        this.tooltip.destroy();
      }
      if (this.xCrosshair) {
        this.xCrosshair.destroy();
      }
      if (this.yCrosshair) {
        this.yCrosshair.destroy();
      }
      if (this.guideGroup) {
        this.guideGroup.remove(true);
      }
      this.reset();
    };
    Tooltip3.prototype.reset = function() {
      this.items = null;
      this.title = null;
      this.tooltipMarkersGroup = null;
      this.tooltipCrosshairsGroup = null;
      this.xCrosshair = null;
      this.yCrosshair = null;
      this.tooltip = null;
      this.guideGroup = null;
      this.isLocked = false;
      this.point = null;
    };
    Tooltip3.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      var _a6 = this, tooltip11 = _a6.tooltip, tooltipMarkersGroup = _a6.tooltipMarkersGroup, xCrosshair = _a6.xCrosshair, yCrosshair = _a6.yCrosshair;
      if (visible) {
        if (tooltip11) {
          tooltip11.show();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.show();
        }
        if (xCrosshair) {
          xCrosshair.show();
        }
        if (yCrosshair) {
          yCrosshair.show();
        }
      } else {
        if (tooltip11) {
          tooltip11.hide();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.hide();
        }
        if (xCrosshair) {
          xCrosshair.hide();
        }
        if (yCrosshair) {
          yCrosshair.hide();
        }
      }
      this.visible = visible;
    };
    Tooltip3.prototype.getTooltipItems = function(point2) {
      var e_1, _a6, e_2, _b, e_3, _c;
      var items = this.findItemsFromView(this.view, point2);
      if (items.length) {
        items = flatten_default(items);
        try {
          for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var itemArr = items_1_1.value;
            try {
              for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
                var item = itemArr_1_1.value;
                var _d = item.mappingData, x = _d.x, y = _d.y;
                item.x = is_array_default(x) ? x[x.length - 1] : x;
                item.y = is_array_default(y) ? y[y.length - 1] : y;
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
                  _b.call(itemArr_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (items_1_1 && !items_1_1.done && (_a6 = items_1.return))
              _a6.call(items_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var shared = this.getTooltipCfg().shared;
        if (shared === false && items.length > 1) {
          var snapItem = items[0];
          var min5 = Math.abs(point2.y - snapItem[0].y);
          try {
            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
              var aItem = items_2_1.value;
              var yDistance = Math.abs(point2.y - aItem[0].y);
              if (yDistance <= min5) {
                snapItem = aItem;
                min5 = yDistance;
              }
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (items_2_1 && !items_2_1.done && (_c = items_2.return))
                _c.call(items_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          items = [snapItem];
        }
        return uniq3(flatten_default(items));
      }
      return [];
    };
    Tooltip3.prototype.layout = function() {
    };
    Tooltip3.prototype.update = function() {
      if (this.point) {
        this.showTooltip(this.point);
      }
      if (this.tooltip) {
        var canvas = this.view.getCanvas();
        this.tooltip.set("region", {
          start: { x: 0, y: 0 },
          end: { x: canvas.get("width"), y: canvas.get("height") }
        });
      }
    };
    Tooltip3.prototype.isCursorEntered = function(point2) {
      if (this.tooltip) {
        var el = this.tooltip.getContainer();
        var capture = this.tooltip.get("capture");
        if (el && capture) {
          var _a6 = el.getBoundingClientRect(), x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
          return new BBox(x, y, width, height).isPointIn(point2);
        }
      }
      return false;
    };
    Tooltip3.prototype.getTooltipCfg = function() {
      var view = this.view;
      var option = view.getOptions().tooltip;
      var processOption = this.processCustomContent(option);
      var theme4 = view.getTheme();
      var defaultCfg = get_default(theme4, ["components", "tooltip"], {});
      var enterable = get_default(processOption, "enterable", defaultCfg.enterable);
      return deep_mix_default({}, defaultCfg, processOption, {
        capture: enterable || this.isLocked ? true : false
      });
    };
    Tooltip3.prototype.processCustomContent = function(option) {
      if (is_boolean_default(option) || !get_default(option, "customContent")) {
        return option;
      }
      var currentCustomContent = option.customContent;
      var customContent = function(title, items) {
        var content = currentCustomContent(title, items) || "";
        return is_string_default(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
      };
      return __assign(__assign({}, option), { customContent });
    };
    Tooltip3.prototype.getTitle = function(items) {
      var title = items[0].title || items[0].name;
      this.title = title;
      return title;
    };
    Tooltip3.prototype.renderTooltip = function() {
      var canvas = this.view.getCanvas();
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var cfg = this.getTooltipCfg();
      var tooltip11 = new HtmlTooltip(__assign(__assign({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
      tooltip11.init();
      this.tooltip = tooltip11;
    };
    Tooltip3.prototype.renderTooltipMarkers = function(items, marker) {
      var e_4, _a6;
      var tooltipMarkersGroup = this.getTooltipMarkersGroup();
      var rootView = this.view.getRootView();
      var limitInPlot5 = rootView.limitInPlot;
      try {
        for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
          var item = items_3_1.value;
          var x = item.x, y = item.y;
          if (limitInPlot5 || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
            var _b = getCoordinateClipCfg(rootView.getCoordinate()), type = _b.type, attrs_1 = _b.attrs;
            tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({
              type,
              attrs: attrs_1
            });
          } else {
            tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(void 0);
          }
          var theme4 = this.view.getTheme();
          var markerDefaultCfg = get_default(theme4, ["components", "tooltip", "marker"], {});
          var attrs = __assign(__assign({ fill: item.color, symbol: "circle", shadowColor: item.color }, is_function_default(marker) ? __assign(__assign({}, markerDefaultCfg), marker(item)) : marker), { x, y });
          tooltipMarkersGroup.addShape("marker", {
            attrs
          });
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (items_3_1 && !items_3_1.done && (_a6 = items_3.return))
            _a6.call(items_3);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    Tooltip3.prototype.renderCrosshairs = function(point2, cfg) {
      var crosshairsType = get_default(cfg, ["crosshairs", "type"], "x");
      if (crosshairsType === "x") {
        if (this.yCrosshair) {
          this.yCrosshair.hide();
        }
        this.renderXCrosshairs(point2, cfg);
      } else if (crosshairsType === "y") {
        if (this.xCrosshair) {
          this.xCrosshair.hide();
        }
        this.renderYCrosshairs(point2, cfg);
      } else if (crosshairsType === "xy") {
        this.renderXCrosshairs(point2, cfg);
        this.renderYCrosshairs(point2, cfg);
      }
    };
    Tooltip3.prototype.renderXCrosshairs = function(point2, tooltipCfg) {
      var coordinate11 = this.getViewWithGeometry(this.view).getCoordinate();
      var start;
      var end;
      if (coordinate11.isRect) {
        if (coordinate11.isTransposed) {
          start = {
            x: coordinate11.start.x,
            y: point2.y
          };
          end = {
            x: coordinate11.end.x,
            y: point2.y
          };
        } else {
          start = {
            x: point2.x,
            y: coordinate11.end.y
          };
          end = {
            x: point2.x,
            y: coordinate11.start.y
          };
        }
      } else {
        var angle4 = getAngleByPoint(coordinate11, point2);
        var center2 = coordinate11.getCenter();
        var radius = coordinate11.getRadius();
        end = polarToCartesian(center2.x, center2.y, radius, angle4);
        start = center2;
      }
      var cfg = deep_mix_default({
        start,
        end,
        container: this.getTooltipCrosshairsGroup()
      }, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point2, tooltipCfg));
      delete cfg.type;
      var xCrosshair = this.xCrosshair;
      if (xCrosshair) {
        xCrosshair.update(cfg);
      } else {
        xCrosshair = new crosshair_exports.Line(cfg);
        xCrosshair.init();
      }
      xCrosshair.render();
      xCrosshair.show();
      this.xCrosshair = xCrosshair;
    };
    Tooltip3.prototype.renderYCrosshairs = function(point2, tooltipCfg) {
      var coordinate11 = this.getViewWithGeometry(this.view).getCoordinate();
      var cfg;
      var type;
      if (coordinate11.isRect) {
        var start = void 0;
        var end = void 0;
        if (coordinate11.isTransposed) {
          start = {
            x: point2.x,
            y: coordinate11.end.y
          };
          end = {
            x: point2.x,
            y: coordinate11.start.y
          };
        } else {
          start = {
            x: coordinate11.start.x,
            y: point2.y
          };
          end = {
            x: coordinate11.end.x,
            y: point2.y
          };
        }
        cfg = {
          start,
          end
        };
        type = "Line";
      } else {
        cfg = {
          center: coordinate11.getCenter(),
          // @ts-ignore
          radius: getDistanceToCenter(coordinate11, point2),
          startAngle: coordinate11.startAngle,
          endAngle: coordinate11.endAngle
        };
        type = "Circle";
      }
      cfg = deep_mix_default({
        container: this.getTooltipCrosshairsGroup()
      }, cfg, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point2, tooltipCfg));
      delete cfg.type;
      var yCrosshair = this.yCrosshair;
      if (yCrosshair) {
        if (coordinate11.isRect && yCrosshair.get("type") === "circle" || !coordinate11.isRect && yCrosshair.get("type") === "line") {
          yCrosshair = new crosshair_exports[type](cfg);
          yCrosshair.init();
        } else {
          yCrosshair.update(cfg);
        }
      } else {
        yCrosshair = new crosshair_exports[type](cfg);
        yCrosshair.init();
      }
      yCrosshair.render();
      yCrosshair.show();
      this.yCrosshair = yCrosshair;
    };
    Tooltip3.prototype.getCrosshairsText = function(type, point2, tooltipCfg) {
      var textCfg = get_default(tooltipCfg, ["crosshairs", "text"]);
      var follow = get_default(tooltipCfg, ["crosshairs", "follow"]);
      var items = this.items;
      if (textCfg) {
        var view = this.getViewWithGeometry(this.view);
        var firstItem = items[0];
        var xScale = view.getXScale();
        var yScale = view.getYScales()[0];
        var xValue = void 0;
        var yValue = void 0;
        if (follow) {
          var invertPoint = this.view.getCoordinate().invert(point2);
          xValue = xScale.invert(invertPoint.x);
          yValue = yScale.invert(invertPoint.y);
        } else {
          xValue = firstItem.data[xScale.field];
          yValue = firstItem.data[yScale.field];
        }
        var content = type === "x" ? xValue : yValue;
        if (is_function_default(textCfg)) {
          textCfg = textCfg(type, content, items, point2);
        } else {
          textCfg.content = content;
        }
        return {
          text: textCfg
        };
      }
    };
    Tooltip3.prototype.getGuideGroup = function() {
      if (!this.guideGroup) {
        var foregroundGroup = this.view.foregroundGroup;
        this.guideGroup = foregroundGroup.addGroup({
          name: "tooltipGuide",
          capture: false
        });
      }
      return this.guideGroup;
    };
    Tooltip3.prototype.getTooltipMarkersGroup = function() {
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
        tooltipMarkersGroup.clear();
        tooltipMarkersGroup.show();
      } else {
        tooltipMarkersGroup = this.getGuideGroup().addGroup({
          name: "tooltipMarkersGroup"
        });
        tooltipMarkersGroup.toFront();
        this.tooltipMarkersGroup = tooltipMarkersGroup;
      }
      return tooltipMarkersGroup;
    };
    Tooltip3.prototype.getTooltipCrosshairsGroup = function() {
      var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
      if (!tooltipCrosshairsGroup) {
        tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
          name: "tooltipCrosshairsGroup",
          capture: false
        });
        tooltipCrosshairsGroup.toBack();
        this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
      }
      return tooltipCrosshairsGroup;
    };
    Tooltip3.prototype.findItemsFromView = function(view, point2) {
      var e_5, _a6;
      if (view.getOptions().tooltip === false) {
        return [];
      }
      var tooltipCfg = this.getTooltipCfg();
      var result2 = findItemsFromView(view, point2, tooltipCfg);
      try {
        for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
          var childView = _c.value;
          result2 = result2.concat(this.findItemsFromView(childView, point2));
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a6 = _b.return))
            _a6.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return result2;
    };
    Tooltip3.prototype.getViewWithGeometry = function(view) {
      var _this = this;
      if (view.geometries.length) {
        return view;
      }
      return find_default(view.views, function(childView) {
        return _this.getViewWithGeometry(childView);
      });
    };
    Tooltip3.prototype.getItemsAfterProcess = function(originalItems) {
      var customItems = this.getTooltipCfg().customItems;
      var fn = customItems ? customItems : function(v) {
        return v;
      };
      return fn(originalItems);
    };
    return Tooltip3;
  }(Controller)
);
var tooltip_default = Tooltip2;

// node_modules/@antv/g2/esm/animate/animation/index.js
var ANIMATIONS_MAP = {};
function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}
function registerAnimation(type, animation7) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation7;
}

// node_modules/@antv/g2/esm/animate/index.js
var DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: "easeQuadOut"
  },
  update: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  enter: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  leave: {
    duration: 350,
    easing: "easeQuadIn"
  }
  // 
};
var GEOMETRY_ANIMATE_CFG = {
  interval: function(coordinate11) {
    return {
      enter: {
        animation: coordinate11.isRect ? coordinate11.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
      },
      update: {
        animation: coordinate11.isPolar && coordinate11.isTransposed ? "sector-path-update" : null
      },
      leave: {
        animation: "fade-out"
      }
    };
  },
  line: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  path: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  point: {
    appear: {
      animation: "zoom-in"
    },
    enter: {
      animation: "zoom-in"
    },
    leave: {
      animation: "zoom-out"
    }
  },
  area: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  polygon: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  schema: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  edge: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  label: {
    appear: {
      animation: "fade-in",
      delay: 450
    },
    enter: {
      animation: "fade-in"
    },
    update: {
      animation: "position-update"
    },
    leave: {
      animation: "fade-out"
    }
  }
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function() {
    return {
      animation: "wave-in"
    };
  },
  area: function() {
    return {
      animation: "wave-in"
    };
  },
  path: function() {
    return {
      animation: "fade-in"
    };
  },
  interval: function(coordinate11) {
    var animation7;
    if (coordinate11.isRect) {
      animation7 = coordinate11.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation7 = "grow-in-xy";
      if (coordinate11.isPolar && coordinate11.isTransposed) {
        animation7 = "wave-in";
      }
    }
    return {
      animation: animation7
    };
  },
  schema: function(coordinate11) {
    var animation7;
    if (coordinate11.isRect) {
      animation7 = coordinate11.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation7 = "grow-in-xy";
    }
    return {
      animation: animation7
    };
  },
  polygon: function() {
    return {
      animation: "fade-in",
      duration: 500
    };
  },
  edge: function() {
    return {
      animation: "fade-in"
    };
  }
};
function parseAnimateConfig(animateCfg, data3) {
  return {
    delay: is_function_default(animateCfg.delay) ? animateCfg.delay(data3) : animateCfg.delay,
    easing: is_function_default(animateCfg.easing) ? animateCfg.easing(data3) : animateCfg.easing,
    duration: is_function_default(animateCfg.duration) ? animateCfg.duration(data3) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate11, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if (is_function_default(animateCfg)) {
      animateCfg = animateCfg(coordinate11);
    }
    animateCfg = deep_mix_default({}, DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
function doAnimate(shape, animateCfg, cfg) {
  var data3 = get_default(shape.get("origin"), "data", FIELD_ORIGIN);
  var animation7 = animateCfg.animation;
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data3);
  if (animation7) {
    var animateFunction = getAnimation(animation7);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate11, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate11);
    var animation7 = getAnimation(get_default(defaultCfg, "animation", ""));
    if (animation7) {
      var cfg = __assign(__assign(__assign({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate();
      animation7(container, cfg, {
        coordinate: coordinate11,
        minYPoint,
        toAttrs: null
      });
    }
  }
}

// node_modules/@antv/g2/esm/geometry/shape/constant.js
var BACKGROUND_SHAPE = "element-background";

// node_modules/@antv/g2/esm/geometry/element/index.js
var Element3 = (
  /** @class */
  function(_super) {
    __extends(Element4, _super);
    function Element4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.labelShape = [];
      _this.states = [];
      var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a6 = cfg.visible, visible = _a6 === void 0 ? true : _a6;
      _this.shapeFactory = shapeFactory;
      _this.container = container;
      _this.offscreenGroup = offscreenGroup;
      _this.visible = visible;
      _this.elementIndex = elementIndex;
      return _this;
    }
    Element4.prototype.draw = function(model, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.drawShape(model, isUpdate);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Element4.prototype.update = function(model) {
      var _a6 = this, shapeFactory = _a6.shapeFactory, shape = _a6.shape;
      if (!shape) {
        return;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.setShapeInfo(shape, model);
      var offscreenGroup = this.getOffscreenGroup();
      var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
      newShape.cfg.data = this.data;
      newShape.cfg.origin = model;
      newShape.cfg.element = this;
      this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
    };
    Element4.prototype.destroy = function() {
      var _a6 = this, shapeFactory = _a6.shapeFactory, shape = _a6.shape;
      if (shape) {
        var animateCfg = this.getAnimateCfg("leave");
        if (animateCfg) {
          doAnimate(shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, shape.attr())
          });
        } else {
          shape.remove(true);
        }
      }
      this.states = [];
      this.shapeFactory = void 0;
      this.container = void 0;
      this.shape = void 0;
      this.animate = void 0;
      this.geometry = void 0;
      this.labelShape = [];
      this.model = void 0;
      this.data = void 0;
      this.offscreenGroup = void 0;
      this.statesStyle = void 0;
      _super.prototype.destroy.call(this);
    };
    Element4.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      if (visible) {
        if (this.shape) {
          this.shape.show();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label17) {
            label17.show();
          });
        }
      } else {
        if (this.shape) {
          this.shape.hide();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label17) {
            label17.hide();
          });
        }
      }
    };
    Element4.prototype.setState = function(stateName, stateStatus) {
      var _a6 = this, states = _a6.states, shapeFactory = _a6.shapeFactory, model = _a6.model, shape = _a6.shape, shapeType = _a6.shapeType;
      var index = states.indexOf(stateName);
      if (stateStatus) {
        if (index > -1) {
          return;
        }
        states.push(stateName);
        if (stateName === "active" || stateName === "selected") {
          shape === null || shape === void 0 ? void 0 : shape.toFront();
        }
      } else {
        if (index === -1) {
          return;
        }
        states.splice(index, 1);
        if (stateName === "active" || stateName === "selected") {
          var _b = this.geometry, sortZIndex = _b.sortZIndex, zIndexReversed = _b.zIndexReversed;
          var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
          sortZIndex ? shape.setZIndex(idx) : shape.set("zIndex", idx);
        }
      }
      var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
      if (states.length) {
        this.syncShapeStyle(shape, offscreenShape, states, null);
      } else {
        this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
      }
      offscreenShape.remove(true);
      var eventObject = {
        state: stateName,
        stateStatus,
        element: this,
        target: this.container
      };
      this.container.emit("statechange", eventObject);
      propagationDelegate(this.shape, "statechange", eventObject);
    };
    Element4.prototype.clearStates = function() {
      var _this = this;
      var states = this.states;
      each_default(states, function(state2) {
        _this.setState(state2, false);
      });
      this.states = [];
    };
    Element4.prototype.hasState = function(stateName) {
      return this.states.includes(stateName);
    };
    Element4.prototype.getStates = function() {
      return this.states;
    };
    Element4.prototype.getData = function() {
      return this.data;
    };
    Element4.prototype.getModel = function() {
      return this.model;
    };
    Element4.prototype.getBBox = function() {
      var _a6 = this, shape = _a6.shape, labelShape = _a6.labelShape;
      var bbox = {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
      if (shape) {
        bbox = shape.getCanvasBBox();
      }
      if (labelShape) {
        labelShape.forEach(function(label17) {
          var labelBBox = label17.getCanvasBBox();
          bbox.x = Math.min(labelBBox.x, bbox.x);
          bbox.y = Math.min(labelBBox.y, bbox.y);
          bbox.minX = Math.min(labelBBox.minX, bbox.minX);
          bbox.minY = Math.min(labelBBox.minY, bbox.minY);
          bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
          bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
        });
      }
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      return bbox;
    };
    Element4.prototype.getStatesStyle = function() {
      if (!this.statesStyle) {
        var _a6 = this, shapeType = _a6.shapeType, geometry35 = _a6.geometry, shapeFactory = _a6.shapeFactory;
        var stateOption = geometry35.stateOption;
        var defaultShapeType = shapeFactory.defaultShapeType;
        var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
        this.statesStyle = deep_mix_default({}, stateTheme, stateOption);
      }
      return this.statesStyle;
    };
    Element4.prototype.getStateStyle = function(stateName, shapeKey) {
      var statesStyle = this.getStatesStyle();
      var stateCfg = get_default(statesStyle, [stateName, "style"], {});
      var shapeStyle = stateCfg[shapeKey] || stateCfg;
      if (is_function_default(shapeStyle)) {
        return shapeStyle(this);
      }
      return shapeStyle;
    };
    Element4.prototype.getAnimateCfg = function(animateType) {
      var _this = this;
      var animate = this.animate;
      if (animate) {
        var cfg_1 = animate[animateType];
        if (cfg_1) {
          return __assign(__assign({}, cfg_1), { callback: function() {
            var _a6;
            is_function_default(cfg_1.callback) && cfg_1.callback();
            (_a6 = _this.geometry) === null || _a6 === void 0 ? void 0 : _a6.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          } });
        }
        return cfg_1;
      }
      return null;
    };
    Element4.prototype.drawShape = function(model, isUpdate) {
      var _a6;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
      this.shape = shapeFactory.drawShape(shapeType, model, container);
      if (this.shape) {
        this.setShapeInfo(this.shape, model);
        var name_1 = this.shape.cfg.name;
        if (!name_1) {
          this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
        } else if (is_string_default(name_1)) {
          this.shape.cfg.name = ["element", name_1];
        }
        var animateType = isUpdate ? "enter" : "appear";
        var animateCfg = this.getAnimateCfg(animateType);
        if (animateCfg) {
          (_a6 = this.geometry) === null || _a6 === void 0 ? void 0 : _a6.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(this.shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, this.shape.attr())
          });
        }
      }
    };
    Element4.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Element4.prototype.setShapeInfo = function(shape, data3) {
      var _this = this;
      shape.cfg.origin = data3;
      shape.cfg.element = this;
      if (shape.isGroup()) {
        var children = shape.get("children");
        children.forEach(function(child) {
          _this.setShapeInfo(child, data3);
        });
      }
    };
    Element4.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index) {
      var _this = this;
      var _a6;
      if (states === void 0) {
        states = [];
      }
      if (index === void 0) {
        index = 0;
      }
      if (!sourceShape || !targetShape) {
        return;
      }
      var clip = sourceShape.get("clipShape");
      var newClip = targetShape.get("clipShape");
      this.syncShapeStyle(clip, newClip, states, animateCfg);
      if (sourceShape.isGroup()) {
        var children = sourceShape.get("children");
        var newChildren = targetShape.get("children");
        for (var i = 0; i < children.length; i++) {
          this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
        }
      } else {
        if (!is_empty_default(states) && !is_equal_default(states, ["reset"])) {
          var name_2 = sourceShape.get("name");
          if (is_array_default(name_2)) {
            name_2 = name_2[1];
          }
          each_default(states, function(state2) {
            if (targetShape.get("name") !== BACKGROUND_SHAPE) {
              var style = _this.getStateStyle(state2, name_2 || index);
              targetShape.attr(style);
            }
          });
        }
        var newAttrs = getReplaceAttrs(sourceShape, targetShape);
        if (this.animate) {
          if (animateCfg) {
            (_a6 = this.geometry) === null || _a6 === void 0 ? void 0 : _a6.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
            doAnimate(sourceShape, animateCfg, {
              coordinate: this.shapeFactory.coordinate,
              toAttrs: newAttrs,
              shapeModel: this.model
            });
          } else if (!is_empty_default(states)) {
            sourceShape.stopAnimate();
            sourceShape.animate(newAttrs, {
              duration: 300
            });
          } else {
            sourceShape.attr(newAttrs);
          }
        } else {
          sourceShape.attr(newAttrs);
        }
      }
    };
    Element4.prototype.getShapeType = function(model) {
      var shape = get_default(model, "shape");
      return is_array_default(shape) ? shape[0] : shape;
    };
    return Element4;
  }(base_default)
);
var element_default2 = Element3;

// node_modules/@antv/g2/esm/geometry/label/index.js
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}

// node_modules/@antv/g2/esm/geometry/shape/base.js
var ShapeFactoryBase = {
  /**  */
  coordinate: null,
  /**  Shape  */
  defaultShapeType: null,
  /**  */
  theme: null,
  /**
   *  shape 
   * @param shapeType shape 
   * @param shapePoint  size 
   * @returns 
   */
  getShapePoints: function(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
  /**
   *  shape  shape 
   * @param shapeType string shape 
   * @returns
   */
  getShape: function(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
  /**
   *  shape 
   * @override
   */
  getDefaultPoints: function() {
    return [];
  },
  /**
   *  shape  ( shapeFactory )
   */
  getDefaultStyle: function(geometryTheme) {
    return get_default(geometryTheme, [this.defaultShapeType, "default", "style"], {});
  },
  /**
   *  shape 
   * @param shapeType shape 
   * @param color 
   * @param isInPolar 
   * @returns  marker 
   */
  getMarker: function(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme4 = this.theme;
    var shapeStyle = get_default(theme4, [shapeType, "default"], {});
    var markerStyle = shape.getMarker(markerCfg);
    return deep_mix_default({}, shapeStyle, markerStyle);
  },
  /**
   *  shape
   * @override
   * @param shapeType  shape 
   * @param cfg  shape 
   * @param element Element 
   * @returns
   */
  drawShape: function(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase = {
  /**  */
  coordinate: null,
  /**
   *  path  path
   * @param path 
   * @returns
   */
  parsePath: function(path) {
    var coordinate11 = this.coordinate;
    var parsedPath = parsePathString2(path);
    if (coordinate11.isPolar) {
      parsedPath = convertPolarPath(coordinate11, parsedPath);
    } else {
      parsedPath = convertNormalPath(coordinate11, parsedPath);
    }
    return parsedPath;
  },
  /**
   * 
   * @param point 
   * @returns
   */
  parsePoint: function(point2) {
    var coordinate11 = this.coordinate;
    return coordinate11.convert(point2);
  },
  /**
   * 01 points   points
   * @param points 
   * @returns
   */
  parsePoints: function(points2) {
    var coordinate11 = this.coordinate;
    return points2.map(function(point2) {
      return coordinate11.convert(point2);
    });
  },
  /**
   *  shape
   * @override
   */
  draw: function(cfg, container) {
  }
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = upper_first_default(factoryName);
  var geomObj = __assign(__assign(__assign({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
function registerShape(factoryName, shapeType, cfg) {
  var className = upper_first_default(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = __assign(__assign({}, ShapeBase), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
function getShapeFactory(factoryName) {
  var className = upper_first_default(factoryName);
  return ShapeFactoryMap[className];
}

// node_modules/@antv/g2/esm/geometry/util/group-data.js
function group(data3, fields, appendConditions) {
  var e_1, _a6;
  if (appendConditions === void 0) {
    appendConditions = {};
  }
  if (!fields) {
    return [data3];
  }
  var groups = groupToMap(data3, fields);
  var array = [];
  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values3 = appendConditions[fields[0]];
    try {
      for (var values_1 = __values(values3), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
        var value2 = values_1_1.value;
        var arr = groups["_".concat(value2)];
        if (arr) {
          array.push(arr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (values_1_1 && !values_1_1.done && (_a6 = values_1.return))
          _a6.call(values_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else {
    for (var k in groups) {
      if (groups.hasOwnProperty(k)) {
        var eachGroup = groups[k];
        array.push(eachGroup);
      }
    }
  }
  return array;
}

// node_modules/@antv/g2/esm/geometry/util/is-model-change.js
function isModelChange(currentModel, preModel) {
  return some_default(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
    return !is_equal_default(currentModel[key], preModel[key]);
  });
}

// node_modules/@antv/g2/esm/geometry/util/parse-fields.js
function parseFields(field6) {
  if (is_array_default(field6)) {
    return field6;
  }
  return field6.split("*");
}

// node_modules/@antv/g2/esm/geometry/util/diff.js
function diff(keyItem, keys3) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = /* @__PURE__ */ new Map();
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (keyItem[key])
      updated.push(key);
    else
      added.push(key);
    keyIncluded.set(key, true);
  }
  Object.keys(keyItem).forEach(function(key2) {
    if (!keyIncluded.has(key2))
      removed.push(key2);
  });
  return {
    added,
    updated,
    removed
  };
}

// node_modules/@antv/g2/esm/geometry/base.js
var Geometry = (
  /** @class */
  function(_super) {
    __extends(Geometry2, _super);
    function Geometry2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "base";
      _this.attributes = {};
      _this.elements = [];
      _this.elementsMap = {};
      _this.animateOption = true;
      _this.attributeOption = {};
      _this.lastElementsMap = {};
      _this.generatePoints = false;
      _this.beforeMappingData = null;
      _this.adjusts = {};
      _this.idFields = [];
      _this.hasSorted = false;
      _this.isCoordinateChanged = false;
      var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate11 = cfg.coordinate, data3 = cfg.data, _a6 = cfg.sortable, sortable = _a6 === void 0 ? false : _a6, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme4 = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
      _this.container = container;
      _this.labelsContainer = labelsContainer;
      _this.coordinate = coordinate11;
      _this.data = data3;
      _this.sortable = sortable;
      _this.visible = visible;
      _this.userTheme = theme4;
      _this.scales = scales;
      _this.scaleDefs = scaleDefs;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.roseWidthRatio = roseWidthRatio;
      _this.multiplePieWidthRatio = multiplePieWidthRatio;
      _this.zIndexReversed = zIndexReversed;
      _this.sortZIndex = sortZIndex;
      _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === "number" ? useDeferredLabel : Infinity : null;
      return _this;
    }
    Geometry2.prototype.position = function(cfg) {
      var positionCfg = cfg;
      if (!is_plain_object_default(cfg)) {
        positionCfg = {
          fields: parseFields(cfg)
        };
      }
      var fields = get_default(positionCfg, "fields");
      if (fields.length === 1) {
        fields.unshift("1");
        set_default(positionCfg, "fields", fields);
      }
      set_default(this.attributeOption, "position", positionCfg);
      return this;
    };
    Geometry2.prototype.color = function(field6, cfg) {
      this.createAttrOption("color", field6, cfg);
      return this;
    };
    Geometry2.prototype.shape = function(field6, cfg) {
      this.createAttrOption("shape", field6, cfg);
      return this;
    };
    Geometry2.prototype.size = function(field6, cfg) {
      this.createAttrOption("size", field6, cfg);
      return this;
    };
    Geometry2.prototype.adjust = function(adjustCfg2) {
      var adjusts = adjustCfg2;
      if (is_string_default(adjustCfg2) || is_plain_object_default(adjustCfg2)) {
        adjusts = [adjustCfg2];
      }
      each_default(adjusts, function(adjust3, index) {
        if (!is_object_default(adjust3)) {
          adjusts[index] = { type: adjust3 };
        }
      });
      this.adjustOption = adjusts;
      return this;
    };
    Geometry2.prototype.style = function(field6, styleFunc) {
      if (is_string_default(field6)) {
        var fields = parseFields(field6);
        this.styleOption = {
          fields,
          callback: styleFunc
        };
      } else {
        var _a6 = field6, fields = _a6.fields, callback = _a6.callback, cfg = _a6.cfg;
        if (fields || callback || cfg) {
          this.styleOption = field6;
        } else {
          this.styleOption = {
            cfg: field6
          };
        }
      }
      return this;
    };
    Geometry2.prototype.tooltip = function(field6, cfg) {
      if (is_string_default(field6)) {
        var fields = parseFields(field6);
        this.tooltipOption = {
          fields,
          callback: cfg
        };
      } else {
        this.tooltipOption = field6;
      }
      return this;
    };
    Geometry2.prototype.animate = function(cfg) {
      this.animateOption = cfg;
      return this;
    };
    Geometry2.prototype.label = function(field6, secondParam, thirdParam) {
      if (is_string_default(field6)) {
        var labelOption = {};
        var fields = parseFields(field6);
        labelOption.fields = fields;
        if (is_function_default(secondParam)) {
          labelOption.callback = secondParam;
        } else if (is_plain_object_default(secondParam)) {
          labelOption.cfg = secondParam;
        }
        if (thirdParam) {
          labelOption.cfg = thirdParam;
        }
        this.labelOption = labelOption;
      } else {
        this.labelOption = field6;
      }
      return this;
    };
    Geometry2.prototype.state = function(cfg) {
      this.stateOption = cfg;
      return this;
    };
    Geometry2.prototype.customInfo = function(cfg) {
      this.customOption = cfg;
      return this;
    };
    Geometry2.prototype.init = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(this.data);
      this.adjustScale();
    };
    Geometry2.prototype.update = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var data3 = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
      var _a6 = this, attributeOption = _a6.attributeOption, lastAttributeOption = _a6.lastAttributeOption;
      if (!is_equal_default(attributeOption, lastAttributeOption)) {
        this.init(cfg);
      } else if (data3 && (isDataChanged || !is_equal_default(data3, this.data))) {
        this.setCfg(cfg);
        this.initAttributes();
        this.processData(data3);
      } else {
        this.setCfg(cfg);
      }
      this.adjustScale();
      this.isCoordinateChanged = isCoordinateChanged;
    };
    Geometry2.prototype.paint = function(isUpdate) {
      var _this = this;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      if (this.animateOption) {
        this.animateOption = deep_mix_default({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
      }
      this.defaultSize = void 0;
      this.elementsMap = {};
      this.elements = [];
      var offscreenGroup = this.getOffscreenGroup();
      offscreenGroup.clear();
      var beforeMappingData = this.beforeMappingData;
      var dataArray = this.beforeMapping(beforeMappingData);
      this.dataArray = new Array(dataArray.length);
      for (var i = 0; i < dataArray.length; i++) {
        var data3 = dataArray[i];
        this.dataArray[i] = this.mapping(data3);
      }
      this.updateElements(this.dataArray, isUpdate);
      this.lastElementsMap = this.elementsMap;
      if (this.canDoGroupAnimation(isUpdate)) {
        var container = this.container;
        var type = this.type;
        var coordinate11 = this.coordinate;
        var animateCfg = get_default(this.animateOption, "appear");
        var yScale = this.getYScale();
        var yMinPoint = coordinate11.convert({
          x: 0,
          y: yScale.scale(this.getYMinValue())
        });
        doGroupAppearAnimate(container, animateCfg, type, coordinate11, yMinPoint);
      }
      if (this.labelOption) {
        var deferred = this.useDeferredLabel;
        var callback = function() {
          return _this.renderLabels(flatten_default(_this.dataArray), isUpdate);
        }.bind(this);
        if (typeof deferred === "number") {
          var timeout2 = typeof deferred === "number" && deferred !== Infinity ? deferred : 0;
          if (!window.requestIdleCallback) {
            setTimeout(callback, timeout2);
          } else {
            var options = timeout2 && timeout2 !== Infinity ? { timeout: timeout2 } : void 0;
            window.requestIdleCallback(callback, options);
          }
        } else {
          callback();
        }
      }
      this.lastAttributeOption = __assign({}, this.attributeOption);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Geometry2.prototype.clear = function() {
      var _a6 = this, container = _a6.container, geometryLabel = _a6.geometryLabel, offscreenGroup = _a6.offscreenGroup;
      if (container) {
        container.clear();
      }
      if (geometryLabel) {
        geometryLabel.clear();
      }
      if (offscreenGroup) {
        offscreenGroup.clear();
      }
      this.scaleDefs = void 0;
      this.attributes = {};
      this.scales = {};
      this.elementsMap = {};
      this.lastElementsMap = {};
      this.elements = [];
      this.adjusts = {};
      this.dataArray = null;
      this.beforeMappingData = null;
      this.lastAttributeOption = void 0;
      this.defaultSize = void 0;
      this.idFields = [];
      this.groupScales = void 0;
      this.hasSorted = false;
      this.isCoordinateChanged = false;
    };
    Geometry2.prototype.destroy = function() {
      this.clear();
      var container = this.container;
      container.remove(true);
      if (this.offscreenGroup) {
        this.offscreenGroup.remove(true);
        this.offscreenGroup = null;
      }
      if (this.geometryLabel) {
        this.geometryLabel.destroy();
        this.geometryLabel = null;
      }
      this.theme = void 0;
      this.shapeFactory = void 0;
      _super.prototype.destroy.call(this);
    };
    Geometry2.prototype.getGroupScales = function() {
      return this.groupScales;
    };
    Geometry2.prototype.getAttribute = function(name) {
      return this.attributes[name];
    };
    Geometry2.prototype.getXScale = function() {
      return this.getAttribute("position").scales[0];
    };
    Geometry2.prototype.getYScale = function() {
      return this.getAttribute("position").scales[1];
    };
    Geometry2.prototype.getGroupAttributes = function() {
      var rst = [];
      each_default(this.attributes, function(attr) {
        if (GROUP_ATTRS.includes(attr.type)) {
          rst.push(attr);
        }
      });
      return rst;
    };
    Geometry2.prototype.getDefaultValue = function(attrName) {
      var value2;
      var attr = this.getAttribute(attrName);
      if (attr && is_empty_default(attr.scales)) {
        value2 = attr.values[0];
      }
      return value2;
    };
    Geometry2.prototype.getAttributeValues = function(attr, obj) {
      var params = [];
      var scales = attr.scales;
      for (var index = 0, length_1 = scales.length; index < length_1; index++) {
        var scale8 = scales[index];
        var field6 = scale8.field;
        if (scale8.isIdentity) {
          params.push(scale8.values);
        } else {
          params.push(obj[field6]);
        }
      }
      return attr.mapping.apply(attr, __spreadArray([], __read(params), false));
    };
    Geometry2.prototype.getAdjust = function(adjustType) {
      return this.adjusts[adjustType];
    };
    Geometry2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    Geometry2.prototype.getData = function() {
      return this.data;
    };
    Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
      var shapeFactory = this.getShapeFactory();
      return shapeFactory.getMarker(shapeName, cfg);
    };
    Geometry2.prototype.getElementsBy = function(condition) {
      return this.elements.filter(function(element) {
        return condition(element);
      });
    };
    Geometry2.prototype.getElements = function() {
      return this.elements;
    };
    Geometry2.prototype.getElementId = function(data3) {
      data3 = is_array_default(data3) ? data3[0] : data3;
      var originData = data3[FIELD_ORIGIN];
      if (this.idFields.length) {
        var elementId = originData[this.idFields[0]];
        for (var index = 1; index < this.idFields.length; index++) {
          elementId += "-" + originData[this.idFields[index]];
        }
        return elementId;
      }
      var type = this.type;
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field || "x";
      var yField = yScale.field || "y";
      var yVal = originData[yField];
      var xVal;
      if (xScale.type === "identity") {
        xVal = xScale.values[0];
      } else {
        xVal = originData[xField];
      }
      var id;
      if (type === "interval" || type === "schema") {
        id = "".concat(xVal);
      } else if (type === "line" || type === "area" || type === "path") {
        id = type;
      } else {
        id = "".concat(xVal, "-").concat(yVal);
      }
      var groupScales = this.groupScales;
      for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
        var groupScale = groupScales[index];
        var field6 = groupScale.field;
        id = "".concat(id, "-").concat(originData[field6]);
      }
      var dodgeAdjust = this.getAdjust("dodge");
      if (dodgeAdjust) {
        var dodgeBy = dodgeAdjust.dodgeBy;
        if (dodgeBy) {
          id = "".concat(id, "-").concat(originData[dodgeBy]);
        }
      }
      if (this.getAdjust("jitter")) {
        id = "".concat(id, "-").concat(data3.x, "-").concat(data3.y);
      }
      return id;
    };
    Geometry2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var _a6 = this, attributeOption = _a6.attributeOption, labelOption = _a6.labelOption, tooltipOption = _a6.tooltipOption;
      for (var attributeType in attributeOption) {
        if (attributeOption.hasOwnProperty(attributeType)) {
          var eachOpt = attributeOption[attributeType];
          if (eachOpt.fields) {
            uniq2(eachOpt.fields, fields, tmpMap);
          } else if (eachOpt.values) {
            uniq2(eachOpt.values, fields, tmpMap);
          }
        }
      }
      if (labelOption && labelOption.fields) {
        uniq2(labelOption.fields, fields, tmpMap);
      }
      if (is_object_default(tooltipOption) && tooltipOption.fields) {
        uniq2(tooltipOption.fields, fields, tmpMap);
      }
      return fields;
    };
    Geometry2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var elements = this.elements;
      for (var index = 0, length_3 = elements.length; index < length_3; index++) {
        var element = elements[index];
        element.changeVisible(visible);
      }
      if (visible) {
        if (this.container) {
          this.container.show();
        }
        if (this.labelsContainer) {
          this.labelsContainer.show();
        }
      } else {
        if (this.container) {
          this.container.hide();
        }
        if (this.labelsContainer) {
          this.labelsContainer.hide();
        }
      }
    };
    Geometry2.prototype.getFields = function() {
      var uniqMap = /* @__PURE__ */ new Map();
      var fields = [];
      Object.values(this.attributeOption).forEach(function(cfg) {
        var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
        fs.forEach(function(f) {
          if (!uniqMap.has(f)) {
            fields.push(f);
          }
          uniqMap.set(f, true);
        });
      }, []);
      return fields;
    };
    Geometry2.prototype.getGroupFields = function() {
      var groupFields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
        var attributeName = GROUP_ATTRS[index];
        var cfg = this.attributeOption[attributeName];
        if (cfg && cfg.fields) {
          uniq2(cfg.fields, groupFields, tmpMap);
        }
      }
      return groupFields;
    };
    Geometry2.prototype.getXYFields = function() {
      var _a6 = __read(this.attributeOption.position.fields, 2), x = _a6[0], y = _a6[1];
      return [x, y];
    };
    Geometry2.prototype.getXField = function() {
      return get_default(this.getXYFields(), [0]);
    };
    Geometry2.prototype.getYField = function() {
      return get_default(this.getXYFields(), [1]);
    };
    Geometry2.prototype.getShapes = function() {
      return this.elements.map(function(element) {
        return element.shape;
      });
    };
    Geometry2.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Geometry2.prototype.sort = function(mappingArray) {
      if (!this.hasSorted) {
        var xScale_1 = this.getXScale();
        var xField_1 = xScale_1.field;
        for (var index = 0; index < mappingArray.length; index++) {
          var itemArr = mappingArray[index];
          itemArr.sort(function(obj1, obj2) {
            return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
          });
        }
      }
      this.hasSorted = true;
    };
    Geometry2.prototype.adjustScale = function() {
      var yScale = this.getYScale();
      if (yScale && this.getAdjust("stack")) {
        this.updateStackRange(yScale, this.beforeMappingData);
      }
    };
    Geometry2.prototype.getShapeFactory = function() {
      var shapeType = this.shapeType;
      if (!getShapeFactory(shapeType)) {
        return;
      }
      if (!this.shapeFactory) {
        this.shapeFactory = clone_default(getShapeFactory(shapeType));
      }
      this.shapeFactory.coordinate = this.coordinate;
      this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
      return this.shapeFactory;
    };
    Geometry2.prototype.createShapePointsCfg = function(obj) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var x = this.normalizeValues(obj[xScale.field], xScale);
      var y;
      if (yScale) {
        y = this.normalizeValues(obj[yScale.field], yScale);
      } else {
        y = obj.y ? obj.y : 0.1;
      }
      return {
        x,
        y,
        y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
      };
    };
    Geometry2.prototype.createElement = function(mappingDatum, index, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var container = this.container;
      var shapeCfg = this.getDrawCfg(mappingDatum);
      var shapeFactory = this.getShapeFactory();
      var element = new element_default2({
        shapeFactory,
        container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: index
      });
      element.animate = this.animateOption;
      element.geometry = this;
      element.draw(shapeCfg, isUpdate);
      return element;
    };
    Geometry2.prototype.getDrawCfg = function(mappingDatum) {
      var originData = mappingDatum[FIELD_ORIGIN];
      var cfg = {
        mappingData: mappingDatum,
        data: originData,
        x: mappingDatum.x,
        y: mappingDatum.y,
        color: mappingDatum.color,
        size: mappingDatum.size,
        isInCircle: this.coordinate.isPolar,
        customInfo: this.customOption
      };
      var shapeName = mappingDatum.shape;
      if (!shapeName && this.getShapeFactory()) {
        shapeName = this.getShapeFactory().defaultShapeType;
      }
      cfg.shape = shapeName;
      var theme4 = this.theme.geometries[this.shapeType];
      cfg.defaultStyle = get_default(theme4, [shapeName, "default"], {}).style;
      if (!cfg.defaultStyle && this.getShapeFactory()) {
        cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme4);
      }
      var styleOption = this.styleOption;
      if (styleOption) {
        cfg.style = this.getStyleCfg(styleOption, originData);
      }
      if (this.generatePoints) {
        cfg.points = mappingDatum.points;
        cfg.nextPoints = mappingDatum.nextPoints;
      }
      return cfg;
    };
    Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      var e_1, _a6, e_2, _b, e_3, _c;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyDatum = /* @__PURE__ */ new Map();
      var keys3 = [];
      var keyIndex = /* @__PURE__ */ new Map();
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        for (var j = 0; j < mappingData.length; j++) {
          var mappingDatum = mappingData[j];
          var key = this.getElementId(mappingDatum);
          var finalKey = keyDatum.has(key) ? "".concat(key, "-").concat(i, "-").concat(j) : key;
          keys3.push(finalKey);
          keyDatum.set(finalKey, mappingDatum);
          keyIndex.set(finalKey, index);
          index++;
        }
      }
      this.elements = new Array(index);
      var _d = diff(this.lastElementsMap, keys3), added = _d.added, updated = _d.updated, removed = _d.removed;
      try {
        for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
          var key = added_1_1.value;
          var mappingDatum = keyDatum.get(key);
          var i = keyIndex.get(key);
          var element = this.createElement(mappingDatum, i, isUpdate);
          this.elements[i] = element;
          this.elementsMap[key] = element;
          if (element.shape) {
            element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (added_1_1 && !added_1_1.done && (_a6 = added_1.return))
            _a6.call(added_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
          var key = updated_1_1.value;
          var element = this.lastElementsMap[key];
          var mappingDatum = keyDatum.get(key);
          var currentShapeCfg = this.getDrawCfg(mappingDatum);
          var preShapeCfg = element.getModel();
          var i = keyIndex.get(key);
          if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
            element.animate = this.animateOption;
            element.update(currentShapeCfg);
          }
          this.elements[i] = element;
          this.elementsMap[key] = element;
          if (element.shape) {
            element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
            _b.call(updated_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      if (this.container) {
        this.container.sort();
      }
      try {
        for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
          var key = removed_1_1.value;
          var element = this.lastElementsMap[key];
          element.animate = this.animateOption;
          element.destroy();
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
            _c.call(removed_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    Geometry2.prototype.getLabelType = function() {
      var _a6 = this, labelOption = _a6.labelOption, coordinate11 = _a6.coordinate, type = _a6.type;
      var coordinateType = coordinate11.type, isTransposed = coordinate11.isTransposed;
      var labelType = get_default(labelOption, ["cfg", "type"]);
      if (!labelType) {
        if (coordinateType === "polar") {
          labelType = isTransposed ? "pie" : "polar";
        } else if (coordinateType === "theta") {
          labelType = "pie";
        } else if (type === "interval" || type === "polygon") {
          labelType = "interval";
        } else {
          labelType = "base";
        }
      }
      return labelType;
    };
    Geometry2.prototype.getYMinValue = function() {
      var yScale = this.getYScale();
      var min5 = yScale.min, max5 = yScale.max;
      var value2;
      if (min5 >= 0) {
        value2 = min5;
      } else if (max5 <= 0) {
        value2 = max5;
      } else {
        value2 = 0;
      }
      return value2;
    };
    Geometry2.prototype.createAttrOption = function(attrName, field6, cfg) {
      if (is_nil_default(field6) || is_object_default(field6)) {
        if (is_object_default(field6) && is_equal_default(Object.keys(field6), ["values"])) {
          set_default(this.attributeOption, attrName, {
            fields: field6.values
          });
        } else {
          set_default(this.attributeOption, attrName, field6);
        }
      } else {
        var attrCfg = {};
        if (is_number_default(field6)) {
          attrCfg.values = [field6];
        } else {
          attrCfg.fields = parseFields(field6);
        }
        if (cfg) {
          if (is_function_default(cfg)) {
            attrCfg.callback = cfg;
          } else {
            attrCfg.values = cfg;
          }
        }
        set_default(this.attributeOption, attrName, attrCfg);
      }
    };
    Geometry2.prototype.initAttributes = function() {
      var _this = this;
      var _a6 = this, attributes = _a6.attributes, attributeOption = _a6.attributeOption, theme4 = _a6.theme, shapeType = _a6.shapeType;
      this.groupScales = [];
      var tmpMap = {};
      var _loop_1 = function(attrType2) {
        if (attributeOption.hasOwnProperty(attrType2)) {
          var option = attributeOption[attrType2];
          if (!option) {
            return { value: void 0 };
          }
          var attrCfg = __assign({}, option);
          var callback = attrCfg.callback, values3 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
          var scales = fields.map(function(field6) {
            var scale8 = _this.scales[field6];
            if (!tmpMap[field6] && GROUP_ATTRS.includes(attrType2)) {
              var inferedScaleType = inferScaleType(scale8, get_default(_this.scaleDefs, field6), attrType2, _this.type);
              if (inferedScaleType === "cat") {
                _this.groupScales.push(scale8);
                tmpMap[field6] = true;
              }
            }
            return scale8;
          });
          attrCfg.scales = scales;
          if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
            attrCfg.values = scales[0].values;
          } else if (!callback && !values3) {
            if (attrType2 === "size") {
              attrCfg.values = theme4.sizes;
            } else if (attrType2 === "shape") {
              attrCfg.values = theme4.shapes[shapeType] || [];
            } else if (attrType2 === "color") {
              if (scales.length) {
                attrCfg.values = scales[0].values.length <= 10 ? theme4.colors10 : theme4.colors20;
              } else {
                attrCfg.values = theme4.colors10;
              }
            }
          }
          var AttributeCtor = getAttribute(attrType2);
          attributes[attrType2] = new AttributeCtor(attrCfg);
        }
      };
      for (var attrType in attributeOption) {
        var state_1 = _loop_1(attrType);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    };
    Geometry2.prototype.processData = function(data3) {
      var e_4, _a6;
      this.hasSorted = false;
      var scales = this.getAttribute("position").scales;
      var categoryScales = scales.filter(function(scale9) {
        return scale9.isCategory;
      });
      var groupedArray = this.groupData(data3);
      var beforeAdjust = [];
      for (var i = 0, len3 = groupedArray.length; i < len3; i++) {
        var subData = groupedArray[i];
        var arr = [];
        for (var j = 0, subLen = subData.length; j < subLen; j++) {
          var originData = subData[j];
          var item = {};
          for (var k in originData) {
            item[k] = originData[k];
          }
          item[FIELD_ORIGIN] = originData;
          try {
            for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
              var scale8 = categoryScales_1_1.value;
              var field6 = scale8.field;
              item[field6] = scale8.translate(item[field6]);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (categoryScales_1_1 && !categoryScales_1_1.done && (_a6 = categoryScales_1.return))
                _a6.call(categoryScales_1);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          arr.push(item);
        }
        beforeAdjust.push(arr);
      }
      var dataArray = this.adjustData(beforeAdjust);
      this.beforeMappingData = dataArray;
      return dataArray;
    };
    Geometry2.prototype.adjustData = function(dataArray) {
      var adjustOption = this.adjustOption;
      var _a6 = this, intervalPadding = _a6.intervalPadding, dodgePadding = _a6.dodgePadding, theme4 = _a6.theme;
      var maxColumnWidth = this.maxColumnWidth || theme4.maxColumnWidth;
      var minColumnWidth = this.minColumnWidth || theme4.minColumnWidth;
      var columnWidthRatio = this.columnWidthRatio || theme4.columnWidthRatio;
      var result2 = dataArray;
      if (adjustOption) {
        var xScale_2 = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale_2.field;
        var yField = yScale ? yScale.field : null;
        var xDimensionLength = getXDimensionLength(this.coordinate);
        var groupNum = xScale_2.values.length;
        var sizeAttr = this.getAttribute("size");
        var defaultSize = void 0;
        if (sizeAttr) {
          defaultSize = sizeAttr.values[0];
        }
        for (var i = 0, len3 = adjustOption.length; i < len3; i++) {
          var adjust3 = adjustOption[i];
          var adjustCfg2 = __assign({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust3);
          var type = adjust3.type;
          if (type === "dodge") {
            var adjustNames = [];
            if (xScale_2.isCategory || xScale_2.type === "identity") {
              adjustNames.push("x");
            } else if (!yScale) {
              adjustNames.push("y");
            } else {
              throw new Error("dodge is not support linear attribute, please use category attribute!");
            }
            adjustCfg2.adjustNames = adjustNames;
            adjustCfg2.dodgeRatio = columnWidthRatio;
          } else if (type === "stack") {
            var coordinate11 = this.coordinate;
            if (!yScale) {
              adjustCfg2.height = coordinate11.getHeight();
              var size3 = this.getDefaultValue("size") || 3;
              adjustCfg2.size = size3;
            }
            if (!coordinate11.isTransposed && is_nil_default(adjustCfg2.reverseOrder)) {
              adjustCfg2.reverseOrder = true;
            }
          }
          var adjustCtor = getAdjust(type);
          adjustCfg2.dimValuesMap = {};
          if (xScale_2 && xScale_2.values) {
            adjustCfg2.dimValuesMap[xScale_2.field] = xScale_2.values.map(function(v) {
              return xScale_2.translate(v);
            });
          }
          var adjustInstance = new adjustCtor(adjustCfg2);
          result2 = adjustInstance.process(result2);
          this.adjusts[type] = adjustInstance;
        }
      }
      return result2;
    };
    Geometry2.prototype.groupData = function(data3) {
      var groupScales = this.getGroupScales();
      var scaleDefs = this.scaleDefs;
      var appendConditions = {};
      var groupFields = [];
      for (var index = 0; index < groupScales.length; index++) {
        var scale8 = groupScales[index];
        var field6 = scale8.field;
        groupFields.push(field6);
        if (get_default(scaleDefs, [field6, "values"])) {
          appendConditions[field6] = scaleDefs[field6].values;
        }
      }
      return group(data3, groupFields, appendConditions);
    };
    Geometry2.prototype.updateStackRange = function(scale8, dataArray) {
      var mergeArray = flatten_default(dataArray);
      var field6 = scale8.field;
      var min5 = scale8.min;
      var max5 = scale8.max;
      for (var index = 0; index < mergeArray.length; index++) {
        var obj = mergeArray[index];
        var tmpMin = Math.min.apply(null, obj[field6]);
        var tmpMax = Math.max.apply(null, obj[field6]);
        if (tmpMin < min5) {
          min5 = tmpMin;
        }
        if (tmpMax > max5) {
          max5 = tmpMax;
        }
      }
      var scaleDefs = this.scaleDefs;
      var cfg = {};
      if (min5 < scale8.min && !get_default(scaleDefs, [field6, "min"])) {
        cfg.min = min5;
      }
      if (max5 > scale8.max && !get_default(scaleDefs, [field6, "max"])) {
        cfg.max = max5;
      }
      scale8.change(cfg);
    };
    Geometry2.prototype.beforeMapping = function(beforeMappingData) {
      var source = beforeMappingData;
      if (this.sortable) {
        this.sort(source);
      }
      if (this.generatePoints) {
        for (var index = 0, length_5 = source.length; index < length_5; index++) {
          var currentData = source[index];
          this.generateShapePoints(currentData);
          var nextData = source[index + 1];
          if (nextData) {
            this.generateShapePoints(nextData);
            currentData[0].nextPoints = nextData[0].points;
          }
        }
      }
      return source;
    };
    Geometry2.prototype.generateShapePoints = function(data3) {
      var shapeFactory = this.getShapeFactory();
      var shapeAttr = this.getAttribute("shape");
      for (var index = 0; index < data3.length; index++) {
        var obj = data3[index];
        var cfg = this.createShapePointsCfg(obj);
        var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
        var points2 = shapeFactory.getShapePoints(shape, cfg);
        obj.points = points2;
      }
    };
    Geometry2.prototype.normalizeValues = function(values3, scale8) {
      var rst = [];
      if (is_array_default(values3)) {
        for (var index = 0; index < values3.length; index++) {
          var value2 = values3[index];
          rst.push(scale8.scale(value2));
        }
      } else {
        rst = scale8.scale(values3);
      }
      return rst;
    };
    Geometry2.prototype.mapping = function(data3) {
      var attributes = this.attributes;
      var mappingData = [];
      for (var index = 0; index < data3.length; index++) {
        var record = data3[index];
        var newRecord = {
          _origin: record[FIELD_ORIGIN],
          points: record.points,
          nextPoints: record.nextPoints
        };
        for (var k in attributes) {
          if (attributes.hasOwnProperty(k)) {
            var attr = attributes[k];
            var names = attr.names;
            var values3 = this.getAttributeValues(attr, record);
            if (names.length > 1) {
              for (var j = 0; j < values3.length; j += 1) {
                var val = values3[j];
                var name_1 = names[j];
                newRecord[name_1] = is_array_default(val) && val.length === 1 ? val[0] : val;
              }
            } else {
              newRecord[names[0]] = values3.length === 1 ? values3[0] : values3;
            }
          }
        }
        this.convertPoint(newRecord);
        mappingData.push(newRecord);
      }
      return mappingData;
    };
    Geometry2.prototype.convertPoint = function(mappingRecord) {
      var x = mappingRecord.x, y = mappingRecord.y;
      var rstX;
      var rstY;
      var obj;
      var coordinate11 = this.coordinate;
      if (is_array_default(x) && is_array_default(y)) {
        rstX = [];
        rstY = [];
        for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
          obj = coordinate11.convert({
            x: x[i],
            y: y[j]
          });
          rstX.push(obj.x);
          rstY.push(obj.y);
        }
      } else if (is_array_default(y)) {
        rstY = [];
        for (var index = 0; index < y.length; index++) {
          var yVal = y[index];
          obj = coordinate11.convert({
            x,
            y: yVal
          });
          if (rstX && rstX !== obj.x) {
            if (!is_array_default(rstX)) {
              rstX = [rstX];
            }
            rstX.push(obj.x);
          } else {
            rstX = obj.x;
          }
          rstY.push(obj.y);
        }
      } else if (is_array_default(x)) {
        rstX = [];
        for (var index = 0; index < x.length; index++) {
          var xVal = x[index];
          obj = coordinate11.convert({
            x: xVal,
            y
          });
          if (rstY && rstY !== obj.y) {
            if (!is_array_default(rstY)) {
              rstY = [rstY];
            }
            rstY.push(obj.y);
          } else {
            rstY = obj.y;
          }
          rstX.push(obj.x);
        }
      } else {
        var point2 = coordinate11.convert({
          x,
          y
        });
        rstX = point2.x;
        rstY = point2.y;
      }
      mappingRecord.x = rstX;
      mappingRecord.y = rstY;
    };
    Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
      var _a6 = styleOption.fields, fields = _a6 === void 0 ? [] : _a6, callback = styleOption.callback, cfg = styleOption.cfg;
      if (cfg) {
        return cfg;
      }
      var params = fields.map(function(field6) {
        return originData[field6];
      });
      return callback.apply(void 0, __spreadArray([], __read(params), false));
    };
    Geometry2.prototype.setCfg = function(cfg) {
      var _this = this;
      var coordinate11 = cfg.coordinate, data3 = cfg.data, theme4 = cfg.theme, scaleDefs = cfg.scaleDefs;
      if (coordinate11) {
        this.coordinate = coordinate11;
      }
      if (data3) {
        this.data = data3;
      }
      if (scaleDefs) {
        this.scaleDefs = scaleDefs;
        this.idFields = [];
        each_default(scaleDefs, function(scaleDef, field6) {
          if (scaleDef && scaleDef.key) {
            _this.idFields.push(field6);
          }
        });
      }
      if (theme4) {
        this.theme = this.userTheme ? deep_mix_default({}, theme4, this.userTheme) : theme4;
      }
    };
    Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a6, _b, _c, element, labels;
        var e_5, _d;
        var _this = this;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              geometryLabel = this.geometryLabel;
              this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
              if (!geometryLabel) {
                labelType = this.getLabelType();
                GeometryLabelsCtor = getGeometryLabel(labelType);
                geometryLabel = new GeometryLabelsCtor(this);
                this.geometryLabel = geometryLabel;
              }
              return [4, geometryLabel.render(mappingArray, isUpdate)];
            case 1:
              _e.sent();
              labelsMap = geometryLabel.labelsRenderer.shapesMap;
              elementLabels = /* @__PURE__ */ new Map();
              each_default(labelsMap, function(labelGroup, labelGroupId) {
                var labelChildren = labelGroup.getChildren() || [];
                for (var j = 0; j < labelChildren.length; j++) {
                  var labelShape = labelChildren[j];
                  var element2 = _this.elementsMap[labelShape.get("elementId") || labelGroupId.split(" ")[0]];
                  if (element2) {
                    labelShape.cfg.name = ["element", "label"];
                    labelShape.cfg.element = element2;
                    var labels2 = elementLabels.get(element2) || /* @__PURE__ */ new Set();
                    labels2.add(labelGroup);
                    elementLabels.set(element2, labels2);
                  }
                }
              });
              try {
                for (_a6 = __values(elementLabels.entries()), _b = _a6.next(); !_b.done; _b = _a6.next()) {
                  _c = __read(_b.value, 2), element = _c[0], labels = _c[1];
                  element.labelShape = __spreadArray([], __read(labels), false);
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (_b && !_b.done && (_d = _a6.return))
                    _d.call(_a6);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
              }
              this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
      return !isUpdate && this.animateOption && (get_default(this.animateOption, "appear") === void 0 || get_default(this.animateOption, "appear") && get_default(this.animateOption, ["appear", "animation"]) === void 0);
    };
    return Geometry2;
  }(base_default)
);
var base_default13 = Geometry;

// node_modules/@antv/g2/esm/util/transform.js
var transform3 = ext_exports.transform;
function translate2(element, x, y) {
  var matrix = transform3(element.getMatrix(), [["t", x, y]]);
  element.setMatrix(matrix);
}
function getRotateMatrix(element, rotateRadian) {
  var _a6 = element.attr(), x = _a6.x, y = _a6.y;
  var matrix = transform3(element.getMatrix(), [
    ["t", -x, -y],
    ["r", rotateRadian],
    ["t", x, y]
  ]);
  return matrix;
}
function rotate4(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform3(element.getMatrix(), [
    ["t", -x, -y],
    ["s", ratio, ratio],
    ["t", x, y]
  ]);
  element.setMatrix(matrix);
}

// node_modules/@antv/g2/esm/geometry/label/util/index.js
function findLabelTextShape(label17) {
  return label17.find(function(el) {
    return el.get("type") === "text";
  });
}
function getLabelBackgroundInfo(labelGroup, labelItem, padding3) {
  if (padding3 === void 0) {
    padding3 = [0, 0, 0, 0];
  }
  var content = labelGroup && labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      rotate4(labelShape, -labelItem.rotate);
    }
    var _a6 = labelShape.getCanvasBBox(), x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
    labelShape.destroy();
    var boxPadding = padding3;
    if (is_nil_default(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (is_number_default(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
}
function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap(cur, dones) {
  var box2 = cur.getBBox();
  return some_default(dones, function(done) {
    var target = done.getBBox();
    return getOverlapArea(box2, target, 2) > 0;
  });
}

// node_modules/@antv/g2/esm/component/update-label.js
function updateLabel(fromShape, toShape, cfg) {
  var data3 = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate11 = cfg.coordinate;
  var updateAnimateCfg = get_default(animateCfg, "update");
  fromShape.set("data", data3);
  fromShape.set("origin", origin);
  fromShape.set("animateCfg", animateCfg);
  fromShape.set("coordinate", coordinate11);
  fromShape.set("visible", toShape.get("visible"));
  (fromShape.getChildren() || []).forEach(function(fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);
    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set("data", data3);
      fromChild.set("origin", origin);
      fromChild.set("animateCfg", animateCfg);
      fromChild.set("coordinate", coordinate11);
      var newAttrs = getReplaceAttrs(fromChild, toChild);
      if (updateAnimateCfg) {
        doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate: coordinate11
        });
      } else {
        fromChild.attr(newAttrs);
      }
      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  });
  each_default(toShape.getChildren(), function(child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}

// node_modules/@antv/g2/esm/component/labels.js
var Labels = (
  /** @class */
  function() {
    function Labels2(cfg) {
      this.shapesMap = {};
      var layout2 = cfg.layout, container = cfg.container;
      this.layout = layout2;
      this.container = container;
    }
    Labels2.prototype.render = function(items, shapes, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
        var e_1, _a6;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              shapesMap = {};
              offscreenGroup = this.createOffscreenGroup();
              if (!items.length)
                return [3, 2];
              try {
                for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                  item = items_1_1.value;
                  if (item) {
                    shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (items_1_1 && !items_1_1.done && (_a6 = items_1.return))
                    _a6.call(items_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              return [4, this.doLayout(items, shapes, shapesMap)];
            case 1:
              _b.sent();
              this.renderLabelLine(items, shapesMap);
              this.renderLabelBackground(items, shapesMap);
              this.adjustLabel(items, shapesMap);
              _b.label = 2;
            case 2:
              lastShapesMap = this.shapesMap;
              each_default(shapesMap, function(shape, id) {
                if (shape.destroyed) {
                  delete shapesMap[id];
                } else {
                  if (lastShapesMap[id]) {
                    var data3 = shape.get("data");
                    var origin_1 = shape.get("origin");
                    var coordinate11 = shape.get("coordinate");
                    var currentAnimateCfg = shape.get("animateCfg");
                    var currentShape = lastShapesMap[id];
                    updateLabel(currentShape, shapesMap[id], {
                      data: data3,
                      origin: origin_1,
                      animateCfg: currentAnimateCfg,
                      coordinate: coordinate11
                    });
                    shapesMap[id] = currentShape;
                  } else {
                    if (_this.container.destroyed)
                      return;
                    _this.container.add(shape);
                    var animateCfg = get_default(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
                    if (animateCfg) {
                      doAnimate(shape, animateCfg, {
                        toAttrs: __assign({}, shape.attr()),
                        coordinate: shape.get("coordinate")
                      });
                    }
                  }
                  delete lastShapesMap[id];
                }
              });
              each_default(lastShapesMap, function(deleteShape) {
                var animateCfg = get_default(deleteShape.get("animateCfg"), "leave");
                if (animateCfg) {
                  doAnimate(deleteShape, animateCfg, {
                    toAttrs: null,
                    coordinate: deleteShape.get("coordinate")
                  });
                } else {
                  deleteShape.remove(true);
                }
              });
              this.shapesMap = shapesMap;
              offscreenGroup.destroy();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Labels2.prototype.clear = function() {
      this.container.clear();
      this.shapesMap = {};
    };
    Labels2.prototype.destroy = function() {
      this.container.destroy();
      this.shapesMap = null;
    };
    Labels2.prototype.renderLabel = function(cfg, container) {
      var id = cfg.id, elementId = cfg.elementId, data3 = cfg.data, mappingData = cfg.mappingData, coordinate11 = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
      var shapeAppendCfg = {
        id,
        elementId,
        capture,
        data: data3,
        origin: __assign(__assign({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
        coordinate: coordinate11
      };
      var labelGroup = container.addGroup(__assign({
        name: "label",
        //  this.animate === false  cfg.animate === false/null 
        animateCfg: this.animate === false || animate === null || animate === false ? false : deep_mix_default({}, this.animate, animate)
      }, shapeAppendCfg));
      var labelShape;
      if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
        var _a6 = content.getCanvasBBox(), width = _a6.width, height = _a6.height;
        var textAlign = get_default(cfg, "textAlign", "left");
        var x = cfg.x;
        var y = cfg.y - height / 2;
        if (textAlign === "center") {
          x = x - width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          x = x - width;
        }
        translate2(content, x, y);
        labelShape = content;
        labelGroup.add(content);
      } else {
        var fill2 = get_default(cfg, ["style", "fill"]);
        labelShape = labelGroup.addShape("text", __assign({ attrs: __assign(__assign({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get_default(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: is_null_default(fill2) ? cfg.color : fill2 }) }, shapeAppendCfg));
      }
      if (cfg.rotate) {
        rotate4(labelShape, cfg.rotate);
      }
      return labelGroup;
    };
    Labels2.prototype.doLayout = function(items, shapes, shapesMap) {
      return __awaiter(this, void 0, void 0, function() {
        var layouts;
        var _this = this;
        return __generator(this, function(_a6) {
          switch (_a6.label) {
            case 0:
              if (!this.layout)
                return [3, 2];
              layouts = is_array_default(this.layout) ? this.layout : [this.layout];
              return [4, Promise.all(layouts.map(function(layout2) {
                var layoutFn = getGeometryLabelLayout(get_default(layout2, "type", ""));
                if (!layoutFn)
                  return;
                var labelShapes = [];
                var geometryShapes = [];
                each_default(shapesMap, function(labelShape, id) {
                  labelShapes.push(labelShape);
                  geometryShapes.push(shapes[labelShape.get("elementId")]);
                });
                return layoutFn(items, labelShapes, geometryShapes, _this.region, layout2.cfg);
              }))];
            case 1:
              _a6.sent();
              _a6.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Labels2.prototype.renderLabelLine = function(labelItems, shapesMap) {
      each_default(labelItems, function(labelItem) {
        var coordinate11 = get_default(labelItem, "coordinate");
        if (!labelItem || !coordinate11) {
          return;
        }
        var center2 = coordinate11.getCenter();
        var radius = coordinate11.getRadius();
        if (!labelItem.labelLine) {
          return;
        }
        var labelLineCfg = get_default(labelItem, "labelLine", {});
        var id = labelItem.id;
        var path = labelLineCfg.path;
        if (!path) {
          var start = polarToCartesian(center2.x, center2.y, radius, labelItem.angle);
          path = [
            ["M", start.x, start.y],
            ["L", labelItem.x, labelItem.y]
          ];
        }
        var labelGroup = shapesMap[id];
        if (!labelGroup.destroyed) {
          labelGroup.addShape("path", {
            capture: false,
            attrs: __assign({ path, stroke: labelItem.color ? labelItem.color : get_default(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
            id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
        }
      });
    };
    Labels2.prototype.renderLabelBackground = function(labelItems, shapesMap) {
      each_default(labelItems, function(labelItem) {
        var coordinate11 = get_default(labelItem, "coordinate");
        var background = get_default(labelItem, "background");
        if (!background || !coordinate11) {
          return;
        }
        var id = labelItem.id;
        var labelGroup = shapesMap[id];
        if (!labelGroup.destroyed) {
          var labelContentShape = labelGroup.getChildren()[0];
          if (labelContentShape) {
            var _a6 = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a6.rotation, box2 = __rest(_a6, ["rotation"]);
            var backgroundShape = labelGroup.addShape("rect", {
              attrs: __assign(__assign({}, box2), background.style || {}),
              id,
              origin: labelItem.mappingData,
              data: labelItem.data,
              coordinate: labelItem.coordinate
            });
            backgroundShape.setZIndex(-1);
            if (rotation) {
              var matrix = labelContentShape.getMatrix();
              backgroundShape.setMatrix(matrix);
            }
          }
        }
      });
    };
    Labels2.prototype.createOffscreenGroup = function() {
      var container = this.container;
      var GroupClass = container.getGroupBase();
      var newGroup = new GroupClass({});
      return newGroup;
    };
    Labels2.prototype.adjustLabel = function(items, shapesMap) {
      each_default(items, function(item) {
        if (item) {
          var id = item.id;
          var labelGroup = shapesMap[id];
          if (!labelGroup.destroyed) {
            var labelShapes = labelGroup.findAll(function(ele) {
              return ele.get("type") !== "path";
            });
            each_default(labelShapes, function(labelShape) {
              if (labelShape) {
                if (item.offsetX) {
                  labelShape.attr("x", labelShape.attr("x") + item.offsetX);
                }
                if (item.offsetY) {
                  labelShape.attr("y", labelShape.attr("y") + item.offsetY);
                }
              }
            });
          }
        }
      });
    };
    return Labels2;
  }()
);
var labels_default = Labels;

// node_modules/@antv/g2/esm/geometry/label/base.js
function avg(arr) {
  var sum2 = 0;
  each_default(arr, function(value2) {
    sum2 += value2;
  });
  return sum2 / arr.length;
}
var GeometryLabel = (
  /** @class */
  function() {
    function GeometryLabel2(geometry35) {
      this.geometry = geometry35;
    }
    GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
      var _this = this;
      var items = [];
      var labelCfgs = this.getLabelCfgs(mapppingArray);
      each_default(mapppingArray, function(mappingData, index) {
        var labelCfg = labelCfgs[index];
        if (!labelCfg || is_nil_default(mappingData.x) || is_nil_default(mappingData.y)) {
          items.push(null);
          return;
        }
        var labelContent = !is_array_default(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
        labelCfg.content = labelContent;
        var total = labelContent.length;
        each_default(labelContent, function(content, subIndex) {
          if (is_nil_default(content) || content === "") {
            items.push(null);
            return;
          }
          var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
          if (!item.textAlign) {
            item.textAlign = _this.getLabelAlign(item, subIndex, total);
          }
          if (item.offset <= 0) {
            item.labelLine = null;
          }
          items.push(item);
        });
      });
      return items;
    };
    GeometryLabel2.prototype.render = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var labelItems, labelsRenderer, shapes;
        return __generator(this, function(_a6) {
          switch (_a6.label) {
            case 0:
              labelItems = this.getLabelItems(mappingArray);
              labelsRenderer = this.getLabelsRenderer();
              shapes = this.getGeometryShapes();
              return [4, labelsRenderer.render(labelItems, shapes, isUpdate)];
            case 1:
              _a6.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    GeometryLabel2.prototype.clear = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.clear();
      }
    };
    GeometryLabel2.prototype.destroy = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.destroy();
      }
      this.labelsRenderer = null;
    };
    GeometryLabel2.prototype.getCoordinate = function() {
      return this.geometry.coordinate;
    };
    GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var geometry35 = this.geometry;
      var type = geometry35.type, theme4 = geometry35.theme;
      if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
        return get_default(theme4, "innerLabels", {});
      }
      return get_default(theme4, "labels", {});
    };
    GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry35 = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var type = geometry35.type, theme4 = geometry35.theme;
      var themedLabelCfg;
      if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme4.innerLabels, labelCfg);
      } else {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme4.labels, labelCfg);
      }
      return themedLabelCfg;
    };
    GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
    };
    GeometryLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate11 = this.getCoordinate();
      var vector = this.getOffsetVector(offset);
      return coordinate11.isTransposed ? vector[0] : vector[1];
    };
    GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total) {
      var offset = labelCfg.offset;
      var coordinate11 = this.getCoordinate();
      var transposed = coordinate11.isTransposed;
      var dim = transposed ? "x" : "y";
      var factor = transposed ? 1 : -1;
      var offsetPoint = {
        x: 0,
        y: 0
      };
      if (index > 0 || total === 1) {
        offsetPoint[dim] = offset * factor;
      } else {
        offsetPoint[dim] = offset * factor * -1;
      }
      return offsetPoint;
    };
    GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var coordinate11 = this.getCoordinate();
      var total = labelCfg.content.length;
      function getDimValue(value2, idx, isAvg) {
        if (isAvg === void 0) {
          isAvg = false;
        }
        var v = value2;
        if (is_array_default(v)) {
          if (labelCfg.content.length === 1) {
            if (isAvg) {
              v = avg(v);
            } else {
              if (v.length <= 2) {
                v = v[value2.length - 1];
              } else {
                v = avg(v);
              }
            }
          } else {
            v = v[idx];
          }
        }
        return v;
      }
      var label17 = {
        content: labelCfg.content[index],
        x: 0,
        y: 0,
        start: { x: 0, y: 0 },
        color: "#fff"
      };
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      var isFunnel = shape === "funnel" || shape === "pyramid";
      if (this.geometry.type === "polygon") {
        var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
        label17.x = centroid[0];
        label17.y = centroid[1];
      } else if (this.geometry.type === "interval" && !isFunnel) {
        label17.x = getDimValue(mappingData.x, index, true);
        label17.y = getDimValue(mappingData.y, index);
      } else {
        label17.x = getDimValue(mappingData.x, index);
        label17.y = getDimValue(mappingData.y, index);
      }
      if (isFunnel) {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points2 = get_default(mappingData, "points");
        if (nextPoints) {
          var point1 = coordinate11.convert(points2[1]);
          var point2 = coordinate11.convert(nextPoints[1]);
          label17.x = (point1.x + point2.x) / 2;
          label17.y = (point1.y + point2.y) / 2;
        } else if (shape === "pyramid") {
          var point1 = coordinate11.convert(points2[1]);
          var point2 = coordinate11.convert(points2[2]);
          label17.x = (point1.x + point2.x) / 2;
          label17.y = (point1.y + point2.y) / 2;
        }
      }
      if (labelCfg.position) {
        this.setLabelPosition(label17, mappingData, index, labelCfg.position);
      }
      var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
      label17.start = { x: label17.x, y: label17.y };
      label17.x += offsetPoint.x;
      label17.y += offsetPoint.y;
      label17.color = mappingData.color;
      return label17;
    };
    GeometryLabel2.prototype.getLabelAlign = function(item, index, total) {
      var align = "center";
      var coordinate11 = this.getCoordinate();
      if (coordinate11.isTransposed) {
        var offset = item.offset;
        if (offset < 0) {
          align = "right";
        } else if (offset === 0) {
          align = "center";
        } else {
          align = "left";
        }
        if (total > 1 && index === 0) {
          if (align === "right") {
            align = "left";
          } else if (align === "left") {
            align = "right";
          }
        }
      }
      return align;
    };
    GeometryLabel2.prototype.getLabelId = function(mappingData) {
      var geometry35 = this.geometry;
      var type = geometry35.type;
      var xScale = geometry35.getXScale();
      var yScale = geometry35.getYScale();
      var origin = mappingData[FIELD_ORIGIN];
      var labelId = geometry35.getElementId(mappingData);
      if (type === "line" || type === "area") {
        labelId += " ".concat(origin[xScale.field]);
      } else if (type === "path") {
        labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
      }
      return labelId;
    };
    GeometryLabel2.prototype.getLabelsRenderer = function() {
      var _a6 = this.geometry, labelsContainer = _a6.labelsContainer, labelOption = _a6.labelOption, canvasRegion = _a6.canvasRegion, animateOption = _a6.animateOption;
      var coordinate11 = this.geometry.coordinate;
      var labelsRenderer = this.labelsRenderer;
      if (!labelsRenderer) {
        labelsRenderer = new labels_default({
          container: labelsContainer,
          layout: get_default(labelOption, ["cfg", "layout"], {
            type: this.defaultLayout
          })
        });
        this.labelsRenderer = labelsRenderer;
      }
      labelsRenderer.region = canvasRegion;
      labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate11) : false;
      return labelsRenderer;
    };
    GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
      var _this = this;
      var geometry35 = this.geometry;
      var labelOption = geometry35.labelOption, scales = geometry35.scales, coordinate11 = geometry35.coordinate;
      var _a6 = labelOption, fields = _a6.fields, callback = _a6.callback, cfg = _a6.cfg;
      var labelScales = fields.map(function(field6) {
        return scales[field6];
      });
      var labelCfgs = [];
      each_default(mapppingArray, function(mappingData, index) {
        var origin = mappingData[FIELD_ORIGIN];
        var originText = _this.getLabelText(origin, labelScales);
        var callbackCfg;
        if (callback) {
          var originValues = fields.map(function(field6) {
            return origin[field6];
          });
          callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));
          if (is_nil_default(callbackCfg)) {
            labelCfgs.push(null);
            return;
          }
        }
        var labelCfg = __assign(__assign({
          id: _this.getLabelId(mappingData),
          elementId: _this.geometry.getElementId(mappingData),
          data: origin,
          // 
          mappingData,
          // ,
          coordinate: coordinate11
        }, cfg), callbackCfg);
        if (is_function_default(labelCfg.position)) {
          labelCfg.position = labelCfg.position(origin, mappingData, index);
        }
        var offset = _this.getLabelOffset(labelCfg.offset || 0);
        var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
        labelCfg = deep_mix_default({}, defaultLabelCfg, labelCfg);
        labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
        var content = labelCfg.content;
        if (is_function_default(content)) {
          labelCfg.content = content(origin, mappingData, index);
        } else if (is_undefined_default(content)) {
          labelCfg.content = originText[0];
        }
        labelCfgs.push(labelCfg);
      });
      return labelCfgs;
    };
    GeometryLabel2.prototype.getLabelText = function(origin, scales) {
      var labelTexts = [];
      each_default(scales, function(scale8) {
        var value2 = origin[scale8.field];
        if (is_array_default(value2)) {
          value2 = value2.map(function(subVal) {
            return scale8.getText(subVal);
          });
        } else {
          value2 = scale8.getText(value2);
        }
        if (is_nil_default(value2) || value2 === "") {
          labelTexts.push(null);
        } else {
          labelTexts.push(value2);
        }
      });
      return labelTexts;
    };
    GeometryLabel2.prototype.getOffsetVector = function(offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var coordinate11 = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      }
      return coordinate11.isTransposed ? coordinate11.applyMatrix(actualOffset, 0) : coordinate11.applyMatrix(0, actualOffset);
    };
    GeometryLabel2.prototype.getGeometryShapes = function() {
      var geometry35 = this.geometry;
      var shapes = {};
      each_default(geometry35.elementsMap, function(element, id) {
        shapes[id] = element.shape;
      });
      each_default(geometry35.getOffscreenGroup().getChildren(), function(child) {
        var id = geometry35.getElementId(child.get("origin").mappingData);
        shapes[id] = child;
      });
      return shapes;
    };
    return GeometryLabel2;
  }()
);
var base_default14 = GeometryLabel;

// node_modules/@antv/g2/esm/util/attr.js
function getMappingValue(attr, value2, def) {
  if (!attr) {
    return def;
  }
  var r;
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill("");
    r = attr.mapping.apply(attr, __spreadArray([value2], __read(restArgs), false)).join("");
  } else {
    r = attr.mapping(value2).join("");
  }
  return r || def;
}

// node_modules/@antv/g2/esm/util/marker.js
var MarkerSymbols = {
  hexagon: function(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x, y - r],
      ["L", x + diffX, y - r / 2],
      ["L", x + diffX, y + r / 2],
      ["L", x, y + r],
      ["L", x - diffX, y + r / 2],
      ["L", x - diffX, y - r / 2],
      ["Z"]
    ];
  },
  bowtie: function(x, y, r) {
    var diffY = r - 1.5;
    return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
  },
  cross: function(x, y, r) {
    return [
      ["M", x - r, y - r],
      ["L", x + r, y + r],
      ["M", x + r, y - r],
      ["L", x - r, y + r]
    ];
  },
  tick: function(x, y, r) {
    return [
      ["M", x - r / 2, y - r],
      ["L", x + r / 2, y - r],
      ["M", x, y - r],
      ["L", x, y + r],
      ["M", x - r / 2, y + r],
      ["L", x + r / 2, y + r]
    ];
  },
  plus: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y],
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  },
  hyphen: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  line: function(x, y, r) {
    return [
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  }
};

// node_modules/@antv/g2/esm/util/legend.js
var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
function handleUserMarkerStyle(markerStyle, style) {
  if (is_function_default(style)) {
    return style(markerStyle);
  }
  return deep_mix_default({}, markerStyle, style);
}
function adpatorMarkerStyle(marker, color3) {
  var symbol = marker.symbol;
  if (is_string_default(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = get_default(marker, "style", {});
    var lineWidth = get_default(markerStyle, "lineWidth", 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color3;
    marker.style = deep_mix_default({}, marker.style, { lineWidth, stroke, fill: null });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if (is_string_default(symbol) && MarkerSymbols[symbol]) {
    marker.symbol = MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction2) {
  return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
function getLegendItems(view, geometry35, attr, themeMarker, userMarker) {
  var scale8 = attr.getScale(attr.type);
  if (scale8.isCategory) {
    var field_1 = scale8.field;
    var colorAttr_1 = geometry35.getAttribute("color");
    var shapeAttr_1 = geometry35.getAttribute("shape");
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry35.coordinate.isPolar;
    return scale8.getTicks().map(function(tick, index) {
      var _a6;
      var text = tick.text, scaleValue = tick.value;
      var name = text;
      var value2 = scale8.invert(scaleValue);
      var unchecked = view.filterFieldData(field_1, [(_a6 = {}, _a6[field_1] = value2, _a6)]).length === 0;
      each_default(view.views, function(subView) {
        var _a7;
        if (!subView.filterFieldData(field_1, [(_a7 = {}, _a7[field_1] = value2, _a7)]).length) {
          unchecked = true;
        }
      });
      var color3 = getMappingValue(colorAttr_1, value2, defaultColor_1);
      var shape = getMappingValue(shapeAttr_1, value2, "point");
      var marker = geometry35.getShapeMarker(shape, {
        color: color3,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if (is_function_default(markerCfg)) {
        markerCfg = markerCfg(name, index, __assign({ name, value: value2 }, deep_mix_default({}, themeMarker, marker)));
      }
      marker = deep_mix_default({}, themeMarker, marker, omit(__assign({}, markerCfg), ["style"]));
      adpatorMarkerStyle(marker, color3);
      if (markerCfg && markerCfg.style) {
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return { id: value2, name, value: value2, marker, unchecked };
    });
  }
  return [];
}
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  return customItems.map(function(item, index) {
    var markerCfg = userMarker;
    if (is_function_default(markerCfg)) {
      markerCfg = markerCfg(item.name, index, deep_mix_default({}, themeMarker, item));
    }
    var itemMarker = is_function_default(item.marker) ? item.marker(item.name, index, deep_mix_default({}, themeMarker, item)) : item.marker;
    var marker = deep_mix_default({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
function getLegendThemeCfg(theme4, direction2) {
  var legendTheme = get_default(theme4, ["components", "legend"], {});
  return deep_mix_default({}, get_default(legendTheme, ["common"], {}), deep_mix_default({}, get_default(legendTheme, [direction2], {})));
}

// node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js
function isValueEmpty(value2) {
  if (value2) {
    return false;
  }
  return value2 === null || value2 === void 0 || isNaN(value2);
}
function isYNil(point2) {
  if (is_array_default(point2)) {
    return isValueEmpty(point2[1].y);
  }
  var value2 = point2.y;
  return is_array_default(value2) ? isValueEmpty(value2[0]) : isValueEmpty(value2);
}
function getPathPoints(points2, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points2.length || points2.length === 1 && !showSinglePoint) {
    return [];
  }
  if (connectNulls) {
    var filtered = [];
    for (var i = 0, len3 = points2.length; i < len3; i++) {
      var point2 = points2[i];
      if (!isYNil(point2)) {
        filtered.push(point2);
      }
    }
    return [filtered];
  }
  var result2 = [];
  var tmp = [];
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var point2 = points2[i];
    if (isYNil(point2)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          result2.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point2);
    }
  }
  if (tmp.length) {
    result2.push(tmp);
  }
  return result2;
}
function getViolinPath(points2) {
  var path = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  if (first) {
    path.push(["L", first.x, first.y]);
    path.push(["z"]);
  }
  return path;
}
function getSmoothViolinPath(points2) {
  var half = points2.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i = 0; i < points2.length; i++) {
    if (i < half) {
      leftPoints.push(points2[i]);
    } else {
      rightPoints.push(points2[i]);
    }
  }
  var leftPath = getSplinePath(leftPoints, false);
  var rightPath = getSplinePath(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path.push(["L", leftPoints[0].x, leftPoints[0].y]);
  }
  path.push(["z"]);
  return path;
}

// node_modules/@antv/g2/esm/geometry/shape/util/get-style.js
function getStyle2(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = "";
  }
  var _a6 = cfg.style, style = _a6 === void 0 ? {} : _a6, defaultStyle = cfg.defaultStyle, color3 = cfg.color, size3 = cfg.size;
  var attrs = __assign(__assign({}, defaultStyle), style);
  if (color3) {
    if (isStroke) {
      if (!style.stroke) {
        attrs.stroke = color3;
      }
    }
    if (isFill) {
      if (!style.fill) {
        attrs.fill = color3;
      }
    }
  }
  if (sizeName && is_nil_default(style[sizeName]) && !is_nil_default(size3)) {
    attrs[sizeName] = size3;
  }
  return attrs;
}
function getBackgroundRectStyle(cfg) {
  return deep_mix_default({}, {
    // copy from active-region
    fill: "#CCD6EC",
    fillOpacity: 0.3
  }, get_default(cfg, ["background", "style"]));
}

// node_modules/@antv/g2/esm/geometry/shape/util/split-points.js
function splitPoints(obj) {
  var x = obj.x;
  var y = is_array_default(obj.y) ? obj.y : [obj.y];
  return y.map(function(eachY, index) {
    return {
      x: is_array_default(x) ? x[index] : x,
      y: eachY
    };
  });
}

// node_modules/@antv/g2/esm/geometry/shape/line/util.js
var LineSymbols = {
  line: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dot: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dash: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  smooth: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r / 2, r / 2, 0, 1, 1, x, y],
      ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
    ];
  },
  hv: function(x, y, r) {
    return [
      ["M", x - r - 1, y - 2.5],
      ["L", x, y - 2.5],
      ["L", x, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vh: function(x, y, r) {
    return [
      ["M", x - r - 1, y + 2.5],
      ["L", x, y + 2.5],
      ["L", x, y - 2.5],
      ["L", x + r + 1, y - 2.5]
    ];
  },
  hvh: function(x, y, r) {
    return [
      ["M", x - (r + 1), y + 2.5],
      ["L", x - r / 2, y + 2.5],
      ["L", x - r / 2, y - 2.5],
      ["L", x + r / 2, y - 2.5],
      ["L", x + r / 2, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vhv: function(x, y) {
    return [
      ["M", x - 5, y + 2.5],
      ["L", x - 5, y],
      ["L", x, y],
      ["L", x, y - 3],
      ["L", x, y + 3],
      ["L", x + 6.5, y + 3]
    ];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color3 = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color3
    }
  };
}

// node_modules/@antv/g2/esm/geometry/shape/line/index.js
function getShapeAttrs(cfg, smooth, constraint) {
  var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = getStyle2(cfg, true, false, "lineWidth");
  var points2 = getPathPoints(cfg.points, connectNulls, showSinglePoint);
  var path = [];
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var eachLinePoints = points2[i];
    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path;
  return shapeAttrs;
}
function getSinglePath(points2, isInCircle, smooth, constraint, style) {
  if (points2.length === 1) {
    return [
      ["M", points2[0].x, points2[0].y - style.lineWidth / 2],
      ["L", points2[0].x, points2[0].y],
      ["L", points2[0].x, points2[0].y + style.lineWidth / 2]
    ];
  }
  var path;
  if (!smooth) {
    path = getLinePath2(points2, false);
    if (isInCircle) {
      path.push(["Z"]);
    }
  } else {
    if (isInCircle && points2.length) {
      points2.push({ x: points2[0].x, y: points2[0].y });
    }
    path = getSplinePath(points2, false, constraint);
  }
  return path;
}
function getRangePath(points2, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  each_default(points2, function(point2) {
    var result2 = splitPoints(point2);
    topPoints.push(result2[1]);
    bottomPoints.push(result2[0]);
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath(points2, isInCircle, isStack, smooth, constraint, style) {
  if (points2.length) {
    var first = points2[0];
    return is_array_default(first.y) ? getRangePath(points2, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points2, isInCircle, smooth, constraint, style);
  }
  return [];
}
var LineShapeFactory = registerShapeFactory("line", {
  defaultShapeType: "line"
});
each_default(["line", "dot", "dash", "smooth"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var smooth = shapeType === "smooth";
      var constraint;
      if (smooth) {
        var _a6 = this.coordinate, start = _a6.start, end = _a6.end;
        constraint = [
          [start.x, end.y],
          [end.x, start.y]
        ];
      }
      var attrs = getShapeAttrs(cfg, smooth, constraint);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line",
        capture: !smooth
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});

// node_modules/@antv/g2/esm/core.js
var VERSION = "4.2.10";
var Util = {
  getLegendItems,
  translate: translate2,
  rotate: rotate4,
  zoom,
  transform: transform3,
  getAngle: getAngle2,
  getSectorPath,
  polarToCartesian,
  getDelegationObject,
  getTooltipItems,
  getMappingValue,
  // shape 
  getPath,
  getPathPoints
};

// node_modules/@antv/g2/esm/theme/style-sheet/dark.js
var WHITE_COLORS2 = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var BLACK_COLORS2 = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_102 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#E86452",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_202 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#E86452",
  "#F8D0CB",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE2 = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createDarkStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a6 = cfg.paletteQualitative10, paletteQualitative10 = _a6 === void 0 ? QUALITATIVE_102 : _a6, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_202 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    /**  */
    backgroundColor: "#141414",
    /**  */
    brandColor,
    /**  */
    subColor: "rgba(255,255,255,0.05)",
    /**  1 10  */
    paletteQualitative10,
    /**  2 10  */
    paletteQualitative20,
    /**  */
    paletteSemanticRed: "#F4664A",
    /**  */
    paletteSemanticGreen: "#30BF78",
    /**  */
    paletteSemanticYellow: "#FAAD14",
    /** () */
    paletteSequence: SINGLE_SEQUENCE2,
    /**  */
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    // --------------------  --------------------
    /**  */
    axisLineBorderColor: BLACK_COLORS2[25],
    /**  */
    axisLineBorder: 1,
    /**  lineDash  */
    axisLineDash: null,
    /**  */
    axisTitleTextFillColor: BLACK_COLORS2[65],
    /**  */
    axisTitleTextFontSize: 12,
    /**  */
    axisTitleTextLineHeight: 12,
    /**  */
    axisTitleTextFontWeight: "normal",
    /**  */
    axisTitleSpacing: 12,
    /** icon */
    axisDescriptionIconFillColor: WHITE_COLORS2[85],
    /**  */
    axisTickLineBorderColor: BLACK_COLORS2[25],
    /**  */
    axisTickLineLength: 4,
    /**  */
    axisTickLineBorder: 1,
    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS2[15],
    /**  */
    axisSubTickLineLength: 2,
    /**  */
    axisSubTickLineBorder: 1,
    /**  */
    axisLabelFillColor: BLACK_COLORS2[45],
    /**  */
    axisLabelFontSize: 12,
    /**  */
    axisLabelLineHeight: 12,
    /**  */
    axisLabelFontWeight: "normal",
    /**  */
    axisLabelOffset: 8,
    /**  */
    axisGridBorderColor: BLACK_COLORS2[15],
    /**  */
    axisGridBorder: 1,
    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------
    /**  */
    legendTitleTextFillColor: BLACK_COLORS2[45],
    /**  */
    legendTitleTextFontSize: 12,
    /**  */
    legendTitleTextLineHeight: 21,
    /**  */
    legendTitleTextFontWeight: "normal",
    /**  marker  */
    legendMarkerColor: QUALITATIVE_102[0],
    /**  marker  */
    legendMarkerSpacing: 8,
    /**  marker  */
    legendMarkerSize: 4,
    /**  'circle' marker  */
    legendCircleMarkerSize: 4,
    /**  'square' marker  */
    legendSquareMarkerSize: 4,
    /**  'line' marker  */
    legendLineMarkerSize: 5,
    /**  */
    legendItemNameFillColor: BLACK_COLORS2[65],
    /**  */
    legendItemNameFontSize: 12,
    /**  */
    legendItemNameLineHeight: 12,
    /**  */
    legendItemNameFontWeight: "normal",
    /**  */
    legendItemSpacing: 24,
    /**  */
    legendItemMarginBottom: 12,
    /**   */
    legendSpacing: 16,
    /**   */
    legendPadding: [8, 8, 8, 8],
    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],
    /**  */
    legendVerticalPadding: [0, 8, 0, 8],
    // 
    /**  marker  */
    legendPageNavigatorMarkerSize: 12,
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS2[45],
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    /**  marker  */
    legendPageNavigatorMarkerFillColor: BLACK_COLORS2[45],
    /**  marker  */
    legendPageNavigatorMarkerFillOpacity: 1,
    /**  */
    legendPageNavigatorTextFillColor: BLACK_COLORS2[65],
    /**  */
    legendPageNavigatorTextFontSize: 12,
    /**  */
    sliderRailFillColor: BLACK_COLORS2[15],
    /**  */
    sliderRailBorder: 0,
    /**  */
    sliderRailBorderColor: null,
    /**  */
    sliderRailWidth: 100,
    /**  */
    sliderRailHeight: 12,
    /**  */
    sliderLabelTextFillColor: BLACK_COLORS2[45],
    /**  */
    sliderLabelTextFontSize: 12,
    /**  */
    sliderLabelTextLineHeight: 12,
    /**  */
    sliderLabelTextFontWeight: "normal",
    /**  */
    sliderHandlerFillColor: WHITE_COLORS2[6],
    /**  */
    sliderHandlerWidth: 10,
    /**  */
    sliderHandlerHeight: 14,
    /**  */
    sliderHandlerBorder: 1,
    /**  */
    sliderHandlerBorderColor: WHITE_COLORS2[25],
    // -------------------- Annotation --------------------
    /** arc  */
    annotationArcBorderColor: BLACK_COLORS2[15],
    /** arc  */
    annotationArcBorder: 1,
    /** line  */
    annotationLineBorderColor: BLACK_COLORS2[25],
    /** line  */
    annotationLineBorder: 1,
    /** lube  */
    annotationLineDash: null,
    /** text  */
    annotationTextFillColor: BLACK_COLORS2[65],
    /** text  */
    annotationTextFontSize: 12,
    /** text  */
    annotationTextLineHeight: 12,
    /** text  */
    annotationTextFontWeight: "normal",
    /** text  */
    annotationTextBorderColor: null,
    /** text  */
    annotationTextBorder: 0,
    /** region  */
    annotationRegionFillColor: BLACK_COLORS2[100],
    /** region  */
    annotationRegionFillOpacity: 0.06,
    /** region  */
    annotationRegionBorder: 0,
    /** region  */
    annotationRegionBorderColor: null,
    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------
    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS2[25],
    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,
    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,
    /** tooltip  */
    tooltipContainerFillColor: "#1f1f1f",
    tooltipContainerFillOpacity: 0.95,
    /** tooltip  */
    tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
    /** tooltip  */
    tooltipContainerBorderRadius: 3,
    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS2[65],
    /** tooltip  */
    tooltipTextFontSize: 12,
    /** tooltip  */
    tooltipTextLineHeight: 12,
    /** tooltip  */
    tooltipTextFontWeight: "bold",
    // -------------------- Geometry labels --------------------
    /** Geometry label  */
    labelFillColor: BLACK_COLORS2[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    /** Geometry label  */
    labelFontSize: 12,
    /** Geometry label  */
    labelLineHeight: 12,
    /** Geometry label  */
    labelFontWeight: "normal",
    /** Geometry label  */
    labelBorderColor: null,
    /** Geometry label  */
    labelBorder: 0,
    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS2[100],
    /** Geometry innerLabel  */
    innerLabelFontSize: 12,
    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,
    /** Geometry innerLabel  */
    innerLabelFontWeight: "normal",
    /** Geometry innerLabel  */
    innerLabelBorderColor: null,
    /** Geometry innerLabel  */
    innerLabelBorder: 0,
    /** Geometry label  */
    overflowLabelFillColor: BLACK_COLORS2[65],
    overflowLabelFillColorDark: "#2c3542",
    overflowLabelFillColorLight: "#ffffff",
    /** Geometry label  */
    overflowLabelFontSize: 12,
    /** Geometry label  */
    overflowLabelLineHeight: 12,
    /** Geometry label  */
    overflowLabelFontWeight: "normal",
    /** Geometry label  */
    overflowLabelBorderColor: WHITE_COLORS2[100],
    /** Geometry label  */
    overflowLabelBorder: 1,
    /** Geometry label  */
    labelLineBorder: 1,
    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS2[25],
    // -------------------- Slider --------------------
    /** slider  */
    cSliderRailHieght: 16,
    /** slider  */
    cSliderBackgroundFillColor: "#416180",
    /** slider  */
    cSliderBackgroundFillOpacity: 0.05,
    /** slider  */
    cSliderForegroundFillColor: "#5B8FF9",
    /** slider  */
    cSliderForegroundFillOpacity: 0.15,
    // slider handlerStyle 
    /** slider  */
    cSliderHandlerHeight: 24,
    /** Slider  */
    cSliderHandlerWidth: 10,
    /** Slider  */
    cSliderHandlerFillColor: "#F7F7F7",
    /** Slider  */
    cSliderHandlerFillOpacity: 1,
    /** Slider  */
    cSliderHandlerHighlightFillColor: "#FFF",
    /** Slider  */
    cSliderHandlerBorderColor: "#BFBFBF",
    /** Slider  */
    cSliderHandlerBorder: 1,
    /** Slider  */
    cSliderHandlerBorderRadius: 2,
    // slider textStyle 
    /** Slider  */
    cSliderTextFillColor: "#fff",
    /** Slider  */
    cSliderTextFillOpacity: 0.45,
    /** Slider  */
    cSliderTextFontSize: 12,
    /** Slider  */
    cSliderTextLineHeight: 12,
    /** Slider  */
    cSliderTextFontWeight: "normal",
    /** Slider  */
    cSliderTextBorderColor: null,
    /** Slider  */
    cSliderTextBorder: 0,
    // -------------------- Scrollbar --------------------
    /**   */
    scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
    /**   */
    scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
    /**   */
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
    // -------------------- Geometry --------------------
    /**  */
    pointFillColor: QUALITATIVE_102[0],
    /**  */
    pointFillOpacity: 0.95,
    /**  */
    pointSize: 4,
    /**  */
    pointBorder: 1,
    /**  */
    pointBorderColor: WHITE_COLORS2[100],
    /**  */
    pointBorderOpacity: 1,
    /**  active  */
    pointActiveBorderColor: BLACK_COLORS2[100],
    /**  selected  */
    pointSelectedBorder: 2,
    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS2[100],
    /**  inactive  */
    pointInactiveFillOpacity: 0.3,
    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,
    /**  */
    hollowPointSize: 4,
    /**  */
    hollowPointBorder: 1,
    /**  */
    hollowPointBorderColor: QUALITATIVE_102[0],
    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS2[100],
    /**  active  */
    hollowPointActiveBorder: 1,
    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS2[100],
    /**  active  */
    hollowPointActiveBorderOpacity: 1,
    /**  selected  */
    hollowPointSelectedBorder: 2,
    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS2[100],
    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,
    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,
    /**  */
    lineBorder: 2,
    /**  */
    lineBorderColor: QUALITATIVE_102[0],
    /**  */
    lineBorderOpacity: 1,
    /**  Active  */
    lineActiveBorder: 3,
    /**  selected  */
    lineSelectedBorder: 3,
    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,
    /** area  */
    areaFillColor: QUALITATIVE_102[0],
    /** area  */
    areaFillOpacity: 0.25,
    /** area  active  */
    areaActiveFillColor: QUALITATIVE_102[0],
    areaActiveFillOpacity: 0.5,
    /** area  selected  */
    areaSelectedFillColor: QUALITATIVE_102[0],
    areaSelectedFillOpacity: 0.5,
    /** area inactive  */
    areaInactiveFillOpacity: 0.3,
    /** hollowArea  */
    hollowAreaBorderColor: QUALITATIVE_102[0],
    /** hollowArea  */
    hollowAreaBorder: 2,
    /** hollowArea  */
    hollowAreaBorderOpacity: 1,
    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS2[100],
    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS2[100],
    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,
    /** interval  */
    intervalFillColor: QUALITATIVE_102[0],
    /** interval  */
    intervalFillOpacity: 0.95,
    /** interval active  */
    intervalActiveBorder: 1,
    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS2[100],
    intervalActiveBorderOpacity: 1,
    /** interval selected  */
    intervalSelectedBorder: 2,
    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS2[100],
    /** interval selected  */
    intervalSelectedBorderOpacity: 1,
    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,
    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,
    /** interval  */
    hollowIntervalBorder: 2,
    /** hollowInterval  */
    hollowIntervalBorderColor: QUALITATIVE_102[0],
    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS2[100],
    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,
    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS2[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS2[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,
    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign(__assign({}, token2), cfg);
};
var antvDark = createDarkStyleSheet();

// node_modules/@antv/g-canvas/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default2,
  AbstractShape: () => shape_default,
  Base: () => base_default2,
  Canvas: () => canvas_default2,
  Event: () => graph_event_default,
  Group: () => group_default3,
  PathUtil: () => path_exports,
  Shape: () => shape_exports,
  assembleFont: () => assembleFont,
  getArcParams: () => getArcParams2,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert2,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version
});

// node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default15,
  Circle: () => circle_default5,
  Ellipse: () => ellipse_default3,
  Image: () => image_default2,
  Line: () => line_default7,
  Marker: () => marker_default,
  Path: () => path_default2,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default3
});

// node_modules/@antv/g-canvas/esm/util/util.js
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance7(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect2(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint2(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

// node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient2) {
  var arr = steps.match(regexColorStop2);
  each_default(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG2.exec(gradientStr);
  var angle4 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle4 >= 0 && angle4 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle4 && angle4 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle4 && angle4 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle4);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient2);
  return gradient2;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG2.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop2);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
  addStop(steps, gradient2);
  return gradient2;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern2;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat2 = arr[1];
  var source = arr[2];
  function onload() {
    pattern2 = context.createPattern(img, repeat2);
    element.set("pattern", pattern2);
    element.set("patternSource", patternStr);
  }
  switch (repeat2) {
    case "a":
      repeat2 = "repeat";
      break;
    case "x":
      repeat2 = "repeat-x";
      break;
    case "y":
      repeat2 = "repeat-y";
      break;
    case "n":
      repeat2 = "no-repeat";
      break;
    default:
      repeat2 = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern2;
}
function parseStyle(context, element, color3) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color3;
  }
  if (is_string_default(color3)) {
    if (color3[1] === "(" || color3[2] === "(") {
      if (color3[0] === "l") {
        return parseLineGradient(context, element, color3);
      }
      if (color3[0] === "r") {
        return parseRadialGradient(context, element, color3);
      }
      if (color3[0] === "p") {
        return parsePattern(context, element, color3);
      }
    }
    return color3;
  }
  if (color3 instanceof CanvasPattern) {
    return color3;
  }
}
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

// node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag2(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio2(u, v) {
  return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
}
function vAngle2(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
}
function getArcParams2(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle2([1, 0], u);
  var dTheta = vAngle2(u, v);
  if (vRatio2(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio2(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/g-canvas/esm/util/arrow.js
var sin = Math.sin;
var cos = Math.cos;
var atan2 = Math.atan2;
var PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      //  10 60 
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      //  shape stroke 
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign(__assign({}, restAttrs), {
      //  stroke  lineWidth shape 
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      //  shape 
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}

// node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === "matrix" && v) {
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      is_array_default(v) && context.setLineDash(v);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v = parseStyle(context, element, v);
      } else if (name_1 === "globalAlpha") {
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each_default(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (!child.cfg.visible) {
      continue;
    }
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect2(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance9 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance9 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path[i + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance9 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance9 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance9.dx, dy = distance9.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i];
          if (!arcParams) {
            arcParams = getArcParams2(currentPoint, params);
            arcParamsCache[i] = arcParams;
          }
        } else {
          arcParams = getArcParams2(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len3 = params.length;
      currentPoint = [params[len3 - 2], params[len3 - 1]];
    }
  }
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each_default(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min_default(minXArr),
    minY: min_default(minYArr),
    maxX: max_default(maxXArr),
    maxY: max_default(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect2(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

// node_modules/@antv/g-canvas/esm/group.js
var Group = (
  /** @class */
  function(_super) {
    __extends(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    Group3.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each_default(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min_default(xArr);
        var maxX = max_default(xArr);
        var minY = min_default(yArr);
        var maxY2 = max_default(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY: maxY2,
          width: maxX - minX,
          height: maxY2 - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect2(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group3.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group3;
  }(group_default2)
);
var group_default3 = Group;

// node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase2 = (
  /** @class */
  function(_super) {
    __extends(ShapeBase4, _super);
    function ShapeBase4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default3;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY2 = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY: maxY2
      };
    };
    ShapeBase4.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase4.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase4.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    ShapeBase4.prototype.draw = function(context, region) {
      var clip = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect2(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase4.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase4.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect2(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase4.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase4.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase4.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase4.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase4.prototype.strokeAndFill = function(context) {
      var _a6 = this.attrs, lineWidth = _a6.lineWidth, opacity = _a6.opacity, strokeOpacity = _a6.strokeOpacity, fillOpacity = _a6.fillOpacity;
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.createPath = function(context) {
    };
    ShapeBase4.prototype.afterDrawPath = function(context) {
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase4;
  }(shape_default)
);
var base_default15 = ShapeBase2;

// node_modules/@antv/g-canvas/esm/shape/circle.js
var Circle3 = (
  /** @class */
  function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance7(cx, cy, x, y);
      if (isFill && isStroke) {
        return absDistance <= r + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r;
      }
      if (isStroke) {
        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
      }
      return false;
    };
    Circle6.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle6;
  }(base_default15)
);
var circle_default5 = Circle3;

// node_modules/@antv/g-canvas/esm/shape/ellipse.js
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = (
  /** @class */
  function(_super) {
    __extends(Ellipse3, _super);
    function Ellipse3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x - cx) * (x - cx);
      var squareY = (y - cy) * (y - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse3;
  }(base_default15)
);
var ellipse_default3 = Ellipse;

// node_modules/@antv/g-canvas/esm/shape/image.js
function isCanvas(dom) {
  return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = (
  /** @class */
  function(_super) {
    __extends(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (is_string_default(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "img") {
        this._setImage(value2);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        } else {
          context.drawImage(img, x, y, width, height);
        }
      }
    };
    return ImageShape2;
  }(base_default15)
);
var image_default2 = ImageShape;

// node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY2 + halfWidth)) {
    return false;
  }
  return line_default.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/shape/line.js
var Line3 = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line7.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line7.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line7.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      this.setArrow();
    };
    Line7.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x2, y2, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x2, y2);
      }
    };
    Line7.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a6 = this.attr(), x1 = _a6.x1, y1 = _a6.y1, x2 = _a6.x2, y2 = _a6.y2;
      return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line7.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line7.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line7.prototype.getTotalLength = function() {
      var _a6 = this.attr(), x1 = _a6.x1, y1 = _a6.y1, x2 = _a6.x2, y2 = _a6.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line7.prototype.getPoint = function(ratio) {
      var _a6 = this.attr(), x1 = _a6.x1, y1 = _a6.y1, x2 = _a6.x2, y2 = _a6.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line7;
  }(base_default15)
);
var line_default7 = Line3;

// node_modules/@antv/g-canvas/esm/shape/marker.js
var Symbols = {
  // 
  circle: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r, r, 0, 1, 0, x + r, y],
      ["A", r, r, 0, 1, 0, x - r, y]
    ];
  },
  // 
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
  },
  // 
  "triangle-down": function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker3, _super);
    function Marker3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker3.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker3.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker3.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker3.prototype._getR = function(attrs) {
      return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r = this._getR(attrs);
      var method2;
      var path;
      if (is_function_default(symbol)) {
        method2 = symbol;
        path = method2(x, y, r);
        path = pathToAbsolute2(path);
      } else {
        method2 = Marker3.Symbols[symbol];
        if (!method2) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path = method2(x, y, r);
      }
      return path;
    };
    Marker3.prototype.createPath = function(context) {
      var path = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path }, paramsCache);
    };
    Marker3.Symbols = Symbols;
    return Marker3;
  }(base_default15)
);
var marker_default = Marker;

// node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x, y) {
  var ctx4 = getOffScreenContext();
  shape.createPath(ctx4);
  return ctx4.isPointInPath(x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
var tolerance2 = 1e-6;
function dcmp2(x) {
  if (Math.abs(x) < tolerance2) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon2(points2, x, y) {
  var isHit = false;
  var n = points2.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points2[i];
    var p2 = points2[(i + 1) % n];
    if (onSegment2(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp2(p1[1] - y) > 0 !== dcmp2(p2[1] - y) > 0 && dcmp2(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle4 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle4 < startAngle || angle4 > endAngle) {
    return false;
  }
  var point2 = {
    x: cx + r * Math.cos(angle4),
    y: cy + r * Math.sin(angle4)
  };
  return distance7(point2.x, point2.y, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/util/path.js
var transform4 = ext_exports.transform;
function hasArc(path) {
  var hasArc2 = false;
  var count2 = path.length;
  for (var i = 0; i < count2; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x, y, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;
      case "Q":
        var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = cubic_default.pointDistance(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x,
          y,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform4(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p, p, m);
        isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
      default:
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path) {
  var count2 = path.length;
  var polygons = [];
  var polylines = [];
  var points2 = [];
  for (var i = 0; i < count2; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points2.length) {
        polylines.push(points2);
        points2 = [];
      }
      points2.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points2.length) {
        polygons.push(points2);
        points2 = [];
      }
    } else {
      points2.push([params[1], params[2]]);
    }
  }
  if (points2.length > 0) {
    polylines.push(points2);
  }
  return {
    polygons,
    polylines
  };
}
var path_default3 = __assign({
  hasArc,
  extractPolygons,
  isPointInStroke
}, path_exports);

// node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points2 = polygons[i];
    isHit = isInPolygon2(points2, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path = (
  /** @class */
  function(_super) {
    __extends(Path4, _super);
    function Path4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path4.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "path") {
        this._setPathArr(value2);
      }
      this.setArrow();
    };
    Path4.prototype._setPathArr = function(path) {
      this.attrs.path = pathToAbsolute2(path);
      var hasArc2 = path_default3.hasArc(path);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path4.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path4.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = path_default3.isPointInStroke(segments, lineWidth, x, y, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x, y);
        } else {
          var path = this.attr("path");
          var extractResutl = path_default3.extractPolygons(path);
          isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
        }
      }
      return isHit;
    };
    Path4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path4.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path4.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path4.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      var seg = curve[index];
      if (is_nil_default(seg) || is_nil_default(index)) {
        return null;
      }
      var l = seg.length;
      var nextSeg = curve[index + 1];
      return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path4.prototype._calculateCurve = function() {
      var path = this.attr().path;
      this.set("curve", path_default3.pathToCurve(path));
    };
    Path4.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path4.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result2;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result2 = [];
        if (tangent) {
          result2.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result2.push([startPoint[0], startPoint[1]]);
        } else {
          result2.push([endPoint[0], endPoint[1]]);
          result2.push([startPoint[0], startPoint[1]]);
        }
      }
      return result2;
    };
    Path4.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length5 = segments.length;
      var result2;
      if (length5 > 1) {
        var startPoint = segments[length5 - 2].currentPoint;
        var endPoint = segments[length5 - 1].currentPoint;
        var tangent = segments[length5 - 1].endTangent;
        result2 = [];
        if (tangent) {
          result2.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result2.push([endPoint[0], endPoint[1]]);
        } else {
          result2.push([startPoint[0], startPoint[1]]);
          result2.push([endPoint[0], endPoint[1]]);
        }
      }
      return result2;
    };
    return Path4;
  }(base_default15)
);
var path_default2 = Path;

// node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points2, lineWidth, x, y, isClose) {
  var count2 = points2.length;
  if (count2 < 2) {
    return false;
  }
  for (var i = 0; i < count2 - 1; i++) {
    var x1 = points2[i][0];
    var y1 = points2[i][1];
    var x2 = points2[i + 1][0];
    var y2 = points2[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points2[0];
    var last3 = points2[count2 - 1];
    if (inLine(first[0], first[1], last3[0], last3[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}

// node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon = (
  /** @class */
  function(_super) {
    __extends(Polygon4, _super);
    function Polygon4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var points2 = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points2, lineWidth, x, y, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon2(points2, x, y);
      }
      return isHit;
    };
    Polygon4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points2 = attrs.points;
      if (points2.length < 2) {
        return;
      }
      context.beginPath();
      for (var i = 0; i < points2.length; i++) {
        var point2 = points2[i];
        if (i === 0) {
          context.moveTo(point2[0], point2[1]);
        } else {
          context.lineTo(point2[0], point2[1]);
        }
      }
      context.closePath();
    };
    return Polygon4;
  }(base_default15)
);
var polygon_default3 = Polygon;

// node_modules/@antv/g-canvas/esm/shape/polyline.js
var PolyLine = (
  /** @class */
  function(_super) {
    __extends(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a6 = this.attrs, points2 = _a6.points, startArrow = _a6.startArrow, endArrow = _a6.endArrow;
      var length5 = points2.length;
      var x1 = points2[0][0];
      var y1 = points2[0][1];
      var x2 = points2[length5 - 1][0];
      var y2 = points2[length5 - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points2[1][0], points2[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points2[length5 - 2][0], points2[length5 - 2][1], x2, y2);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points2 = this.attr().points;
      return inPolyline(points2, lineWidth, x, y, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a6 = this.attr(), points2 = _a6.points, startArrow = _a6.startArrow, endArrow = _a6.endArrow;
      var length5 = points2.length;
      if (points2.length < 2) {
        return;
      }
      var x1 = points2[0][0];
      var y1 = points2[0][1];
      var x2 = points2[length5 - 1][0];
      var y2 = points2[length5 - 1][1];
      if (startArrow && startArrow.d) {
        var distance9 = getShortenOffset(x1, y1, points2[1][0], points2[1][1], startArrow.d);
        x1 += distance9.dx;
        y1 += distance9.dy;
      }
      if (endArrow && endArrow.d) {
        var distance9 = getShortenOffset(points2[length5 - 2][0], points2[length5 - 2][1], x2, y2, endArrow.d);
        x2 -= distance9.dx;
        y2 -= distance9.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i = 0; i < length5 - 1; i++) {
        var point2 = points2[i];
        context.lineTo(point2[0], point2[1]);
      }
      context.lineTo(x2, y2);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points2 = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points2));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points2 = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points2[index][0], points2[index][1], points2[index + 1][0], points2[index + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points2 = this.attr().points;
      if (!points2 || points2.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points2, function(p, i) {
        if (points2[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p[0], p[1], points2[i + 1][0], points2[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points2 = this.attr().points;
      var result2 = [];
      result2.push([points2[1][0], points2[1][1]]);
      result2.push([points2[0][0], points2[0][1]]);
      return result2;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points2 = this.attr().points;
      var l = points2.length - 1;
      var result2 = [];
      result2.push([points2[l - 1][0], points2[l - 1][1]]);
      result2.push([points2[l][0], points2[l][1]]);
      return result2;
    };
    return PolyLine2;
  }(base_default15)
);
var polyline_default3 = PolyLine;

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

// node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect = (
  /** @class */
  function(_super) {
    __extends(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x, y);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x, y);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x, y);
        }
        return isHit;
      }
    };
    Rect4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x, y, width, height);
      } else {
        var _a6 = parseRadius(radius), r1 = _a6[0], r2 = _a6[1], r3 = _a6[2], r4 = _a6[3];
        context.moveTo(x + r1, y);
        context.lineTo(x + width - r2, y);
        r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x + width, y + height - r3);
        r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x + r4, y + height);
        r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x, y + r1);
        r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect4;
  }(base_default15)
);
var rect_default2 = Rect;

// node_modules/@antv/g-canvas/esm/shape/text.js
var Text = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text3.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text3.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text3.prototype._setText = function(text) {
      var textArr = null;
      if (is_string_default(text) && text.indexOf("\n") !== -1) {
        textArr = text.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text3.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value2);
      }
    };
    Text3.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text3.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x = attrs.x;
      var y = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each_default(textArr, function(subText, index) {
        subY = y + index * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!is_nil_default(subText)) {
          if (isFill) {
            context.fillText(subText, x, subY);
          } else {
            context.strokeText(subText, x, subY);
          }
        }
      });
    };
    Text3.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text = attrs.text;
        if (!is_nil_default(text)) {
          if (isFill) {
            context.fillText(text, x, y);
          } else {
            context.strokeText(text, x, y);
          }
        }
      }
    };
    Text3.prototype.strokeAndFill = function(context) {
      var _a6 = this.attrs, lineWidth = _a6.lineWidth, opacity = _a6.opacity, strokeOpacity = _a6.strokeOpacity, fillOpacity = _a6.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text3.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text3.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text3;
  }(base_default15)
);
var text_default3 = Text;

// node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = invert2(matrix);
    return multiplyVec2(invertMatrix, v);
  }
  return v;
}
function getRefXY(element, x, y) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a6 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a6[0], refY = _a6[1];
    return [refX, refY];
  }
  return [x, y];
}
function preTest(element, x, y) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a6 = getRefXY(element, x, y), refX = _a6[0], refY = _a6[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x, y) {
  if (!preTest(container, x, y)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count2 = children.length;
  for (var i = count2 - 1; i >= 0; i--) {
    var child = children[i];
    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;
      var _a6 = getRefXY(child, x, y), refX = _a6[0], refY = _a6[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}

// node_modules/@antv/g-canvas/esm/canvas.js
var Canvas2 = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default3;
    };
    Canvas4.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas4.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas4.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas4.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas4.prototype.getShape = function(x, y) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape(this, x, y);
      } else {
        shape = _super.prototype.getShape.call(this, x, y, null);
      }
      return shape;
    };
    Canvas4.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas4.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas4.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas4.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas4.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren(context, children);
      this.set("refreshElements", []);
    };
    Canvas4.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each_default(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas4.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas4.prototype.skipDraw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default2 = Canvas2;

// node_modules/@antv/g-canvas/esm/index.js
var version = "0.5.12";

// node_modules/@antv/g-svg/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default2,
  AbstractShape: () => shape_default,
  Base: () => base_default2,
  Canvas: () => canvas_default3,
  Event: () => graph_event_default,
  Group: () => group_default4,
  PathUtil: () => path_exports,
  Shape: () => shape_exports2,
  assembleFont: () => assembleFont,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert2,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version2
});

// node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports2 = {};
__export(shape_exports2, {
  Base: () => base_default16,
  Circle: () => circle_default6,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default4,
  Image: () => image_default3,
  Line: () => line_default8,
  Marker: () => marker_default2,
  Path: () => path_default4,
  Polygon: () => polygon_default4,
  Polyline: () => polyline_default4,
  Rect: () => rect_default3,
  Text: () => text_default4
});

// node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// node_modules/@antv/g-svg/esm/util/dom.js
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom2(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent2 = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent2) {
    var parentNode = parent2.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent2.createDom();
      parent2.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
    //  defs 
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id = context.find("filter", cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform9 = [];
    for (var i = 0; i < 9; i += 3) {
      transform9.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform9 = transform9.join(",");
    if (transform9.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform9 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom2(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id + ")");
  }
}

// node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren2(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement2(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// node_modules/@antv/g-svg/esm/group.js
var Group2 = (
  /** @class */
  function(_super) {
    __extends(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.isEntityGroup = function() {
      return true;
    };
    Group3.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent2 = this.getParent();
      if (parent2) {
        var parentNode = parent2.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent2.createDom();
          parent2.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren2(context, children);
        }
      }
    };
    Group3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      setTransform(this);
    };
    return Group3;
  }(group_default2)
);
var group_default4 = Group2;

// node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase3 = (
  /** @class */
  function(_super) {
    __extends(ShapeBase4, _super);
    function ShapeBase4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default4;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x - halfWidth;
        var minY = y - halfWidth;
        var maxX = x + width + halfWidth;
        var maxY2 = y + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY: maxY2,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase4.prototype.isFill = function() {
      var _a6 = this.attr(), fill2 = _a6.fill, fillStyle = _a6.fillStyle;
      return (fill2 || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase4.prototype.isStroke = function() {
      var _a6 = this.attr(), stroke = _a6.stroke, strokeStyle = _a6.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase4.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom2(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase4.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase4.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill2 = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill2 || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill2);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase4.prototype._setColor = function(context, attr, value2) {
      var el = this.get("el");
      if (!value2) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value2 = value2.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value2)) {
        var id = context.find("gradient", value2);
        if (!id) {
          id = context.addGradient(value2);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value2)) {
        var id = context.find("pattern", value2);
        if (!id) {
          id = context.addPattern(value2);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    };
    ShapeBase4.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a6 = targetAttrs || attrs, shadowOffsetX = _a6.shadowOffsetX, shadowOffsetY = _a6.shadowOffsetY, shadowBlur = _a6.shadowBlur, shadowColor = _a6.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase4.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase4.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      var _a6 = this.attrs, lineWidth = _a6.lineWidth, lineAppendWidth = _a6.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase4;
  }(shape_default)
);
var base_default16 = ShapeBase3;

// node_modules/@antv/g-svg/esm/shape/circle.js
var Circle4 = (
  /** @class */
  function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value2);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Circle6;
  }(base_default16)
);
var circle_default6 = Circle4;

// node_modules/@antv/g-svg/esm/shape/dom.js
var Dom = (
  /** @class */
  function(_super) {
    __extends(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i = children.length - 1; i >= 0; i--) {
            el.removeChild(children[i]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default16)
);
var dom_default = Dom;

// node_modules/@antv/g-svg/esm/shape/ellipse.js
var Ellipse2 = (
  /** @class */
  function(_super) {
    __extends(Ellipse3, _super);
    function Ellipse3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value2);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Ellipse3;
  }(base_default16)
);
var ellipse_default4 = Ellipse2;

// node_modules/@antv/g-svg/esm/shape/image.js
var Image2 = (
  /** @class */
  function(_super) {
    __extends(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value2) {
      this.attrs[name] = value2;
      if (name === "img") {
        this._setImage(value2);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default16)
);
var image_default3 = Image2;

// node_modules/@antv/g-svg/esm/shape/line.js
var Line4 = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line7.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line7.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value2) {
            var id = is_object_default(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Line7.prototype.getTotalLength = function() {
      var _a6 = this.attr(), x1 = _a6.x1, y1 = _a6.y1, x2 = _a6.x2, y2 = _a6.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line7.prototype.getPoint = function(ratio) {
      var _a6 = this.attr(), x1 = _a6.x1, y1 = _a6.y1, x2 = _a6.x2, y2 = _a6.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line7;
  }(base_default16)
);
var line_default8 = Line4;

// node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols2 = {
  // 
  circle: function(x, y, r) {
    return [
      ["M", x, y],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  // 
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
  },
  // 
  triangleDown: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols2[type];
  },
  register: function(type, func) {
    Symbols2[type] = func;
  },
  remove: function(type) {
    delete Symbols2[type];
  },
  getAll: function() {
    return Symbols2;
  }
};

// node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker2 = (
  /** @class */
  function(_super) {
    __extends(Marker3, _super);
    function Marker3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker3.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker3.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (is_array_default(d)) {
        return d.map(function(path) {
          return path.join(" ");
        }).join("");
      }
      return d;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method2;
      if (is_function_default(symbol)) {
        method2 = symbol;
      } else {
        method2 = symbols_default.get(symbol);
      }
      if (!method2) {
        console.warn(method2 + " symbol is not exist.");
        return null;
      }
      return method2(x, y, r);
    };
    Marker3.symbolsFactory = symbols_default;
    return Marker3;
  }(base_default16)
);
var marker_default2 = Marker2;

// node_modules/@antv/g-svg/esm/shape/path.js
var Path2 = (
  /** @class */
  function(_super) {
    __extends(Path4, _super);
    function Path4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "path" && is_array_default(value2)) {
          el.setAttribute("d", _this._formatPath(value2));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value2) {
            var id = is_object_default(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Path4.prototype._formatPath = function(value2) {
      var newValue = value2.map(function(path) {
        return path.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path4.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path4.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point2 = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point2 ? {
        x: point2.x,
        y: point2.y
      } : null;
    };
    return Path4;
  }(base_default16)
);
var path_default4 = Path2;

// node_modules/@antv/g-svg/esm/shape/polygon.js
var Polygon2 = (
  /** @class */
  function(_super) {
    __extends(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon4.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "points" && is_array_default(value2) && value2.length >= 2) {
          el.setAttribute("points", value2.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Polygon4;
  }(base_default16)
);
var polygon_default4 = Polygon2;

// node_modules/@antv/g-svg/esm/shape/polyline.js
var Polyline = (
  /** @class */
  function(_super) {
    __extends(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "points" && is_array_default(value2) && value2.length >= 2) {
          el.setAttribute("points", value2.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points2 = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points2));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points2 = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points2[index][0], points2[index][1], points2[index + 1][0], points2[index + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points2 = this.attr().points;
      if (!points2 || points2.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points2, function(p, i) {
        if (points2[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p[0], p[1], points2[i + 1][0], points2[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points2 = this.attr().points;
      var result2 = [];
      result2.push([points2[1][0], points2[1][1]]);
      result2.push([points2[0][0], points2[0][1]]);
      return result2;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points2 = this.attr().points;
      var l = points2.length - 1;
      var result2 = [];
      result2.push([points2[l - 1][0], points2[l - 1][1]]);
      result2.push([points2[l][0], points2[l][1]]);
      return result2;
    };
    return Polyline2;
  }(base_default16)
);
var polyline_default4 = Polyline;

// node_modules/@antv/g-svg/esm/util/format.js
function parseRadius2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// node_modules/@antv/g-svg/esm/shape/rect.js
var Rect2 = (
  /** @class */
  function(_super) {
    __extends(Rect4, _super);
    function Rect4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Rect4.prototype._assembleRect = function(attrs) {
      var x = attrs.x;
      var y = attrs.y;
      var w = attrs.width;
      var h = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
      }
      var r = parseRadius2(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x + r.r1) + "," + y],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect4;
  }(base_default16)
);
var rect_default3 = Rect2;

// node_modules/@antv/g-svg/esm/shape/text.js
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value2, attr) {
        if (attr === "text") {
          _this._setText("" + value2);
        } else if (attr === "matrix" && value2) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text3.prototype._setFont = function() {
      var el = this.get("el");
      var _a6 = this.attr(), textBaseline = _a6.textBaseline, textAlign = _a6.textAlign;
      var browser2 = detect();
      if (browser2 && browser2.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text3.prototype._setText = function(text) {
      var el = this.get("el");
      var _a6 = this.attr(), x = _a6.x, _b = _a6.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i) {
          if (i === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text3;
  }(base_default16)
);
var text_default4 = Text2;

// node_modules/@antv/g-svg/esm/defs/gradient.js
var regexLG3 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG3 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop3 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop2(steps) {
  var arr = steps.match(regexColorStop3);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a, b) {
    a = a.split(":");
    b = b.split(":");
    return Number(a[0]) - Number(b[0]);
  });
  each_default(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient2(color3, el) {
  var arr = regexLG3.exec(color3);
  var angle4 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle4 >= 0 && angle4 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle4 && angle4 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle4 && angle4 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle4);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x);
  el.setAttribute("y2", y);
  el.innerHTML = addStop2(steps);
}
function parseRadialGradient2(color3, self2) {
  var arr = regexRG3.exec(color3);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r);
  self2.innerHTML = addStop2(steps);
}
var Gradient = (
  /** @class */
  function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient2(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient2(cfg, el);
      }
      el.setAttribute("id", id);
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }()
);
var gradient_default = Gradient;

// node_modules/@antv/g-svg/esm/defs/shadow.js
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = (
  /** @class */
  function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each_default(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value2) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value2;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }()
);
var shadow_default = Shadow;

// node_modules/@antv/g-svg/esm/defs/arrow.js
var Arrow = (
  /** @class */
  function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id = unique_id_default("marker_");
      el.setAttribute("id", id);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent2 = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent2.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent2.setAttribute("refY", "5");
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent2 = this.el;
      var path = this.cfg.path;
      var d = this.cfg.d;
      if (is_array_default(path)) {
        path = path.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path);
      parent2.appendChild(el);
      if (d) {
        parent2.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill2) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill2);
      } else {
        child.setAttribute("fill", fill2);
      }
    };
    return Arrow2;
  }()
);
var arrow_default = Arrow;

// node_modules/@antv/g-svg/esm/defs/clip.js
var Clip = (
  /** @class */
  function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }()
);
var clip_default = Clip;

// node_modules/@antv/g-svg/esm/defs/pattern.js
var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = (
  /** @class */
  function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id = unique_id_default("pattern_");
      el.id = id;
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      var arr = regexPR2.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }()
);
var pattern_default = Pattern;

// node_modules/@antv/g-svg/esm/defs/index.js
var Defs = (
  /** @class */
  function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id = unique_id_default("defs_");
      el.id = id;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result2 = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].match(type, attr)) {
          result2 = children[i].id;
          break;
        }
      }
      return result2;
    };
    Defs2.prototype.findById = function(id) {
      var children = this.children;
      var flag = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].id === id) {
          flag = children[i];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient2 = new gradient_default(cfg);
      this.el.appendChild(gradient2.el);
      this.add(gradient2);
      return gradient2.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern2 = new pattern_default(cfg);
      this.el.appendChild(pattern2.el);
      this.add(pattern2);
      return pattern2.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new clip_default(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }()
);
var defs_default = Defs;

// node_modules/@antv/g-svg/esm/canvas.js
var Canvas3 = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      return _super.call(this, __assign(__assign({}, cfg), {
        autoDraw: true,
        //  canvas
        renderer: "svg"
      })) || this;
    }
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default4;
    };
    Canvas4.prototype.getShape = function(x, y, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas4.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas4.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren2(context, children);
      }
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default3 = Canvas3;

// node_modules/@antv/g-svg/esm/index.js
var version2 = "0.5.6";

// node_modules/@antv/g2/esm/geometry/path.js
var Path3 = (
  /** @class */
  function(_super) {
    __extends(Path4, _super);
    function Path4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "path";
      _this.shapeType = "line";
      var _a6 = cfg.connectNulls, connectNulls = _a6 === void 0 ? false : _a6, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
      _this.connectNulls = connectNulls;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Path4.prototype.updateElements = function(mappingDataArray, isUpdate) {
      var e_1, _a6, e_2, _b, e_3, _c;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyData = /* @__PURE__ */ new Map();
      var keyIndex = /* @__PURE__ */ new Map();
      var keys3 = [];
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var key = this.getElementId(mappingData);
        keys3.push(key);
        keyData.set(key, mappingData);
        keyIndex.set(key, index);
        index++;
      }
      this.elements = new Array(index);
      var _d = diff(this.lastElementsMap, keys3), added = _d.added, updated = _d.updated, removed = _d.removed;
      try {
        for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
          var key = added_1_1.value;
          var mappingData = keyData.get(key);
          var shapeFactory = this.getShapeFactory();
          var shapeCfg = this.getShapeInfo(mappingData);
          var i = keyIndex.get(key);
          var element = new element_default2({
            shapeFactory,
            container: this.container,
            offscreenGroup: this.getOffscreenGroup(),
            elementIndex: i
          });
          element.geometry = this;
          element.animate = this.animateOption;
          element.draw(shapeCfg, isUpdate);
          this.elementsMap[key] = element;
          this.elements[i] = element;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (added_1_1 && !added_1_1.done && (_a6 = added_1.return))
            _a6.call(added_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
          var key = updated_1_1.value;
          var mappingData = keyData.get(key);
          var element = this.lastElementsMap[key];
          var i = keyIndex.get(key);
          var shapeCfg = this.getShapeInfo(mappingData);
          var preShapeCfg = element.getModel();
          if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
            element.animate = this.animateOption;
            element.update(shapeCfg);
          }
          this.elementsMap[key] = element;
          this.elements[i] = element;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
            _b.call(updated_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      try {
        for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
          var key = removed_1_1.value;
          var element = this.lastElementsMap[key];
          element.animate = this.animateOption;
          element.destroy();
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
            _c.call(removed_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    Path4.prototype.getPointsAndData = function(mappingData) {
      var points2 = [];
      var data3 = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points2.push({
          x: obj.x,
          y: obj.y
        });
        data3.push(obj[FIELD_ORIGIN]);
      }
      return {
        points: points2,
        data: data3
      };
    };
    Path4.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var _a6 = this.getPointsAndData(mappingData), points2 = _a6.points, data3 = _a6.data;
      shapeCfg.mappingData = mappingData;
      shapeCfg.data = data3;
      shapeCfg.isStack = !!this.getAdjust("stack");
      shapeCfg.points = points2;
      shapeCfg.connectNulls = this.connectNulls;
      shapeCfg.showSinglePoint = this.showSinglePoint;
      return shapeCfg;
    };
    return Path4;
  }(base_default13)
);
var path_default5 = Path3;

// node_modules/@antv/g2/esm/geometry/shape/area/util.js
function getPath2(points2, isInCircle, smooth, registeredShape, constraint) {
  var path = [];
  if (points2.length) {
    var topLinePoints_1 = [];
    var bottomLinePoints_1 = [];
    for (var i = 0, len3 = points2.length; i < len3; i++) {
      var point2 = points2[i];
      topLinePoints_1.push(point2[1]);
      bottomLinePoints_1.push(point2[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    each_default([topLinePoints_1, bottomLinePoints_1], function(pointsData, index) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        subPath = index === 0 ? [
          ["M", p1.x - 0.5, p1.y],
          ["L", p1.x + 0.5, p1.y]
        ] : [
          ["L", p1.x + 0.5, p1.y],
          ["L", p1.x - 0.5, p1.y]
        ];
      } else {
        if (isInCircle) {
          parsedPoints.push({ x: p1.x, y: p1.y });
        }
        if (smooth) {
          subPath = getSplinePath(parsedPoints, false, constraint);
        } else {
          subPath = getLinePath2(parsedPoints, false);
        }
        if (index > 0) {
          subPath[0][0] = "L";
        }
      }
      path = path.concat(subPath);
    });
    path.push(["Z"]);
  }
  return path;
}
function getShapeAttrs2(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = getStyle2(cfg, isStroke, !isStroke, "lineWidth");
  var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points2 = cfg.points, showSinglePoint = cfg.showSinglePoint;
  var pathPoints = getPathPoints(points2, connectNulls, showSinglePoint);
  var path = [];
  for (var i = 0, len3 = pathPoints.length; i < len3; i++) {
    var eachPoints = pathPoints[i];
    path = path.concat(getPath2(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path;
  return attrs;
}
function getConstraint(coordinate11) {
  var start = coordinate11.start, end = coordinate11.end;
  return [
    [start.x, end.y],
    [end.x, start.y]
  ];
}

// node_modules/@antv/g2/esm/geometry/shape/area/index.js
var AreaShapeFactory = registerShapeFactory("area", {
  defaultShapeType: "area",
  getDefaultPoints: function(pointInfo) {
    var x = pointInfo.x, y0 = pointInfo.y0;
    var y = is_array_default(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function(yItem) {
      return {
        x,
        y: yItem
      };
    });
  }
});
registerShape("area", "area", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs2(cfg, false, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color3,
        fillOpacity: 1
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/area.js
var Area = (
  /** @class */
  function(_super) {
    __extends(Area3, _super);
    function Area3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "area";
      _this.shapeType = "area";
      _this.generatePoints = true;
      _this.startOnZero = true;
      var _a6 = cfg.startOnZero, startOnZero = _a6 === void 0 ? true : _a6, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
      _this.startOnZero = startOnZero;
      _this.sortable = sortable;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Area3.prototype.getPointsAndData = function(mappingData) {
      var points2 = [];
      var data3 = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points2.push(obj.points);
        data3.push(obj[FIELD_ORIGIN]);
      }
      return {
        points: points2,
        data: data3
      };
    };
    Area3.prototype.getYMinValue = function() {
      if (this.startOnZero) {
        return _super.prototype.getYMinValue.call(this);
      }
      var yScale = this.getYScale();
      return yScale.min;
    };
    return Area3;
  }(path_default5)
);
var area_default = Area;

// node_modules/@antv/g2/esm/geometry/shape/edge/index.js
var EdgeShapeFactory = registerShapeFactory("edge", {
  defaultShapeType: "line",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
registerShape("edge", "line", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var path = getLinePath2(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/edge.js
var Edge = (
  /** @class */
  function(_super) {
    __extends(Edge2, _super);
    function Edge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "edge";
      _this.shapeType = "edge";
      _this.generatePoints = true;
      return _this;
    }
    return Edge2;
  }(base_default13)
);
var edge_default = Edge;

// node_modules/@antv/g2/esm/geometry/heatmap.js
var Heatmap = (
  /** @class */
  function(_super) {
    __extends(Heatmap3, _super);
    function Heatmap3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      _this.paletteCache = {};
      return _this;
    }
    Heatmap3.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var range2 = this.prepareRange(mappingData);
        var radius = this.prepareSize();
        var blur_1 = get_default(this.styleOption, ["cfg", "shadowBlur"]);
        if (!is_number_default(blur_1)) {
          blur_1 = radius / 2;
        }
        this.prepareGreyScaleBlurredCircle(radius, blur_1);
        this.drawWithRange(mappingData, range2, radius, blur_1);
      }
    };
    Heatmap3.prototype.color = function(field6, cfg) {
      this.createAttrOption("color", field6, typeof cfg !== "function" ? cfg : "");
      return this;
    };
    Heatmap3.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.clearShadowCanvasCtx();
      this.paletteCache = {};
    };
    Heatmap3.prototype.prepareRange = function(data3) {
      var colorAttr = this.getAttribute("color");
      var colorField = colorAttr.getFields()[0];
      var min5 = Infinity;
      var max5 = -Infinity;
      data3.forEach(function(row) {
        var value2 = row[FIELD_ORIGIN][colorField];
        if (value2 > max5) {
          max5 = value2;
        }
        if (value2 < min5) {
          min5 = value2;
        }
      });
      if (min5 === max5) {
        min5 = max5 - 1;
      }
      return [min5, max5];
    };
    Heatmap3.prototype.prepareSize = function() {
      var radius = this.getDefaultValue("size");
      if (!is_number_default(radius)) {
        radius = this.getDefaultSize();
      }
      return radius;
    };
    Heatmap3.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      var r2 = radius + blur;
      var ctx4 = grayScaleBlurredCanvas.getContext("2d");
      grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
      ctx4.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
      ctx4.shadowOffsetX = ctx4.shadowOffsetY = r2 * 2;
      ctx4.shadowBlur = blur;
      ctx4.shadowColor = "black";
      ctx4.beginPath();
      ctx4.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
      ctx4.closePath();
      ctx4.fill();
    };
    Heatmap3.prototype.drawWithRange = function(data3, range2, radius, blur) {
      var e_1, _a6;
      var _b = this.coordinate, start = _b.start, end = _b.end;
      var width = this.coordinate.getWidth();
      var height = this.coordinate.getHeight();
      var colorAttr = this.getAttribute("color");
      var valueField = colorAttr.getFields()[0];
      this.clearShadowCanvasCtx();
      var ctx4 = this.getShadowCanvasCtx();
      if (range2) {
        data3 = data3.filter(function(row) {
          return row[FIELD_ORIGIN][valueField] <= range2[1] && row[FIELD_ORIGIN][valueField] >= range2[0];
        });
      }
      var scale8 = this.scales[valueField];
      try {
        for (var data_1 = __values(data3), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var obj = data_1_1.value;
          var _c = this.getDrawCfg(obj), x = _c.x, y = _c.y;
          var alpha = scale8.scale(obj[FIELD_ORIGIN][valueField]);
          this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx4);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a6 = data_1.return))
            _a6.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var colored = ctx4.getImageData(0, 0, width, height);
      this.clearShadowCanvasCtx();
      this.colorize(colored);
      ctx4.putImageData(colored, 0, 0);
      var imageShape = this.getImageShape();
      imageShape.attr("x", start.x);
      imageShape.attr("y", end.y);
      imageShape.attr("width", width);
      imageShape.attr("height", height);
      imageShape.attr("img", ctx4.canvas);
      imageShape.set("origin", this.getShapeInfo(data3));
    };
    Heatmap3.prototype.getDefaultSize = function() {
      var position = this.getAttribute("position");
      var coordinate11 = this.coordinate;
      return Math.min(coordinate11.getWidth() / (position.scales[0].ticks.length * 4), coordinate11.getHeight() / (position.scales[1].ticks.length * 4));
    };
    Heatmap3.prototype.clearShadowCanvasCtx = function() {
      var ctx4 = this.getShadowCanvasCtx();
      ctx4.clearRect(0, 0, ctx4.canvas.width, ctx4.canvas.height);
    };
    Heatmap3.prototype.getShadowCanvasCtx = function() {
      var canvas = this.shadowCanvas;
      if (!canvas) {
        canvas = document.createElement("canvas");
        this.shadowCanvas = canvas;
      }
      canvas.width = this.coordinate.getWidth();
      canvas.height = this.coordinate.getHeight();
      return canvas.getContext("2d");
    };
    Heatmap3.prototype.getGrayScaleBlurredCanvas = function() {
      if (!this.grayScaleBlurredCanvas) {
        this.grayScaleBlurredCanvas = document.createElement("canvas");
      }
      return this.grayScaleBlurredCanvas;
    };
    Heatmap3.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx4) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      ctx4.globalAlpha = alpha;
      ctx4.drawImage(grayScaleBlurredCanvas, x - r, y - r);
    };
    Heatmap3.prototype.colorize = function(img) {
      var colorAttr = this.getAttribute("color");
      var pixels = img.data;
      var paletteCache = this.paletteCache;
      for (var i = 3; i < pixels.length; i += 4) {
        var alpha = pixels[i];
        if (is_number_default(alpha)) {
          var palette = paletteCache[alpha] ? paletteCache[alpha] : esm_default2.rgb2arr(colorAttr.gradient(alpha / 256));
          pixels[i - 3] = palette[0];
          pixels[i - 2] = palette[1];
          pixels[i - 1] = palette[2];
          pixels[i] = alpha;
        }
      }
    };
    Heatmap3.prototype.getImageShape = function() {
      var imageShape = this.imageShape;
      if (imageShape) {
        return imageShape;
      }
      var container = this.container;
      imageShape = container.addShape({
        type: "image",
        attrs: {}
      });
      this.imageShape = imageShape;
      return imageShape;
    };
    Heatmap3.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var data3 = mappingData.map(function(obj) {
        return obj[FIELD_ORIGIN];
      });
      return __assign(__assign({}, shapeCfg), { mappingData, data: data3 });
    };
    return Heatmap3;
  }(base_default13)
);
var heatmap_default = Heatmap;

// node_modules/@antv/g2/esm/geometry/shape/interval/util.js
function getRectPoints(pointInfo) {
  var _a6, _b;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y)) {
    _a6 = __read(y, 2), yMin = _a6[0], yMax = _a6[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMin;
  var xMax;
  if (is_array_default(x)) {
    _b = __read(x, 2), xMin = _b[0], xMax = _b[1];
  } else {
    xMin = x - size3 / 2;
    xMax = x + size3 / 2;
  }
  var points2 = [
    { x: xMin, y: yMin },
    { x: xMin, y: yMax }
  ];
  points2.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
  return points2;
}
function getRectPath(points2, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points2[0];
  path.push(["M", firstPoint.x, firstPoint.y]);
  for (var i = 1, len3 = points2.length; i < len3; i++) {
    path.push(["L", points2[i].x, points2[i].y]);
  }
  if (isClosed) {
    path.push(["L", firstPoint.x, firstPoint.y]);
    path.push(["z"]);
  }
  return path;
}
function parseRadius3(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
function getBackgroundRectPath(cfg, points2, coordinate11) {
  var path = [];
  if (coordinate11.isRect) {
    var p0 = coordinate11.isTransposed ? { x: coordinate11.start.x, y: points2[0].y } : { x: points2[0].x, y: coordinate11.start.y };
    var p1 = coordinate11.isTransposed ? { x: coordinate11.end.x, y: points2[2].y } : { x: points2[3].x, y: coordinate11.end.y };
    var radius = get_default(cfg, ["background", "style", "radius"]);
    if (radius) {
      var width = coordinate11.isTransposed ? Math.abs(points2[0].y - points2[2].y) : points2[2].x - points2[1].x;
      var height = coordinate11.isTransposed ? coordinate11.getWidth() : coordinate11.getHeight();
      var _a6 = __read(parseRadius3(radius, Math.min(width, height)), 4), r1 = _a6[0], r2 = _a6[1], r3 = _a6[2], r4 = _a6[3];
      var isReflectYTransposed_1 = coordinate11.isTransposed && coordinate11.isReflect("y");
      var bump = isReflectYTransposed_1 ? 0 : 1;
      var opposite = function(r) {
        return isReflectYTransposed_1 ? -r : r;
      };
      path.push(["M", p0.x, p1.y + opposite(r1)]);
      r1 !== 0 && path.push(["A", r1, r1, 0, 0, bump, p0.x + r1, p1.y]);
      path.push(["L", p1.x - r2, p1.y]);
      r2 !== 0 && path.push(["A", r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);
      path.push(["L", p1.x, p0.y - opposite(r3)]);
      r3 !== 0 && path.push(["A", r3, r3, 0, 0, bump, p1.x - r3, p0.y]);
      path.push(["L", p0.x + r4, p0.y]);
      r4 !== 0 && path.push(["A", r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);
    } else {
      path.push(["M", p0.x, p0.y]);
      path.push(["L", p1.x, p0.y]);
      path.push(["L", p1.x, p1.y]);
      path.push(["L", p0.x, p1.y]);
      path.push(["L", p0.x, p0.y]);
    }
    path.push(["z"]);
  }
  if (coordinate11.isPolar) {
    var center2 = coordinate11.getCenter();
    var _b = getAngle2(cfg, coordinate11), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (coordinate11.type !== "theta" && !coordinate11.isTransposed) {
      path = getSectorPath(center2.x, center2.y, coordinate11.getRadius(), startAngle, endAngle);
    } else {
      var pow = function(v) {
        return Math.pow(v, 2);
      };
      var r1 = Math.sqrt(pow(center2.x - points2[0].x) + pow(center2.y - points2[0].y));
      var r2 = Math.sqrt(pow(center2.x - points2[2].x) + pow(center2.y - points2[2].y));
      path = getSectorPath(center2.x, center2.y, r1, coordinate11.startAngle, coordinate11.endAngle, r2);
    }
  }
  return path;
}
function getIntervalRectPath(points2, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === "rect";
  var path = [];
  var r = (points2[2].x - points2[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;
  if (lineCap === "round") {
    if (isRect) {
      path.push(["M", points2[0].x, points2[0].y + ry]);
      path.push(["L", points2[1].x, points2[1].y - ry]);
      path.push(["A", r, r, 0, 0, 1, points2[2].x, points2[2].y - ry]);
      path.push(["L", points2[3].x, points2[3].y + ry]);
      path.push(["A", r, r, 0, 0, 1, points2[0].x, points2[0].y + ry]);
    } else {
      path.push(["M", points2[0].x, points2[0].y]);
      path.push(["L", points2[1].x, points2[1].y]);
      path.push(["A", r, r, 0, 0, 1, points2[2].x, points2[2].y]);
      path.push(["L", points2[3].x, points2[3].y]);
      path.push(["A", r, r, 0, 0, 1, points2[0].x, points2[0].y]);
    }
    path.push(["z"]);
  } else {
    path = getRectPath(points2);
  }
  return path;
}
function getFunnelPath(points2, nextPoints, isPyramid) {
  var path = [];
  if (!is_nil_default(nextPoints)) {
    path.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
  } else if (isPyramid) {
    path.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", (points2[2].x + points2[3].x) / 2, (points2[2].y + points2[3].y) / 2], ["Z"]);
  } else {
    path.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", points2[2].x, points2[2].y], ["L", points2[3].x, points2[3].y], ["Z"]);
  }
  return path;
}
function swap(p0, p1) {
  return [p1, p0];
}
function getRectWithCornerRadius(points2, coordinate11, radius) {
  var _a6, _b, _c, _d, _e, _f, _g;
  var _h = __read(__spreadArray([], __read(points2), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
  var _j = __read(typeof radius === "number" ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
  if (coordinate11.isTransposed) {
    _a6 = __read(swap(p1, p3), 2), p1 = _a6[0], p3 = _a6[1];
  }
  if (coordinate11.isReflect("y")) {
    _b = __read(swap(p0, p1), 2), p0 = _b[0], p1 = _b[1];
    _c = __read(swap(p2, p3), 2), p2 = _c[0], p3 = _c[1];
  }
  if (coordinate11.isReflect("x")) {
    _d = __read(swap(p0, p3), 2), p0 = _d[0], p3 = _d[1];
    _e = __read(swap(p1, p2), 2), p1 = _e[0], p2 = _e[1];
  }
  var path = [];
  var abs = function(v) {
    return Math.abs(v);
  };
  _f = __read(parseRadius3([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function(d) {
    return abs(d);
  }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
  if (coordinate11.isTransposed) {
    _g = __read([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
  }
  if (p0.y < p1.y) {
    path.push(["M", p3.x, p3.y + r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 0, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y + r4]);
    path.push(["L", p1.x, p1.y - r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 0, p1.x + r1, p1.y]);
    path.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y - r2]);
    path.push(["L", p3.x, p3.y + r3]);
    path.push(["z"]);
  } else if (p3.x < p0.x) {
    path.push(["M", p2.x + r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 0, p3.x + r3, p3.y]);
    path.push(["L", p0.x - r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 0, p1.x - r1, p1.y]);
    path.push(["L", p2.x + r2, p2.y]);
    path.push(["z"]);
  } else {
    path.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    path.push(["z"]);
  }
  return path;
}

// node_modules/@antv/g2/esm/geometry/shape/interval/index.js
var IntervalShapeFactory = registerShapeFactory("interval", {
  defaultShapeType: "rect",
  getDefaultPoints: function(pointInfo) {
    return getRectPoints(pointInfo);
  }
});
registerShape("interval", "rect", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup({
        name: "interval-group"
      });
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
        capture: false,
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path;
    if (style.radius && this.coordinate.isRect) {
      path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
    } else {
      path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
    }
    var shape = group2.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color3
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/util/shape-size.js
function findMinDistance(arr, scale8) {
  var count2 = arr.length;
  var sourceArr = arr;
  if (is_string_default(sourceArr[0])) {
    sourceArr = arr.map(function(v) {
      return scale8.translate(v);
    });
  }
  var distance9 = sourceArr[1] - sourceArr[0];
  for (var i = 2; i < count2; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];
    if (distance9 > tmp) {
      distance9 = tmp;
    }
  }
  return distance9;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData2 = flatten_default(dataArray);
    var values3 = values_of_key_default(mergeData2, dodgeBy);
    return values3.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry35) {
  var theme4 = geometry35.theme;
  var coordinate11 = geometry35.coordinate;
  var xScale = geometry35.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry35.beforeMappingData;
  var count2 = xValues.length;
  var xDimensionLength = getXDimensionLength(geometry35.coordinate);
  var intervalPadding = geometry35.intervalPadding, dodgePadding = geometry35.dodgePadding;
  var maxColumnWidth = geometry35.maxColumnWidth || theme4.maxColumnWidth;
  var minColumnWidth = geometry35.minColumnWidth || theme4.minColumnWidth;
  var columnWidthRatio = geometry35.columnWidthRatio || theme4.columnWidthRatio;
  var multiplePieWidthRatio = geometry35.multiplePieWidthRatio || theme4.multiplePieWidthRatio;
  var roseWidthRatio = geometry35.roseWidthRatio || theme4.roseWidthRatio;
  if (xScale.isLinear && xValues.length > 1) {
    xValues.sort();
    var interval3 = findMinDistance(xValues, xScale);
    count2 = (xScale.max - xScale.min) / interval3;
    if (xValues.length > count2) {
      count2 = xValues.length;
    }
  }
  var range2 = xScale.range;
  var normalizedSize = 1 / count2;
  var wr = 1;
  if (coordinate11.isPolar) {
    if (coordinate11.isTransposed && count2 > 1) {
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    if (xScale.isLinear) {
      normalizedSize *= range2[1] - range2[0];
    }
    wr = columnWidthRatio;
  }
  if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count2 - 1) * normalizedIntervalPadding) / count2;
  } else {
    normalizedSize *= wr;
  }
  if (geometry35.getAdjust("dodge")) {
    var dodgeAdjust = geometry35.getAdjust("dodge");
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!is_nil_default(dodgePadding) && dodgePadding >= 0) {
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  if (!is_nil_default(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  if (!is_nil_default(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}

// node_modules/@antv/g2/esm/geometry/interval.js
var Interval = (
  /** @class */
  function(_super) {
    __extends(Interval2, _super);
    function Interval2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "interval";
      _this.shapeType = "interval";
      _this.generatePoints = true;
      var background = cfg.background;
      _this.background = background;
      return _this;
    }
    Interval2.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, obj)[0];
        var coordinate11 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate11);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    Interval2.prototype.adjustScale = function() {
      _super.prototype.adjustScale.call(this);
      var yScale = this.getYScale();
      if (this.coordinate.type === "theta") {
        yScale.change({
          nice: false,
          min: 0,
          //  stack yScale  max this.updateStackRange()
          max: getMaxScale(yScale)
        });
      } else {
        var scaleDefs = this.scaleDefs;
        var field6 = yScale.field, min5 = yScale.min, max5 = yScale.max, type = yScale.type;
        if (type !== "time") {
          if (min5 > 0 && !get_default(scaleDefs, [field6, "min"])) {
            yScale.change({
              min: 0
            });
          }
          if (max5 <= 0 && !get_default(scaleDefs, [field6, "max"])) {
            yScale.change({
              max: 0
            });
          }
        }
      }
    };
    Interval2.prototype.getDrawCfg = function(mappingData) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
      shapeCfg.background = this.background;
      return shapeCfg;
    };
    return Interval2;
  }(base_default13)
);
var interval_default2 = Interval;

// node_modules/@antv/g2/esm/geometry/line.js
var Line5 = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "line";
      var _a6 = cfg.sortable, sortable = _a6 === void 0 ? false : _a6;
      _this.sortable = sortable;
      return _this;
    }
    return Line7;
  }(path_default5)
);
var line_default9 = Line5;

// node_modules/@antv/g2/esm/geometry/shape/point/util.js
var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var e_1, _a6;
  var style = getStyle2(cfg, isStroke, !isStroke, "r");
  var points2 = shape.parsePoints(cfg.points);
  var pointPosition = points2[0];
  if (cfg.isStack) {
    pointPosition = points2[1];
  } else if (points2.length > 1) {
    var group2 = container.addGroup();
    try {
      for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
        var point2 = points_1_1.value;
        group2.addShape({
          type: "marker",
          attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point2)
        });
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (points_1_1 && !points_1_1.done && (_a6 = points_1.return))
          _a6.call(points_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return group2;
  }
  return container.addShape({
    type: "marker",
    attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
  });
}

// node_modules/@antv/g2/esm/geometry/shape/point/index.js
var PointShapeFactory = registerShapeFactory("point", {
  defaultShapeType: "hollow-circle",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
each_default(SHAPES, function(shapeName) {
  registerShape("point", "hollow-".concat(shapeName), {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color3 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color3,
          fill: null
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/point.js
var Point = (
  /** @class */
  function(_super) {
    __extends(Point2, _super);
    function Point2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "point";
      _this.shapeType = "point";
      _this.generatePoints = true;
      return _this;
    }
    Point2.prototype.getDrawCfg = function(mappingDatum) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
      return __assign(__assign({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
    };
    return Point2;
  }(base_default13)
);
var point_default = Point;

// node_modules/@antv/g2/esm/geometry/shape/polygon/index.js
function getPath3(points2) {
  var flag = points2[0];
  var i = 1;
  var path = [["M", flag.x, flag.y]];
  while (i < points2.length) {
    var c = points2[i];
    if (c.x !== points2[i - 1].x || c.y !== points2[i - 1].y) {
      path.push(["L", c.x, c.y]);
      if (c.x === flag.x && c.y === flag.y && i < points2.length - 1) {
        flag = points2[i + 1];
        path.push(["Z"]);
        path.push(["M", flag.x, flag.y]);
        i++;
      }
    }
    i++;
  }
  if (!is_equal_default(last(path), flag)) {
    path.push(["L", flag.x, flag.y]);
  }
  path.push(["Z"]);
  return path;
}
var PolygonShapeFactory = registerShapeFactory("polygon", {
  defaultShapeType: "polygon",
  getDefaultPoints: function(pointInfo) {
    var points2 = [];
    each_default(pointInfo.x, function(subX, index) {
      var subY = pointInfo.y[index];
      points2.push({
        x: subX,
        y: subY
      });
    });
    return points2;
  }
});
registerShape("polygon", "polygon", {
  draw: function(cfg, container) {
    if (!is_empty_default(cfg.points)) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getPath3(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, shapeAttrs), { path }),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/polygon.js
var Polygon3 = (
  /** @class */
  function(_super) {
    __extends(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.shapeType = "polygon";
      _this.generatePoints = true;
      return _this;
    }
    Polygon4.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var x = cfg.x;
      var y = cfg.y;
      var temp;
      if (!(is_array_default(x) && is_array_default(y))) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xCount = xScale.values.length;
        var yCount = yScale.values.length;
        var xOffset = 0.5 * 1 / xCount;
        var yOffset = 0.5 * 1 / yCount;
        if (xScale.isCategory && yScale.isCategory) {
          x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
          y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
        } else if (is_array_default(x)) {
          temp = x;
          x = [temp[0], temp[0], temp[1], temp[1]];
          y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
        } else if (is_array_default(y)) {
          temp = y;
          y = [temp[0], temp[1], temp[1], temp[0]];
          x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
        }
        cfg.x = x;
        cfg.y = y;
      }
      return cfg;
    };
    return Polygon4;
  }(base_default13)
);
var polygon_default5 = Polygon3;

// node_modules/@antv/g2/esm/geometry/shape/schema/index.js
var SchemaShapeFactory = registerShapeFactory("schema", {
  defaultShapeType: ""
  // 'schema' is for some custom shapes, so will not specify defaultShapeType
});

// node_modules/@antv/g2/esm/geometry/schema.js
var Schema = (
  /** @class */
  function(_super) {
    __extends(Schema2, _super);
    function Schema2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "schema";
      _this.shapeType = "schema";
      _this.generatePoints = true;
      return _this;
    }
    Schema2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate11 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate11);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    return Schema2;
  }(base_default13)
);
var schema_default = Schema;

// node_modules/@antv/g2/esm/geometry/shape/violin/index.js
function normalizeSize(arr) {
  if (!is_array_default(arr)) {
    return [];
  }
  var maxValue = max_default(arr);
  return map_default(arr, function(num) {
    return num / maxValue;
  });
}
var ViolinShapeFactory = registerShapeFactory("violin", {
  defaultShapeType: "violin",
  getDefaultPoints: function(pointInfo) {
    var radius = pointInfo.size / 2;
    var points2 = [];
    var sizeArr = normalizeSize(pointInfo._size);
    each_default(pointInfo.y, function(y, index) {
      var offset = sizeArr[index] * radius;
      var isMin = index === 0;
      var isMax = index === pointInfo.y.length - 1;
      points2.push({
        isMin,
        isMax,
        x: pointInfo.x - offset,
        y
      });
      points2.unshift({
        isMin,
        isMax,
        x: pointInfo.x + offset,
        y
      });
    });
    return points2;
  }
});
registerShape("violin", "violin", {
  draw: function(cfg, container) {
    var shapeAttrs = getStyle2(cfg, true, true);
    var path = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, shapeAttrs), { path }),
      name: "violin"
    });
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/violin.js
var Violin = (
  /** @class */
  function(_super) {
    __extends(Violin3, _super);
    function Violin3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      _this.shapeType = "violin";
      _this.generatePoints = true;
      return _this;
    }
    Violin3.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate11 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate11);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      cfg._size = get_default(record[FIELD_ORIGIN], [this._sizeField]);
      return cfg;
    };
    Violin3.prototype.initAttributes = function() {
      var attributeOption = this.attributeOption;
      var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
      this._sizeField = sizeField;
      delete attributeOption.size;
      _super.prototype.initAttributes.call(this);
    };
    return Violin3;
  }(base_default13)
);
var violin_default = Violin;

// node_modules/@antv/g2/esm/geometry/shape/area/line.js
registerShape("area", "line", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs2(cfg, true, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color3,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/area/smooth.js
registerShape("area", "smooth", {
  draw: function(cfg, container) {
    var coordinate11 = this.coordinate;
    var attrs = getShapeAttrs2(cfg, false, true, this, getConstraint(coordinate11));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color3,
        fillOpacity: 1
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js
registerShape("area", "smooth-line", {
  draw: function(cfg, container) {
    var coordinate11 = this.coordinate;
    var attrs = getShapeAttrs2(cfg, true, true, this, getConstraint(coordinate11));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color3,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/util.js
function getCPath(from, to) {
  return ["C", from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}
function getQPath(to, center2) {
  var points2 = [];
  points2.push({
    x: center2.x,
    y: center2.y
  });
  points2.push(to);
  var sub4 = ["Q"];
  each_default(points2, function(point2) {
    sub4.push(point2.x, point2.y);
  });
  return sub4;
}

// node_modules/@antv/g2/esm/geometry/shape/edge/arc.js
function getArcShapePath(from, to, center2) {
  var sub4 = getQPath(to, center2);
  var path = [["M", from.x, from.y]];
  path.push(sub4);
  return path;
}
function getArcShapeWeightPath(points2, center2) {
  var arc1 = getQPath(points2[1], center2);
  var arc2 = getQPath(points2[3], center2);
  var path = [["M", points2[0].x, points2[0].y]];
  path.push(arc2);
  path.push(["L", points2[3].x, points2[3].y]);
  path.push(["L", points2[2].x, points2[2].y]);
  path.push(arc1);
  path.push(["L", points2[1].x, points2[1].y]);
  path.push(["L", points2[0].x, points2[0].y]);
  path.push(["Z"]);
  return path;
}
registerShape("edge", "arc", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var type = points2.length > 2 ? "weight" : "normal";
    var path;
    if (cfg.isInCircle) {
      var center2 = { x: 0, y: 1 };
      if (type === "normal") {
        path = getArcShapePath(points2[0], points2[1], center2);
      } else {
        style.fill = style.stroke;
        path = getArcShapeWeightPath(points2, center2);
      }
      path = this.parsePath(path);
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    } else {
      if (type === "normal") {
        points2 = this.parsePoints(points2);
        path = getArcPath((points2[1].x + points2[0].x) / 2, points2[0].y, Math.abs(points2[1].x - points2[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      } else {
        var c1 = getCPath(points2[1], points2[3]);
        var c2 = getCPath(points2[2], points2[0]);
        path = [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          c1,
          ["L", points2[3].x, points2[3].y],
          ["L", points2[2].x, points2[2].y],
          c2,
          ["Z"]
        ];
        path = this.parsePath(path);
        style.fill = style.stroke;
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      }
    }
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js
function getSmoothPath(from, to) {
  var sub4 = getCPath(from, to);
  var path = [["M", from.x, from.y]];
  path.push(sub4);
  return path;
}
registerShape("edge", "smooth", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path = this.parsePath(getSmoothPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
  var points2 = [];
  points2.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push(to);
  var path = [["M", from.x, from.y]];
  each_default(points2, function(point2) {
    path.push(["L", point2.x, point2.y]);
  });
  return path;
}
registerShape("edge", "vhv", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path = this.parsePath(getVHVPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign(__assign({}, style), { path })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js
registerShape("interval", "funnel", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js
registerShape("interval", "hollow-rect", {
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
        capture: false,
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path = this.parsePath(getRectPath(cfg.points));
    var shape = group2.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          stroke: color3,
          fill: null
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        stroke: color3,
        fill: null
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/line.js
function getLinePoints(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
  if (is_array_default(y)) {
    return y.map(function(yItem, idx) {
      return {
        x: is_array_default(x) ? x[idx] : x,
        y: yItem
      };
    });
  }
  return [
    { x, y: y0 },
    { x, y }
  ];
}
registerShape("interval", "line", {
  getPoints: function(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false, "lineWidth");
    var newStyle = omit(__assign({}, style), ["fill"]);
    var path = this.parsePath(getRectPath(cfg.points, false));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, newStyle), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x, y - r],
          ["L", x, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js
registerShape("interval", "pyramid", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, false, true);
    var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/interval/tick.js
function getTickPoints(pointInfo) {
  var _a6;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y)) {
    _a6 = __read(y, 2), yMin = _a6[0], yMax = _a6[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMax = x + size3 / 2;
  var xMin = x - size3 / 2;
  return [
    { x, y: yMin },
    { x, y: yMax },
    { x: xMin, y: yMin },
    { x: xMax, y: yMin },
    { x: xMin, y: yMax },
    { x: xMax, y: yMax }
  ];
}
function getTickPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y]
  ];
}
registerShape("interval", "tick", {
  getPoints: function(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var path = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x - r / 2, y - r],
          ["L", x + r / 2, y - r],
          ["M", x, y - r],
          ["L", x, y + r],
          ["M", x - r / 2, y + r],
          ["L", x + r / 2, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/line/step.js
var interpolateCallback = function(point2, nextPoint, shapeType) {
  var x = point2.x;
  var y = point2.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result2;
  switch (shapeType) {
    case "hv":
      result2 = [{ x: nextX, y }];
      break;
    case "vh":
      result2 = [{ x, y: nextY }];
      break;
    case "hvh":
      var middleX = (nextX + x) / 2;
      result2 = [
        { x: middleX, y },
        { x: middleX, y: nextY }
      ];
      break;
    case "vhv":
      var middleY = (y + nextY) / 2;
      result2 = [
        { x, y: middleY },
        { x: nextX, y: middleY }
      ];
      break;
    default:
      break;
  }
  return result2;
};
function getInterpolatePoints(points2, shapeType) {
  var result2 = [];
  each_default(points2, function(point2, index) {
    var nextPoint = points2[index + 1];
    result2.push(point2);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point2, nextPoint, shapeType);
      result2 = result2.concat(interpolatePoint);
    }
  });
  return result2;
}
function getInterpolatePath(points2) {
  return points2.map(function(point2, index) {
    return index === 0 ? ["M", point2.x, point2.y] : ["L", point2.x, point2.y];
  });
}
function getInterpolateShapeAttrs(cfg, shapeType) {
  var points2 = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
  var path = [];
  each_default(points2, function(eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path = path.concat(getInterpolatePath(interpolatePoints));
  });
  return __assign(__assign({}, getStyle2(cfg, true, false, "lineWidth")), { path });
}
each_default(["hv", "vh", "hvh", "vhv"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/point/hollow.js
each_default(HOLLOW_SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color3 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color3,
          fill: null
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/point/image.js
registerShape("point", "image", {
  draw: function(cfg, container) {
    var e_1, _a6;
    var size3 = getStyle2(cfg, false, false, "r").r;
    var points2 = this.parsePoints(cfg.points);
    var pointPosition = points2[0];
    if (cfg.isStack) {
      pointPosition = points2[1];
    } else if (points2.length > 1) {
      var group2 = container.addGroup();
      try {
        for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
          var point2 = points_1_1.value;
          group2.addShape("image", {
            attrs: {
              x: point2.x - size3 / 2,
              y: point2.y - size3,
              width: size3,
              height: size3,
              img: cfg.shape[1]
            }
          });
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (points_1_1 && !points_1_1.done && (_a6 = points_1.return))
            _a6.call(points_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return group2;
    }
    return container.addShape("image", {
      attrs: {
        x: pointPosition.x - size3 / 2,
        y: pointPosition.y - size3,
        width: size3,
        height: size3,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/point/solid.js
each_default(SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function(markerCfg) {
      var color3 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color3
        }
      };
    }
  });
});

// node_modules/@antv/g2/esm/geometry/shape/schema/box.js
function parseValue(value2) {
  var array = !is_array_default(value2) ? [value2] : value2;
  var min5 = array[0];
  var max5 = array[array.length - 1];
  var min1 = array.length > 1 ? array[1] : min5;
  var max1 = array.length > 3 ? array[3] : max5;
  var median2 = array.length > 2 ? array[2] : min1;
  return {
    min: min5,
    max: max5,
    min1,
    max1,
    median: median2
  };
}
function getBoxPoints(x, y, size3) {
  var halfSize = size3 / 2;
  var pointsArray;
  if (is_array_default(y)) {
    var _a6 = parseValue(y), min5 = _a6.min, max5 = _a6.max, median2 = _a6.median, min1 = _a6.min1, max1 = _a6.max1;
    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [
      [minX, max5],
      [maxX, max5],
      [x, max5],
      [x, max1],
      [minX, min1],
      [minX, max1],
      [maxX, max1],
      [maxX, min1],
      [x, min1],
      [x, min5],
      [minX, min5],
      [maxX, min5],
      [minX, median2],
      [maxX, median2]
    ];
  } else {
    y = is_nil_default(y) ? 0.5 : y;
    var _b = parseValue(x), min5 = _b.min, max5 = _b.max, median2 = _b.median, min1 = _b.min1, max1 = _b.max1;
    var minY = y - halfSize;
    var maxY2 = y + halfSize;
    pointsArray = [
      [min5, minY],
      [min5, maxY2],
      [min5, y],
      [min1, y],
      [min1, minY],
      [min1, maxY2],
      [max1, maxY2],
      [max1, minY],
      [max1, y],
      [max5, y],
      [max5, minY],
      [max5, maxY2],
      [median2, minY],
      [median2, maxY2]
    ];
  }
  return pointsArray.map(function(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["L", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y],
    ["L", points2[4].x, points2[4].y],
    ["Z"],
    ["M", points2[8].x, points2[8].y],
    ["L", points2[9].x, points2[9].y],
    ["M", points2[10].x, points2[10].y],
    ["L", points2[11].x, points2[11].y],
    ["M", points2[12].x, points2[12].y],
    ["L", points2[13].x, points2[13].y]
  ];
}
registerShape("schema", "box", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
    return getBoxPoints(x, y, size3);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, false);
    var path = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points2 = getBoxPoints(x, yValues, r);
        return [
          ["M", points2[0].x + 1, points2[0].y],
          ["L", points2[1].x - 1, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["M", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["L", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y],
          ["L", points2[4].x, points2[4].y],
          ["Z"],
          ["M", points2[8].x, points2[8].y],
          ["L", points2[9].x, points2[9].y],
          ["M", points2[10].x + 1, points2[10].y],
          ["L", points2[11].x - 1, points2[11].y],
          ["M", points2[12].x, points2[12].y],
          ["L", points2[13].x, points2[13].y]
        ];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/schema/candle.js
function getCandleYValues(value2) {
  var array = !is_array_default(value2) ? [value2] : value2;
  var sorted = array.sort(function(a, b) {
    return b - a;
  });
  return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x, y, size3) {
  var yValues = getCandleYValues(y);
  return [
    { x, y: yValues[0] },
    { x, y: yValues[1] },
    { x: x - size3 / 2, y: yValues[2] },
    { x: x - size3 / 2, y: yValues[1] },
    { x: x + size3 / 2, y: yValues[1] },
    { x: x + size3 / 2, y: yValues[2] },
    { x, y: yValues[2] },
    { x, y: yValues[3] }
  ];
}
function getCandlePath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["L", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["Z"],
    ["M", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y]
  ];
}
registerShape("schema", "candle", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
    return getCandlePoints(x, y, size3);
  },
  draw: function(cfg, container) {
    var style = getStyle2(cfg, true, true);
    var path = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign(__assign({}, style), { path, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points2 = getCandlePoints(x, yValues, r);
        return [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["L", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["Z"],
          ["M", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y]
        ];
      },
      style: {
        lineWidth: 1,
        stroke: color3,
        fill: color3,
        r: 6
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/polygon/square.js
function getRectAttrs(points2, size3) {
  var width = Math.abs(points2[0].x - points2[2].x);
  var height = Math.abs(points2[0].y - points2[2].y);
  var len3 = Math.min(width, height);
  if (size3) {
    len3 = clamp_default(size3, 0, Math.min(width, height));
  }
  len3 = len3 / 2;
  var centerX = (points2[0].x + points2[2].x) / 2;
  var centerY = (points2[0].y + points2[2].y) / 2;
  return {
    x: centerX - len3,
    y: centerY - len3,
    width: len3 * 2,
    height: len3 * 2
  };
}
registerShape("polygon", "square", {
  draw: function(cfg, container) {
    if (!is_empty_default(cfg.points)) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var points2 = this.parsePoints(cfg.points);
      return container.addShape("rect", {
        attrs: __assign(__assign({}, shapeAttrs), getRectAttrs(points2, cfg.size)),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js
registerShape("violin", "smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, true);
    var path = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        stroke: null,
        r: 4,
        fill: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js
registerShape("violin", "hollow", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, false);
    var path = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color3
      }
    };
  }
});
registerShape("violin", "hollow-smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle2(cfg, true, false);
    var path = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign(__assign({}, attrs), { path })
    });
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color3
      }
    };
  }
});

// node_modules/@antv/g2/esm/geometry/label/interval.js
var IntervalLabel = (
  /** @class */
  function(_super) {
    __extends(IntervalLabel2, _super);
    function IntervalLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
      var dim = "y";
      var points2 = mappingData.points;
      return points2[0][dim] <= points2[2][dim] ? 1 : -1;
    };
    IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total, position) {
      var _a6;
      var point2 = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
      var coordinate11 = this.getCoordinate();
      var transposed = coordinate11.isTransposed;
      var dim = transposed ? "x" : "y";
      var dir = this.getLabelValueDir(labelCfg.mappingData);
      point2 = __assign(__assign({}, point2), (_a6 = {}, _a6[dim] = point2[dim] * dir, _a6));
      if (coordinate11.isReflect("x")) {
        point2 = __assign(__assign({}, point2), { x: point2.x * -1 });
      }
      if (coordinate11.isReflect("y")) {
        point2 = __assign(__assign({}, point2), { y: point2.y * -1 });
      }
      return point2;
    };
    IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry35 = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var theme4 = geometry35.theme;
      return deep_mix_default({}, defaultLabelCfg, theme4.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
      var coordinate11 = this.getCoordinate();
      var transposed = coordinate11.isTransposed;
      var shapePoints = mappingData.points;
      var point0 = coordinate11.convert(shapePoints[0]);
      var point2 = coordinate11.convert(shapePoints[2]);
      var dir = this.getLabelValueDir(mappingData);
      var top;
      var right2;
      var bottom;
      var left2;
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      if (shape === "funnel" || shape === "pyramid") {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points2 = get_default(mappingData, "points");
        if (nextPoints) {
          var p0 = coordinate11.convert(points2[0]);
          var p1 = coordinate11.convert(points2[1]);
          var nextP0 = coordinate11.convert(nextPoints[0]);
          var nextP1 = coordinate11.convert(nextPoints[1]);
          if (transposed) {
            top = Math.min(nextP0.y, p0.y);
            bottom = Math.max(nextP0.y, p0.y);
            right2 = (p1.x + nextP1.x) / 2;
            left2 = (p0.x + nextP0.x) / 2;
          } else {
            top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            right2 = nextP1.x;
            left2 = p0.x;
          }
        } else {
          top = Math.min(point2.y, point0.y);
          bottom = Math.max(point2.y, point0.y);
          right2 = point2.x;
          left2 = point0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right2 = point2.x;
        left2 = point0.x;
      }
      switch (position) {
        case "right":
          labelPointCfg.x = right2;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "left":
          labelPointCfg.x = left2;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "bottom":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = bottom;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        case "middle":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", "middle");
          break;
        case "top":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = top;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        default:
          break;
      }
    };
    return IntervalLabel2;
  }(base_default14)
);
var interval_default3 = IntervalLabel;

// node_modules/@antv/g2/esm/geometry/label/polar.js
var HALF_PI = Math.PI / 2;
var PolarLabel = (
  /** @class */
  function(_super) {
    __extends(PolarLabel2, _super);
    function PolarLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate11 = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      } else if (is_string_default(offset) && offset.indexOf("%") !== -1) {
        var r = coordinate11.getRadius();
        if (coordinate11.innerRadius > 0) {
          r = r * (1 - coordinate11.innerRadius);
        }
        actualOffset = parseFloat(offset) * 0.01 * r;
      }
      return actualOffset;
    };
    PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
      var items = _super.prototype.getLabelItems.call(this, mapppingArray);
      var yScale = this.geometry.getYScale();
      return map_default(items, function(item) {
        if (item && yScale) {
          var percent2 = yScale.scale(get_default(item.data, yScale.field));
          return __assign(__assign({}, item), { percent: percent2 });
        }
        return item;
      });
    };
    PolarLabel2.prototype.getLabelAlign = function(point2) {
      var coordinate11 = this.getCoordinate();
      var align;
      if (point2.labelEmit) {
        align = point2.angle <= Math.PI / 2 && point2.angle >= -Math.PI / 2 ? "left" : "right";
      } else if (!coordinate11.isTransposed) {
        align = "center";
      } else {
        var center2 = coordinate11.getCenter();
        var offset = point2.offset;
        if (Math.abs(point2.x - center2.x) < 1) {
          align = "center";
        } else if (point2.angle > Math.PI || point2.angle <= 0) {
          align = offset > 0 ? "left" : "right";
        } else {
          align = offset > 0 ? "right" : "left";
        }
      }
      return align;
    };
    PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var factor = 1;
      var arcPoint;
      var content = labelCfg.content[index];
      if (this.isToMiddle(mappingData)) {
        arcPoint = this.getMiddlePoint(mappingData.points);
      } else {
        if (labelCfg.content.length === 1 && index === 0) {
          index = 1;
        } else if (index === 0) {
          factor = -1;
        }
        arcPoint = this.getArcPoint(mappingData, index);
      }
      var offset = labelCfg.offset * factor;
      var middleAngle = this.getPointAngle(arcPoint);
      var isLabelEmit = labelCfg.labelEmit;
      var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
      if (labelPositionCfg.r === 0) {
        labelPositionCfg.content = "";
      } else {
        labelPositionCfg.content = content;
        labelPositionCfg.angle = middleAngle;
        labelPositionCfg.color = mappingData.color;
      }
      labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
      labelPositionCfg.start = {
        x: arcPoint.x,
        y: arcPoint.y
      };
      return labelPositionCfg;
    };
    PolarLabel2.prototype.getArcPoint = function(mappingData, index) {
      if (index === void 0) {
        index = 0;
      }
      if (!is_array_default(mappingData.x) && !is_array_default(mappingData.y)) {
        return {
          x: mappingData.x,
          y: mappingData.y
        };
      }
      return {
        x: is_array_default(mappingData.x) ? mappingData.x[index] : mappingData.x,
        y: is_array_default(mappingData.y) ? mappingData.y[index] : mappingData.y
      };
    };
    PolarLabel2.prototype.getPointAngle = function(point2) {
      return getAngleByPoint(this.getCoordinate(), point2);
    };
    PolarLabel2.prototype.getCirclePoint = function(angle4, offset, point2, isLabelEmit) {
      var coordinate11 = this.getCoordinate();
      var center2 = coordinate11.getCenter();
      var r = getDistanceToCenter(coordinate11, point2);
      if (r === 0) {
        return __assign(__assign({}, center2), { r });
      }
      var labelAngle = angle4;
      if (coordinate11.isTransposed && r > offset && !isLabelEmit) {
        var appendAngle = Math.asin(offset / (2 * r));
        labelAngle = angle4 + appendAngle * 2;
      } else {
        r = r + offset;
      }
      return {
        x: center2.x + r * Math.cos(labelAngle),
        y: center2.y + r * Math.sin(labelAngle),
        r
      };
    };
    PolarLabel2.prototype.getLabelRotate = function(angle4, offset, isLabelEmit) {
      var rotate5 = angle4 + HALF_PI;
      if (isLabelEmit) {
        rotate5 -= HALF_PI;
      }
      if (rotate5) {
        if (rotate5 > HALF_PI) {
          rotate5 = rotate5 - Math.PI;
        } else if (rotate5 < -HALF_PI) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PolarLabel2.prototype.getMiddlePoint = function(points2) {
      var coordinate11 = this.getCoordinate();
      var count2 = points2.length;
      var middlePoint = {
        x: 0,
        y: 0
      };
      each_default(points2, function(point2) {
        middlePoint.x += point2.x;
        middlePoint.y += point2.y;
      });
      middlePoint.x /= count2;
      middlePoint.y /= count2;
      middlePoint = coordinate11.convert(middlePoint);
      return middlePoint;
    };
    PolarLabel2.prototype.isToMiddle = function(mappingData) {
      return mappingData.x.length > 2;
    };
    return PolarLabel2;
  }(base_default14)
);
var polar_default2 = PolarLabel;

// node_modules/@antv/g2/esm/geometry/label/pie.js
var PieLabel = (
  /** @class */
  function(_super) {
    __extends(PieLabel2, _super);
    function PieLabel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.defaultLayout = "distribute";
      return _this;
    }
    PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
      return deep_mix_default({}, cfg, get_default(this.geometry.theme, "pieLabels", {}));
    };
    PieLabel2.prototype.getLabelOffset = function(offset) {
      return _super.prototype.getLabelOffset.call(this, offset) || 0;
    };
    PieLabel2.prototype.getLabelRotate = function(angle4, offset, isLabelLimit) {
      var rotate5;
      if (offset < 0) {
        rotate5 = angle4;
        if (rotate5 > Math.PI / 2) {
          rotate5 = rotate5 - Math.PI;
        }
        if (rotate5 < -Math.PI / 2) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PieLabel2.prototype.getLabelAlign = function(point2) {
      var coordinate11 = this.getCoordinate();
      var center2 = coordinate11.getCenter();
      var align;
      if (point2.angle <= Math.PI / 2 && point2.x >= center2.x) {
        align = "left";
      } else {
        align = "right";
      }
      if (point2.offset <= 0) {
        if (align === "right") {
          align = "left";
        } else {
          align = "right";
        }
      }
      return align;
    };
    PieLabel2.prototype.getArcPoint = function(point2) {
      return point2;
    };
    PieLabel2.prototype.getPointAngle = function(point2) {
      var coordinate11 = this.getCoordinate();
      var startPoint = {
        x: is_array_default(point2.x) ? point2.x[0] : point2.x,
        y: point2.y[0]
      };
      var endPoint = {
        x: is_array_default(point2.x) ? point2.x[1] : point2.x,
        y: point2.y[1]
      };
      var angle4;
      var startAngle = getAngleByPoint(coordinate11, startPoint);
      if (point2.points && point2.points[0].y === point2.points[1].y) {
        angle4 = startAngle;
      } else {
        var endAngle = getAngleByPoint(coordinate11, endPoint);
        if (startAngle >= endAngle) {
          endAngle = endAngle + Math.PI * 2;
        }
        angle4 = startAngle + (endAngle - startAngle) / 2;
      }
      return angle4;
    };
    PieLabel2.prototype.getCirclePoint = function(angle4, offset) {
      var coordinate11 = this.getCoordinate();
      var center2 = coordinate11.getCenter();
      var r = coordinate11.getRadius() + offset;
      return __assign(__assign({}, polarToCartesian(center2.x, center2.y, r, angle4)), { angle: angle4, r });
    };
    return PieLabel2;
  }(polar_default2)
);
var pie_default = PieLabel;

// node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js
var MARGIN = 4;
function antiCollision(labelShapes, labels, lineHeight, plotRange, center2, isRight) {
  var e_1, _a6;
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label17) {
    if (label17.y > maxY2) {
      maxY2 = label17.y;
    }
    if (label17.y < minY) {
      minY = label17.y;
    }
    return {
      size: lineHeight,
      targets: [label17.y - startY]
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + lineHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};
  try {
    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
      var labelShape = labelShapes_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a6 = labelShapes_1.return))
        _a6.call(labelShapes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  labels.forEach(function(label17) {
    var rPow2 = label17.r * label17.r;
    var dyPow2 = Math.pow(Math.abs(label17.y - center2.y), 2);
    if (rPow2 < dyPow2) {
      label17.x = center2.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        label17.x = center2.x - dx;
      } else {
        label17.x = center2.x + dx;
      }
    }
    var labelShape2 = labelsMap[label17.id];
    labelShape2.attr("x", label17.x);
    labelShape2.attr("y", label17.y);
    var textShape = find_default(labelShape2.getChildren(), function(ele) {
      return ele.get("type") === "text";
    });
    if (textShape) {
      textShape.attr("y", label17.y);
      textShape.attr("x", label17.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset = items[0] ? items[0].offset : 0;
  var coordinate11 = labels[0].get("coordinate");
  var radius = coordinate11.getRadius();
  var center2 = coordinate11.getCenter();
  if (offset > 0) {
    var lineHeight_1 = 14;
    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate11.start,
      end: coordinate11.end
    };
    var halves_1 = [
      [],
      []
      // right
    ];
    items.forEach(function(labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === "right") {
        halves_1[0].push(labelItem);
      } else {
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function(half, index) {
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b["..percent"] - a["..percent"];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      half.sort(function(a, b) {
        return a.y - b.y;
      });
      antiCollision(labels, half, lineHeight_1, plotRange_1, center2, index);
    });
  }
  each_default(items, function(item) {
    if (item && item.labelLine) {
      var distance9 = item.offset;
      var angle4 = item.angle;
      var startPoint = polarToCartesian(center2.x, center2.y, radius, angle4);
      var innerPoint = polarToCartesian(center2.x, center2.y, radius + distance9 / 2, angle4);
      var itemX = item.x + get_default(item, "offsetX", 0);
      var itemY = item.y + get_default(item, "offsetY", 0);
      var endPoint = {
        x: itemX - Math.cos(angle4) * MARGIN,
        y: itemY - Math.sin(angle4) * MARGIN
      };
      if (!is_object_default(item.labelLine)) {
        item.labelLine = {};
      }
      item.labelLine.path = [
        "M ".concat(startPoint.x),
        "".concat(startPoint.y, " Q").concat(innerPoint.x),
        "".concat(innerPoint.y, " ").concat(endPoint.x),
        endPoint.y
      ].join(",");
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
function antiCollision2(items, labelHeight, plotRange) {
  var labels = items.filter(function(item) {
    return !item.invisible;
  });
  labels.sort(function(a, b) {
    return a.y - b.y;
  });
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label17) {
    if (label17.y > maxY2) {
      maxY2 = label17.y;
    }
    if (label17.y < minY) {
      minY = label17.y;
    }
    return {
      content: label17.content,
      size: labelHeight,
      targets: [label17.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      box3.pos = Math.max(0, box3.pos);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + labelHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js
var MARGIN2 = 4;
function drawLabelline(item, coordinate11) {
  var center2 = coordinate11.getCenter();
  var radius = coordinate11.getRadius();
  if (item && item.labelLine) {
    var angle4 = item.angle, labelOffset = item.offset;
    var startPoint = polarToCartesian(center2.x, center2.y, radius, angle4);
    var itemX = item.x + get_default(item, "offsetX", 0) * (Math.cos(angle4) > 0 ? 1 : -1);
    var itemY = item.y + get_default(item, "offsetY", 0) * (Math.sin(angle4) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle4) * MARGIN2,
      y: itemY - Math.sin(angle4) * MARGIN2
    };
    var smoothConnector = item.labelLine.smooth;
    var path = [];
    var dx = endPoint.x - center2.x;
    var dy = endPoint.y - center2.y;
    var endAngle = Math.atan(dy / dx);
    if (dx < 0) {
      endAngle += Math.PI;
    }
    if (smoothConnector === false) {
      if (!is_object_default(item.labelLine)) {
        item.labelLine = {};
      }
      var sweepFlag = 0;
      if (angle4 < 0 && angle4 > -Math.PI / 2 || angle4 > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle4 >= 0 && angle4 < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle4 >= Math.PI / 2 && angle4 < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle4 < -Math.PI / 2 || angle4 >= Math.PI && angle4 < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      var distance9 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + distance9, angle4);
      var breakPoint3 = polarToCartesian(center2.x, center2.y, radius + labelOffset / 2, endAngle);
      var largeArcFlag = 0;
      path.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
      path.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
      path.push("A ".concat(center2.x, " ").concat(center2.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
      path.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
    } else {
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle4);
      var xSign = startPoint.x < center2.x ? 1 : -1;
      path.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
      var slope1 = (startPoint.y - center2.y) / (startPoint.x - center2.x);
      var slope2 = (endPoint.y - center2.y) / (endPoint.x - center2.x);
      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        path.push.apply(path, [
          "C",
          endPoint.x + xSign * 4,
          endPoint.y,
          2 * breakPoint.x - startPoint.x,
          2 * breakPoint.y - startPoint.y,
          startPoint.x,
          startPoint.y
        ]);
      }
      path.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
    }
    item.labelLine.path = path.join(" ");
  }
}
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var e_1, _a6;
  var items = filter_default(originalItems, function(item) {
    return !is_nil_default(item);
  });
  var coordinate11 = labels[0] && labels[0].get("coordinate");
  if (!coordinate11) {
    return;
  }
  var center2 = coordinate11.getCenter();
  var radius = coordinate11.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a6 = labels_1.return))
        _a6.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get_default(items[0], "labelHeight", 14);
  var labelOffset = get_default(items[0], "offset", 0);
  if (labelOffset <= 0) {
    return;
  }
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = group_by_default(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate11.start, end = coordinate11.end;
  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate11.getHeight());
  var totalR = totalHeight / 2;
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalR,
    maxY: center2.y + totalR
  };
  each_default(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each_default(half, function(labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision2(half, labelHeight, labelsContainerRange);
  });
  each_default(separateLabels, function(half, key) {
    each_default(half, function(item) {
      var isRight = key === RIGHT_HALF_KEY;
      var labelShape2 = labelsMap[item.id];
      var content = labelShape2.getChildByIndex(0);
      if (content) {
        var r = radius + labelOffset;
        var dy = item.y - center2.y;
        var rPow2 = Math.pow(r, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r);
        if (!isRight) {
          item.x = center2.x - Math.max(dx, dx_offset);
        } else {
          item.x = center2.x + Math.max(dx, dx_offset);
        }
      }
      if (content) {
        content.attr("y", item.y);
        content.attr("x", item.x);
      }
      drawLabelline(item, coordinate11);
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js
var INFLECTION_OFFSET = 4;
var LABEL_OFFSET_X = 4;
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline2(item, coordinate11, inRight) {
  var center2 = coordinate11.getCenter();
  var radius = coordinate11.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = { x: startPoint.x, y: startPoint.y };
  var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
  var endPoint = polarToCartesian(center2.x, center2.y, radius, item.angle);
  var path = "";
  if (startPoint.y !== inflectionPoint.y) {
    var offset = inRight ? 4 : -4;
    p1.y = startPoint.y;
    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
  }
  path = [
    "M ".concat(startPoint.x, ",").concat(startPoint.y),
    "L ".concat(p1.x, ",").concat(p1.y),
    "L ".concat(p2.x, ",").concat(p2.y),
    "L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
    "L ".concat(endPoint.x, ",").concat(endPoint.y)
  ].join(" ");
  item.labelLine = deep_mix_default({}, item.labelLine, { path });
}
function pieSpiderLabelLayout(items, labels, shapes, region) {
  var e_1, _a6;
  var coordinate11 = labels[0] && labels[0].get("coordinate");
  if (!coordinate11) {
    return;
  }
  var center2 = coordinate11.getCenter();
  var radius = coordinate11.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a6 = labels_1.return))
        _a6.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get_default(items[0], "labelHeight", 14);
  var labelOffset = Math.max(get_default(items[0], "offset", 0), INFLECTION_OFFSET);
  each_default(items, function(item) {
    if (!item)
      return;
    var label17 = get_default(labelsMap, [item.id]);
    if (!label17)
      return;
    var inRight = item.x > center2.x || item.x === center2.x && item.y > center2.y;
    var offsetX = !is_nil_default(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center2.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate11.start, end = coordinate11.end;
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = group_by_default(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  each_default(separateLabels, function(half) {
    var halfHeight = half.length * labelHeight;
    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalHeight / 2,
    maxY: center2.y + totalHeight / 2
  };
  each_default(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each_default(half, function(labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision2(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY;
  each_default(separateLabels, function(half, key) {
    var inRight = key === RIGHT_HALF_KEY;
    each_default(half, function(item) {
      var label17 = get_default(labelsMap, item && [item.id]);
      if (!label17) {
        return;
      }
      if (item.y < startY || item.y > endY) {
        label17.set("visible", false);
        return;
      }
      var labelContent = label17.getChildByIndex(0);
      var box2 = labelContent.getCanvasBBox();
      var originalPos = {
        x: inRight ? box2.x : box2.maxX,
        y: box2.y + box2.height / 2
        /** vertical-align: middle */
      };
      translate2(labelContent, item.x - originalPos.x, item.y - originalPos.y);
      if (item.labelLine) {
        drawLabelline2(item, coordinate11, inRight);
      }
    });
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js
function limitInCanvas(items, labels, shapes, region) {
  each_default(labels, function(label17) {
    var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
    var _a6 = label17.getCanvasBBox(), minX = _a6.minX, minY = _a6.minY, maxX = _a6.maxX, maxY2 = _a6.maxY, x = _a6.x, y = _a6.y, width = _a6.width, height = _a6.height;
    var finalX = x;
    var finalY = y;
    if (minX < regionMinX || maxX < regionMinX) {
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY2 < regionMinY) {
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      finalY = regionMaxY - height;
    } else if (maxY2 > regionMaxY) {
      finalY = finalY - (maxY2 - regionMaxY);
    }
    if (finalX !== x || finalY !== y) {
      translate2(label17, finalX - x, finalY - y);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js
function limitInShape(items, labels, shapes, region) {
  each_default(labels, function(label17, index) {
    var labelBBox = label17.getCanvasBBox();
    var shapeBBox = shapes[index].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label17.remove(true);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/overlap.js
var MAX_TIMES = 100;
var Greedy = (
  /** @class */
  function() {
    function Greedy2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.bitmap = {};
      var _a6 = cfg.xGap, xGap = _a6 === void 0 ? 1 : _a6, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
      this.xGap = xGap;
      this.yGap = yGap;
    }
    Greedy2.prototype.hasGap = function(bbox) {
      var hasGap = true;
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY2 = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
          continue;
        }
        if (i === minX || i === maxX) {
          for (var j = minY; j <= maxY2; j++) {
            if (bitmap[i][j]) {
              hasGap = false;
              break;
            }
          }
        } else {
          if (bitmap[i][minY] || bitmap[i][maxY2]) {
            hasGap = false;
            break;
          }
        }
      }
      return hasGap;
    };
    Greedy2.prototype.fillGap = function(bbox) {
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY2 = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
        }
      }
      for (var i = minX; i <= maxX; i += this.xGap) {
        for (var j = minY; j <= maxY2; j += this.yGap) {
          bitmap[i][j] = true;
        }
        bitmap[i][maxY2] = true;
      }
      if (this.yGap !== 1) {
        for (var i = minY; i <= maxY2; i += 1) {
          bitmap[minX][i] = true;
          bitmap[maxX][i] = true;
        }
      }
      if (this.xGap !== 1) {
        for (var i = minX; i <= maxX; i += 1) {
          bitmap[i][minY] = true;
          bitmap[i][maxY2] = true;
        }
      }
    };
    Greedy2.prototype.destroy = function() {
      this.bitmap = {};
    };
    return Greedy2;
  }()
);
function spiralFill(label17, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a6 = label17.attr(), x = _a6.x, y = _a6.y;
  var bbox = label17.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;
  var f = function(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times2 = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times2 < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache["".concat(dx, "-").concat(dy)]) {
      continue;
    }
    label17.attr({ x: x + dx, y: y + dy });
    if (dx + dy < 0) {
      label17.attr("textAlign", "right");
    }
    times2++;
    if (greedy.hasGap(label17.getCanvasBBox())) {
      greedy.fillGap(label17.getCanvasBBox());
      canFill = true;
      accessedCache["".concat(dx, "-").concat(dy)] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label17, x, y, index) {
  var _a6 = label17.getCanvasBBox(), width = _a6.width, height = _a6.height;
  var attrs = {
    x,
    y,
    textAlign: "center"
  };
  switch (index) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = "left";
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = "right";
      break;
    default:
      break;
  }
  label17.attr(attrs);
  return label17.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each_default(labels, function(label17) {
    var labelShape = label17.find(function(shape) {
      return shape.get("type") === "text";
    });
    if (!spiralFill(labelShape, greedy)) {
      label17.remove(true);
    }
  });
  greedy.destroy();
}
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each_default(labels, function(label17) {
    var labelShape = label17.find(function(shape) {
      return shape.get("type") === "text";
    });
    var _a6 = labelShape.attr(), x = _a6.x, y = _a6.y;
    var canFill = false;
    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label17.remove(true);
    }
  });
  greedy.destroy();
}

// node_modules/@antv/g2/esm/util/collision-detect.js
function dot5(a, b) {
  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
}
function getAxes(points2) {
  if (points2.length > 4) {
    return [];
  }
  var vector = function(start, end) {
    return [end.x - start.x, end.y - start.y];
  };
  var AB = vector(points2[0], points2[1]);
  var BC = vector(points2[1], points2[2]);
  return [AB, BC];
}
function rotateAtPoint(point2, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }
  if (origin === void 0) {
    origin = { x: 0, y: 0 };
  }
  var x = point2.x, y = point2.y;
  return {
    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
  };
}
function getRectPoints2(box2) {
  var points2 = [
    { x: box2.x, y: box2.y },
    { x: box2.x + box2.width, y: box2.y },
    { x: box2.x + box2.width, y: box2.y + box2.height },
    { x: box2.x, y: box2.y + box2.height }
  ];
  var rotation = box2.rotation;
  if (rotation) {
    return [
      rotateAtPoint(points2[0], rotation, points2[0]),
      rotateAtPoint(points2[1], rotation, points2[0]),
      rotateAtPoint(points2[2], rotation, points2[0]),
      rotateAtPoint(points2[3], rotation, points2[0])
    ];
  }
  return points2;
}
function getProjection(points2, axis22) {
  if (points2.length > 4) {
    return { min: 0, max: 0 };
  }
  var scalars = [];
  points2.forEach(function(point2) {
    scalars.push(dot5([point2.x, point2.y], axis22));
  });
  return { min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)), max: Math.max.apply(Math, __spreadArray([], __read(scalars), false)) };
}
function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
  return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box2) {
  return ["x", "y", "width", "height"].every(function(attr) {
    return isValidNumber(box2[attr]);
  });
}
function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
function intersect2(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  if (!isValidBox(box1) || !isValidBox(box2))
    return false;
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2, margin);
  }
  var rect1Points = getRectPoints2(box1);
  var rect2Points = getRectPoints2(box2);
  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
  for (var i = 0; i < axes.length; i++) {
    var axis22 = axes[i];
    var projection1 = getProjection(rect1Points, axis22);
    var projection2 = getProjection(rect2Points, axis22);
    if (!isProjectionOverlap(projection1, projection2)) {
      return false;
    }
  }
  return true;
}

// node_modules/@antv/g2/esm/geometry/label/util/createWorker.js
var MyWorker = (
  /** @class */
  function() {
    function MyWorker2(url) {
      var _this = this;
      this.queue = [];
      this.worker = new Worker(url);
      this.worker.onmessage = function(e) {
        var _a6;
        (_a6 = _this.queue.shift()) === null || _a6 === void 0 ? void 0 : _a6.resolve(e);
      };
      this.worker.onmessageerror = function(e) {
        var _a6;
        console.warn("[AntV G2] Web worker is not available");
        (_a6 = _this.queue.shift()) === null || _a6 === void 0 ? void 0 : _a6.reject(e);
      };
    }
    MyWorker2.prototype.post = function(params, onError) {
      var _this = this;
      return new Promise(function(resolve, reject2) {
        _this.queue.push({ resolve, reject: reject2 });
        try {
          _this.worker.postMessage(params);
        } catch (e) {
          console.warn("[AntV G2] Web worker is not available");
          is_function_default(onError) && onError();
        }
      });
    };
    MyWorker2.prototype.destroy = function() {
      this.worker.terminate();
    };
    return MyWorker2;
  }()
);
function createWorker(f) {
  if (typeof window === "undefined")
    return;
  var blob;
  try {
    blob = new Blob([f.toString()], { type: "application/javascript" });
  } catch (e) {
    blob = new window.BlobBuilder();
    blob.append(f.toString());
    blob = blob.getBlob();
  }
  return new MyWorker(URL.createObjectURL(blob));
}

// node_modules/@antv/g2/esm/geometry/label/layout/worker/hide-overlap.js
var onmessage = function(e) {
  function generateUtils() {
    function dot7(a, b) {
      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
    }
    function getAxes2(points2) {
      if (points2.length > 4) {
        return [];
      }
      var vector = function(start, end) {
        return [end.x - start.x, end.y - start.y];
      };
      var AB = vector(points2[0], points2[1]);
      var BC = vector(points2[1], points2[2]);
      return [AB, BC];
    }
    function rotateAtPoint2(point2, deg, origin) {
      if (deg === void 0) {
        deg = 0;
      }
      if (origin === void 0) {
        origin = { x: 0, y: 0 };
      }
      var x = point2.x, y = point2.y;
      return {
        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
      };
    }
    function getRectPoints3(box2) {
      var points2 = [
        { x: box2.x, y: box2.y },
        { x: box2.x + box2.width, y: box2.y },
        { x: box2.x + box2.width, y: box2.y + box2.height },
        { x: box2.x, y: box2.y + box2.height }
      ];
      var rotation = box2.rotation;
      if (rotation) {
        return [
          rotateAtPoint2(points2[0], rotation, points2[0]),
          rotateAtPoint2(points2[1], rotation, points2[0]),
          rotateAtPoint2(points2[2], rotation, points2[0]),
          rotateAtPoint2(points2[3], rotation, points2[0])
        ];
      }
      return points2;
    }
    function getProjection2(points2, axis22) {
      if (points2.length > 4) {
        return { min: 0, max: 0 };
      }
      var scalars = [];
      points2.forEach(function(point2) {
        scalars.push(dot7([point2.x, point2.y], axis22));
      });
      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };
    }
    function isProjectionOverlap2(projection1, projection2) {
      return projection1.max > projection2.min && projection1.min < projection2.max;
    }
    function isValidNumber2(d) {
      return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
    }
    function isValidBox2(box2) {
      return ["x", "y", "width", "height"].every(function(attr) {
        return isValidNumber2(box2[attr]);
      });
    }
    function isIntersectRect2(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
    }
    function intersect4(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      if (!isValidBox2(box1) || !isValidBox2(box2))
        return false;
      if (!box1.rotation && !box2.rotation) {
        return isIntersectRect2(box1, box2, margin);
      }
      var rect1Points = getRectPoints3(box1);
      var rect2Points = getRectPoints3(box2);
      var axes = getAxes2(rect1Points).concat(getAxes2(rect2Points));
      for (var i = 0; i < axes.length; i++) {
        var axis22 = axes[i];
        var projection1 = getProjection2(rect1Points, axis22);
        var projection2 = getProjection2(rect2Points, axis22);
        if (!isProjectionOverlap2(projection1, projection2))
          return false;
      }
      return true;
    }
    return { intersect: intersect4 };
  }
  var intersect3 = generateUtils().intersect;
  function hideOverlap2(items2) {
    var boxes = items2.slice();
    for (var i = 0; i < boxes.length; i++) {
      var box1 = boxes[i];
      if (box1.visible) {
        for (var j = i + 1; j < boxes.length; j++) {
          var box2 = boxes[j];
          if (box1 !== box2 && box2.visible) {
            if (intersect3(box1, box2)) {
              box2.visible = false;
            }
          }
        }
      }
    }
    return boxes;
  }
  var methods = {
    "hide-overlap": hideOverlap2
  };
  try {
    var eventData = JSON.parse(e.data);
    if (!eventData || !eventData.type || !methods[eventData.type])
      return;
    var type = eventData.type, items = eventData.items;
    var result2 = methods[type](items);
    self.postMessage(result2);
  } catch (e3) {
    throw e3;
  }
};
var code = "\n   self.onmessage = ".concat(onmessage.toString(), "\n");

// node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js
var layout = function(items) {
  var boxes = items.slice();
  for (var i = 0; i < boxes.length; i++) {
    var box1 = boxes[i];
    if (box1.visible) {
      for (var j = i + 1; j < boxes.length; j++) {
        var box2 = boxes[j];
        if (box1 !== box2 && box2.visible) {
          if (intersect2(box1, box2)) {
            box2.visible = false;
          }
        }
      }
    }
  }
  return boxes;
};
var cache2 = /* @__PURE__ */ new Map();
var worker = createWorker(code);
function hideOverlap(labelItems, labels, shapes, region) {
  return __awaiter(this, void 0, void 0, function() {
    var boxes, memoKey, cb, params, res, e_1;
    return __generator(this, function(_a6) {
      switch (_a6.label) {
        case 0:
          boxes = labels.map(function(d, idx) {
            return __assign(__assign({}, getLabelBackgroundInfo(d, labelItems[idx], get_default(labelItems[idx], "background.padding"))), { visible: true });
          });
          memoKey = JSON.stringify(boxes);
          cb = function(items) {
            cache2.set(memoKey, items);
            each_default(items, function(_a7, idx) {
              var visible = _a7.visible;
              var labelShape = labels[idx];
              if (visible) {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();
              } else {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();
              }
            });
            return items;
          };
          if (!cache2.get(memoKey))
            return [3, 1];
          cb(cache2.get(memoKey));
          return [3, 7];
        case 1:
          if (!worker)
            return [3, 6];
          _a6.label = 2;
        case 2:
          _a6.trys.push([2, 4, , 5]);
          params = JSON.stringify({ type: "hide-overlap", items: boxes });
          return [4, worker.post(params, function() {
            return cb(layout(boxes));
          })];
        case 3:
          res = _a6.sent();
          cb(Array.isArray(res.data) ? res.data : []);
          return [3, 5];
        case 4:
          e_1 = _a6.sent();
          console.error(e_1);
          cb(layout(boxes));
          return [3, 5];
        case 5:
          return [3, 7];
        case 6:
          cb(layout(boxes));
          _a6.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}

// node_modules/@antv/g2/esm/util/color.js
var preset = {
  "#5B8FF9": true
};
var isContrastColorWhite = function(color3) {
  var rgb2 = esm_default2.toRGB(color3).toUpperCase();
  if (preset[rgb2]) {
    return preset[rgb2];
  }
  var _a6 = __read(esm_default2.rgb2arr(rgb2), 3), r = _a6[0], g = _a6[1], b = _a6[2];
  var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
  return isDark;
};

// node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js
function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }
  var element = shapes[0].get("element");
  var theme4 = element.geometry.theme;
  var _a6 = theme4.labels || {}, fillColorLight = _a6.fillColorLight, fillColorDark = _a6.fillColorDark;
  shapes.forEach(function(shape, index) {
    var label17 = labels[index];
    var textShape = label17.find(function(el) {
      return el.get("type") === "text";
    });
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr("fill");
    var fillWhite = isContrastColorWhite(bgColor);
    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr("fill", fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr("fill", fillColorDark);
        }
      }
    } else {
      textShape.attr(theme4.overflowLabels.style);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js
function shouldInShapeSingle(geometry35, label17, shape) {
  var coordinate11 = geometry35.coordinate;
  var textShape = findLabelTextShape(label17);
  var textBBox = BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = BBox.fromObject(shape.getBBox());
  return coordinate11.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry35, labels, shapes) {
  var isStack = !!geometry35.getAdjust("stack");
  return isStack || labels.every(function(label17, index) {
    var shape = shapes[index];
    return shouldInShapeSingle(geometry35, label17, shape);
  });
}
function moveInShape(geometry35, label17, shape) {
  var coordinate11 = geometry35.coordinate;
  var shapeBBox = BBox.fromObject(shape.getBBox());
  var textShape = findLabelTextShape(label17);
  if (coordinate11.isTransposed) {
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: "center"
    });
  } else {
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: "middle"
    });
  }
}
function intervalAdjustPosition(items, labels, shapes) {
  var _a6;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a6 = shapes[0]) === null || _a6 === void 0 ? void 0 : _a6.get("element");
  var geometry35 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry35 || geometry35.type !== "interval") {
    return;
  }
  var inShape = shouldInShape(geometry35, labels, shapes);
  if (inShape) {
    shapes.forEach(function(shape, index) {
      var label17 = labels[index];
      moveInShape(geometry35, label17, shape);
    });
  }
}

// node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js
function filterLabel(labels) {
  var MAX_CNT = 500;
  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  each_default(labels, function(label17, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label17);
    } else {
      label17.set("visible", false);
    }
  });
  return filteredLabels;
}
function intervalHideOverlap(items, labels, shapes) {
  var _a6;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a6 = shapes[0]) === null || _a6 === void 0 ? void 0 : _a6.get("element");
  var geometry35 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry35 || geometry35.type !== "interval") {
    return;
  }
  var filteredLabels = filterLabel(labels);
  var _b = __read(geometry35.getXYFields(), 1), xField = _b[0];
  var dones = [];
  var todo = [];
  var groupedLabels = group_by_default(filteredLabels, function(label17) {
    return label17.get("data")[xField];
  });
  var xValues = uniq(map_default(filteredLabels, function(label17) {
    return label17.get("data")[xField];
  }));
  var xValue;
  filteredLabels.forEach(function(label17) {
    label17.set("visible", true);
  });
  var addCurrentGroup = function(curItems) {
    if (curItems) {
      if (curItems.length) {
        todo.push(curItems.pop());
      }
      todo.push.apply(todo, __spreadArray([], __read(curItems), false));
    }
  };
  if (size(xValues) > 0) {
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }
  if (size(xValues) > 0) {
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }
  each_default(xValues.reverse(), function(val) {
    addCurrentGroup(groupedLabels[val]);
  });
  while (todo.length > 0) {
    var cur = todo.shift();
    if (cur.get("visible")) {
      if (checkShapeOverlap(cur, dones)) {
        cur.set("visible", false);
      } else {
        dones.push(cur);
      }
    }
  }
}

// node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js
function sortLabels(geometry35, labels) {
  var yField = geometry35.getXYFields()[1];
  var result2 = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result2.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result2.push(sortedLabels.pop());
  }
  result2.push.apply(result2, __spreadArray([], __read(sortedLabels), false));
  return result2;
}
function hasSome(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea2(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap2(dones, current) {
  return hasSome(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea2(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a6, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a6 = shapes[0]) === null || _a6 === void 0 ? void 0 : _a6.get("element");
  var geometry35 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry35 || geometry35.type !== "point") {
    return;
  }
  var _c = __read(geometry35.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = group_by_default(labels, function(label17) {
    return label17.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map_default(keys_default(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels(geometry35, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap2(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap2(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}

// node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js
function sortLabels2(geometry35, labels) {
  var yField = geometry35.getXYFields()[1];
  var result2 = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result2.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result2.push(sortedLabels.pop());
  }
  result2.push.apply(result2, __spreadArray([], __read(sortedLabels), false));
  return result2;
}
function hasSome2(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea3(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap3(dones, current) {
  return hasSome2(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea3(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a6, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a6 = shapes[0]) === null || _a6 === void 0 ? void 0 : _a6.get("element");
  var geometry35 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry35 || ["path", "line", "area"].indexOf(geometry35.type) < 0) {
    return;
  }
  var _c = __read(geometry35.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = group_by_default(labels, function(label17) {
    return label17.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map_default(keys_default(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels2(geometry35, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome2(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap3(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap3(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}

// node_modules/@antv/g2/esm/util/context.js
var ctx2;
function getCanvasContext() {
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  return ctx2;
}

// node_modules/@antv/g2/esm/util/text.js
var measureTextWidth = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx4 = getCanvasContext();
  ctx4.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx4.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray([text], __read(values_default(font)), false).join("");
});
var getEllipsisText = function(text, maxWidth, font) {
  var STEP = 16;
  var DOT_WIDTH = measureTextWidth("...", font);
  var leftText;
  if (!is_string_default(text)) {
    leftText = to_string_default(text);
  } else {
    leftText = text;
  }
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth(text, font) <= maxWidth) {
    return text;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "".concat(r.join(""), "...");
};

// node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js
function limitInPlot(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }
  var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate11 = labels[0].get("coordinate");
  if (!coordinate11) {
    return;
  }
  var _a6 = getCoordinateBBox(coordinate11, margin), regionMinX = _a6.minX, regionMinY = _a6.minY, regionMaxX = _a6.maxX, regionMaxY = _a6.maxY;
  each_default(labels, function(label17) {
    var _a7 = label17.getCanvasBBox(), minX = _a7.minX, minY = _a7.minY, maxX = _a7.maxX, maxY2 = _a7.maxY, x = _a7.x, y = _a7.y, width = _a7.width, height = _a7.height;
    var finalX = x;
    var finalY = y;
    if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      finalX = regionMinX;
    }
    if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY2 < regionMinY)) {
      finalY = regionMinY;
    }
    if (direction2.indexOf("right") >= 0) {
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
    }
    if (direction2.indexOf("bottom") >= 0) {
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY2 > regionMaxY) {
        finalY = finalY - (maxY2 - regionMaxY);
      }
    }
    if (finalX !== x || finalY !== y) {
      var translateX_1 = finalX - x;
      if (action === "translate") {
        translate2(label17, translateX_1, finalY - y);
      } else if (action === "ellipsis") {
        var textShapes = label17.findAll(function(shape) {
          return shape.get("type") === "text";
        });
        textShapes.forEach(function(textShape) {
          var style = pick_default(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
          var textBox = textShape.getCanvasBBox();
          var text = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
          textShape.attr("text", text);
        });
      } else {
        label17.hide();
      }
    }
  });
}

// node_modules/@antv/g2/esm/animate/animation/fade.js
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: is_nil_default(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
    strokeOpacity: is_nil_default(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
    opacity: is_nil_default(shape.attr("opacity")) ? 1 : shape.attr("opacity")
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing, duration = animateCfg.duration, delay2 = animateCfg.delay;
  shape.animate(endState, duration, easing, function() {
    shape.remove(true);
  }, delay2);
}

// node_modules/@antv/g2/esm/animate/animation/util.js
function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var _a6 = __read(vector, 2), x = _a6[0], y = _a6[1];
  shape.applyToMatrix([x, y, 1]);
  if (direct === "x") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ]);
  } else if (direct === "y") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ]);
  } else if (direct === "xy") {
    shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 100],
      ["t", x, y]
    ]);
  }
  return scaledMatrix;
}
function doScaleAnimate(element, animateCfg, coordinate11, yMinPoint, type) {
  var start = coordinate11.start, end = coordinate11.end;
  var width = coordinate11.getWidth();
  var height = coordinate11.getHeight();
  var x;
  var y;
  if (type === "y") {
    x = start.x + width / 2;
    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type === "x") {
    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y = start.y + height / 2;
  } else if (type === "xy") {
    if (coordinate11.isPolar) {
      x = coordinate11.getCenter().x;
      y = coordinate11.getCenter().y;
    } else {
      x = (start.x + end.x) / 2;
      y = (start.y + end.y) / 2;
    }
  }
  var endMatrix = transformShape(element, [x, y], type);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/grow-in.js
function growInX(element, animateCfg, cfg) {
  var coordinate11 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate11, minYPoint, "x");
}
function growInY(element, animateCfg, cfg) {
  var coordinate11 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate11, minYPoint, "y");
}
function growInXY(element, animateCfg, cfg) {
  var coordinate11 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate11, minYPoint, "xy");
}

// node_modules/@antv/g2/esm/animate/animation/path-in.js
function pathIn(element, animateCfg, cfg) {
  var length5 = element.getTotalLength();
  element.attr("lineDash", [length5]);
  element.animate(function(ratio) {
    return {
      // 
      lineDashOffset: (1 - ratio) * length5
    };
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/position-update.js
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  var x = toAttrs.x;
  var y = toAttrs.y;
  delete toAttrs.x;
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x,
    y
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/scale-in.js
function scaleInX(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var points2 = mappingData.points;
  var x = points2[0].y - points2[1].y > 0 ? box2.maxX : box2.minX;
  var y = (box2.minY + box2.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = ext_exports.transform(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 0.01, 1],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ])
  }, animateCfg);
}
function scaleInY(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var x = (box2.minX + box2.maxX) / 2;
  var points2 = mappingData.points;
  var y = points2[0].y - points2[1].y <= 0 ? box2.maxY : box2.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = ext_exports.transform(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 1, 0.01],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ])
  }, animateCfg);
}

// node_modules/@antv/g2/esm/animate/animation/sector-path-update.js
function getAngle3(startPoint, arcPath) {
  var _a6;
  var _b = getArcParams2(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    _a6 = __read([endAngle, startAngle], 2), startAngle = _a6[0], endAngle = _a6[1];
  }
  if (isNumberEqual(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle,
    endAngle
  };
}
function getArcStartPoint(path) {
  var startPoint;
  if (path[0] === "M" || path[0] === "L") {
    startPoint = [path[1], path[2]];
  } else if (path[0] === "a" || path[0] === "A" || path[0] === "C") {
    startPoint = [path[path.length - 2], path[path.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path) {
  var _a6;
  var startAngle;
  var endAngle;
  var arcPaths = path.filter(function(command) {
    return command[0] === "A" || command[0] === "a";
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path.indexOf(firstArcPathCommand);
  var lastIndex = path.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
  var _b = getAngle3(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
  var _c = getAngle3(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a6 = __read([innerRadius, radius], 2), radius = _a6[0], innerRadius = _a6[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle,
    endAngle,
    radius,
    innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs, coordinate11 = cfg.coordinate;
  var path = toAttrs.path || [];
  var pathCommands = path.map(function(command) {
    return command[0];
  });
  if (path.length < 1)
    return;
  var _a6 = getArcInfo(path), curStartAngle = _a6.startAngle, curEndAngle = _a6.endAngle, radius = _a6.radius, innerRadius = _a6.innerRadius;
  var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
  var center2 = coordinate11.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr("path", path);
    return;
  }
  shape.animate(function(ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return __assign(__assign({}, toAttrs), { path: (
      // hack,  /examples/bar/basic/demo/radial-line.ts 
      is_equal_default(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)
    ) });
  }, __assign(__assign({}, animateCfg), { callback: function() {
    shape.attr("path", path);
    is_function_default(animateCfg.callback) && animateCfg.callback();
  } }));
}

// node_modules/@antv/g2/esm/animate/animation/wave-in.js
function waveIn(element, animateCfg, cfg) {
  var _a6 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a6.type, startState = _a6.startState, endState = _a6.endState;
  var clipShape = element.setClip({
    type,
    attrs: startState
  });
  if (cfg.toAttrs) {
    element.attr(cfg.toAttrs);
  }
  clipShape.animate(endState, __assign(__assign({}, animateCfg), { callback: function() {
    if (element && !element.get("destroyed")) {
      element.set("clipShape", null);
    }
    clipShape.remove(true);
    is_function_default(animateCfg.callback) && animateCfg.callback();
  } }));
}

// node_modules/@antv/g2/esm/animate/animation/zoom.js
function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    each_default(shape.getChildren(), function(child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    if (type === "zoomIn") {
      var matrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 100, 100],
          ["t", x, y]
        ])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ])
      }, __assign(__assign({}, animateCfg), { callback: function() {
        shape.remove(true);
        is_function_default(animateCfg.callback) && animateCfg.callback();
      } }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomIn");
}
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomOut");
}

// node_modules/@antv/g2/esm/util/facet.js
function getFactTitleConfig(direction2) {
  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
    return {
      offsetX: 0,
      offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: "center",
        textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
      }
    };
  }
  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
    return {
      offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
        textBaseline: "middle",
        rotate: Math.PI / 2
        // 
      }
    };
  }
  return {};
}
function getAnglePoint(center2, r, angle4) {
  return {
    x: center2.x + r * Math.cos(angle4),
    y: center2.y + r * Math.sin(angle4)
  };
}

// node_modules/@antv/g2/esm/facet/circle.js
var Circle5 = (
  /** @class */
  function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "circle",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Circle6.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Circle6.prototype.getRegion = function(count2, index) {
      var r = 1 / 2;
      var center2 = { x: 0.5, y: 0.5 };
      var avgAngle = Math.PI * 2 / count2;
      var angle4 = -1 * Math.PI / 2 + avgAngle * index;
      var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
      var middle = getAnglePoint(center2, r - facetR, angle4);
      var startAngle = Math.PI * 5 / 4;
      var endAngle = Math.PI * 1 / 4;
      return {
        start: getAnglePoint(middle, facetR, startAngle),
        end: getAnglePoint(middle, facetR, endAngle)
      };
    };
    Circle6.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Circle6.prototype.beforeEachView = function(view, facet) {
    };
    Circle6.prototype.generateFacets = function(data3) {
      var _this = this;
      var _a6 = this.cfg, fields = _a6.fields, type = _a6.type;
      var _b = __read(fields, 1), field6 = _b[0];
      if (!field6) {
        throw new Error("No `fields` specified!");
      }
      var values3 = this.getFieldValues(data3, field6);
      var count2 = values3.length;
      var rst = [];
      values3.forEach(function(value2, index) {
        var conditions = [{ field: field6, value: value2, values: values3 }];
        var facetData = filter_default(data3, _this.getFacetDataFilter(conditions));
        var facet = {
          type,
          data: facetData,
          region: _this.getRegion(count2, index),
          columnValue: value2,
          columnField: field6,
          columnIndex: index,
          columnValuesLength: count2,
          rowValue: null,
          rowField: null,
          rowIndex: 0,
          rowValuesLength: 1
        };
        rst.push(facet);
      });
      return rst;
    };
    Circle6.prototype.getXAxisOption = function(x, axes, option, facet) {
      return option;
    };
    Circle6.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Circle6.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    return Circle6;
  }(Facet)
);
var circle_default7 = Circle5;

// node_modules/@antv/g2/esm/facet/list.js
var List = (
  /** @class */
  function(_super) {
    __extends(List2, _super);
    function List2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    List2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "list",
        cols: null,
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    List2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    List2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    List2.prototype.beforeEachView = function(view, facet) {
    };
    List2.prototype.generateFacets = function(data3) {
      var _this = this;
      var fields = this.cfg.fields;
      var cols = this.cfg.cols;
      var _a6 = __read(fields, 1), columnField = _a6[0];
      if (!columnField) {
        throw new Error("No `fields` specified!");
      }
      var colValues = this.getFieldValues(data3, columnField);
      var count2 = colValues.length;
      cols = cols || count2;
      var rows = this.getPageCount(count2, cols);
      var rst = [];
      colValues.forEach(function(val, index) {
        var _a7 = _this.getRowCol(index, cols), row = _a7.row, col = _a7.col;
        var conditions = [{ field: columnField, value: val, values: colValues }];
        var facetData = filter_default(data3, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rows, cols, col, row),
          columnValue: val,
          rowValue: val,
          columnField,
          rowField: null,
          columnIndex: col,
          rowIndex: row,
          columnValuesLength: cols,
          rowValuesLength: rows,
          total: count2
        };
        rst.push(facet);
      });
      return rst;
    };
    List2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    List2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    List2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    List2.prototype.getPageCount = function(total, pageSize) {
      return Math.floor((total + pageSize - 1) / pageSize);
    };
    List2.prototype.getRowCol = function(index, pageSize) {
      var row = Math.floor(index / pageSize);
      var col = index % pageSize;
      return { row, col };
    };
    return List2;
  }(Facet)
);
var list_default = List;

// node_modules/@antv/g2/esm/facet/matrix.js
var Matrix = (
  /** @class */
  function(_super) {
    __extends(Matrix2, _super);
    function Matrix2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Matrix2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "matrix",
        showTitle: false,
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Matrix2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Matrix2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Matrix2.prototype.beforeEachView = function(view, facet) {
    };
    Matrix2.prototype.generateFacets = function(data3) {
      var _a6 = this.cfg, fields = _a6.fields, type = _a6.type;
      var rowValuesLength = fields.length;
      var columnValuesLength = rowValuesLength;
      var rst = [];
      for (var i = 0; i < columnValuesLength; i++) {
        var columnField = fields[i];
        for (var j = 0; j < rowValuesLength; j++) {
          var rowField = fields[j];
          var facet = {
            type,
            data: data3,
            region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
            columnValue: columnField,
            rowValue: rowField,
            columnField,
            rowField,
            columnIndex: i,
            rowIndex: j,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        }
      }
      return rst;
    };
    Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Matrix2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, rowValuesLength = facet.rowValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    return Matrix2;
  }(Facet)
);
var matrix_default = Matrix;

// node_modules/@antv/g2/esm/facet/mirror.js
var Mirror = (
  /** @class */
  function(_super) {
    __extends(Mirror2, _super);
    function Mirror2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Mirror2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "mirror",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this),
        transpose: false
      });
    };
    Mirror2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Mirror2.prototype.beforeEachView = function(view, facet) {
      if (this.cfg.transpose) {
        if (facet.columnIndex % 2 === 0) {
          view.coordinate().transpose().reflect("x");
        } else {
          view.coordinate().transpose();
        }
      } else {
        if (facet.rowIndex % 2 !== 0) {
          view.coordinate().reflect("y");
        }
      }
    };
    Mirror2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Mirror2.prototype.generateFacets = function(data3) {
      var _this = this;
      var _a6 = __read(this.cfg.fields, 1), f = _a6[0];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      var columnField;
      var rowField;
      if (this.cfg.transpose) {
        columnField = f;
        columnValues = this.getFieldValues(data3, columnField).slice(0, 2);
        columnValuesLength = columnValues.length;
      } else {
        rowField = f;
        rowValues = this.getFieldValues(data3, rowField).slice(0, 2);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data3, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.columnIndex === 1 || facet.rowIndex === 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Mirror2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        if (_this.cfg.transpose) {
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
          view.annotation().text(config);
        } else {
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
          view.annotation().text(config);
        }
      });
    };
    return Mirror2;
  }(Facet)
);
var mirror_default = Mirror;

// node_modules/@antv/g2/esm/facet/rect.js
var Rect3 = (
  /** @class */
  function(_super) {
    __extends(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Rect4.prototype.beforeEachView = function(view, facet) {
    };
    Rect4.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "rect",
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Rect4.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Rect4.prototype.generateFacets = function(data3) {
      var _this = this;
      var _a6 = __read(this.cfg.fields, 2), columnField = _a6[0], rowField = _a6[1];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      if (columnField) {
        columnValues = this.getFieldValues(data3, columnField);
        columnValuesLength = columnValues.length;
      }
      if (rowField) {
        rowValues = this.getFieldValues(data3, rowField);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data3, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Rect4.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    Rect4.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    Rect4.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    return Rect4;
  }(Facet)
);
var rect_default4 = Rect3;

// node_modules/@antv/g2/esm/facet/tree.js
var Tree = (
  /** @class */
  function(_super) {
    __extends(Tree2, _super);
    function Tree2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.afterChartRender = function() {
        if (_this.facets && _this.cfg.line) {
          _this.container.clear();
          _this.drawLines(_this.facets);
        }
      };
      return _this;
    }
    Tree2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Tree2.prototype.beforeEachView = function(view, facet) {
    };
    Tree2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
    };
    Tree2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "tree",
        line: {
          style: {
            lineWidth: 1,
            stroke: "#ddd"
          },
          smooth: false
        },
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Tree2.prototype.generateFacets = function(data3) {
      var fields = this.cfg.fields;
      if (!fields.length) {
        throw new Error("Please specify for the fields for rootFacet!");
      }
      var rst = [];
      var rootFacet = {
        type: this.cfg.type,
        data: data3,
        region: null,
        rowValuesLength: this.getRows(),
        columnValuesLength: 1,
        rowIndex: 0,
        columnIndex: 0,
        rowField: "",
        columnField: "",
        rowValue: "",
        columnValue: ""
      };
      rst.push(rootFacet);
      rootFacet.children = this.getChildFacets(data3, 1, rst);
      this.setRegion(rst);
      return rst;
    };
    Tree2.prototype.setRegion = function(facets) {
      var _this = this;
      this.forceColIndex(facets);
      facets.forEach(function(facet) {
        facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
      });
    };
    Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var xWidth = 1 / cols;
      var yWidth = 1 / rows;
      var start = {
        x: xWidth * xIndex,
        y: yWidth * yIndex
      };
      var end = {
        x: start.x + xWidth,
        y: start.y + yWidth * 2 / 3
        // 1/3
      };
      return {
        start,
        end
      };
    };
    Tree2.prototype.forceColIndex = function(facets) {
      var e_1, _a6;
      var _this = this;
      var leafs = [];
      var index = 0;
      facets.forEach(function(facet2) {
        if (_this.isLeaf(facet2)) {
          leafs.push(facet2);
          facet2.columnIndex = index;
          index++;
        }
      });
      leafs.forEach(function(facet2) {
        facet2.columnValuesLength = leafs.length;
      });
      var maxLevel = this.cfg.fields.length;
      for (var i = maxLevel - 1; i >= 0; i--) {
        var levelFacets = this.getFacetsByLevel(facets, i);
        try {
          for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
            var facet = levelFacets_1_1.value;
            if (!this.isLeaf(facet)) {
              facet.originColIndex = facet.columnIndex;
              facet.columnIndex = this.getRegionIndex(facet.children);
              facet.columnValuesLength = leafs.length;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (levelFacets_1_1 && !levelFacets_1_1.done && (_a6 = levelFacets_1.return))
              _a6.call(levelFacets_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    };
    Tree2.prototype.getFacetsByLevel = function(facets, level) {
      var rst = [];
      facets.forEach(function(facet) {
        if (facet.rowIndex === level) {
          rst.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.getRegionIndex = function(children) {
      var first = children[0];
      var last3 = children[children.length - 1];
      return (last3.columnIndex - first.columnIndex) / 2 + first.columnIndex;
    };
    Tree2.prototype.isLeaf = function(facet) {
      return !facet.children || !facet.children.length;
    };
    Tree2.prototype.getRows = function() {
      return this.cfg.fields.length + 1;
    };
    Tree2.prototype.getChildFacets = function(data3, level, arr) {
      var _this = this;
      var fields = this.cfg.fields;
      var length5 = fields.length;
      if (length5 < level) {
        return;
      }
      var rst = [];
      var field6 = fields[level - 1];
      var values3 = this.getFieldValues(data3, field6);
      values3.forEach(function(value2, index) {
        var conditions = [{ field: field6, value: value2, values: values3 }];
        var subData = data3.filter(_this.getFacetDataFilter(conditions));
        if (subData.length) {
          var facet = {
            type: _this.cfg.type,
            data: subData,
            region: null,
            columnValue: value2,
            rowValue: "",
            columnField: field6,
            rowField: "",
            columnIndex: index,
            rowValuesLength: _this.getRows(),
            columnValuesLength: 1,
            rowIndex: level,
            children: _this.getChildFacets(subData, level + 1, arr)
          };
          rst.push(facet);
          arr.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Tree2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    Tree2.prototype.drawLines = function(facets) {
      var _this = this;
      facets.forEach(function(facet) {
        if (!_this.isLeaf(facet)) {
          var children = facet.children;
          _this.addFacetLines(facet, children);
        }
      });
    };
    Tree2.prototype.addFacetLines = function(facet, children) {
      var _this = this;
      var view = facet.view;
      var region = view.coordinateBBox;
      var start = {
        x: region.x + region.width / 2,
        y: region.y + region.height
      };
      children.forEach(function(subFacet) {
        var subRegion = subFacet.view.coordinateBBox;
        var end = {
          x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
          y: subRegion.tr.y
        };
        var middle1 = {
          x: start.x,
          y: start.y + (end.y - start.y) / 2
        };
        var middle2 = {
          x: end.x,
          y: middle1.y
        };
        _this.drawLine([start, middle1, middle2, end]);
      });
    };
    Tree2.prototype.getPath = function(points2) {
      var path = [];
      var smooth = this.cfg.line.smooth;
      if (smooth) {
        path.push(["M", points2[0].x, points2[0].y]);
        path.push(["C", points2[1].x, points2[1].y, points2[2].x, points2[2].y, points2[3].x, points2[3].y]);
      } else {
        points2.forEach(function(point2, index) {
          if (index === 0) {
            path.push(["M", point2.x, point2.y]);
          } else {
            path.push(["L", point2.x, point2.y]);
          }
        });
      }
      return path;
    };
    Tree2.prototype.drawLine = function(points2) {
      var path = this.getPath(points2);
      var line2 = this.cfg.line.style;
      this.container.addShape("path", {
        attrs: mix({
          // @ts-ignore
          path
        }, line2)
      });
    };
    Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    return Tree2;
  }(Facet)
);
var tree_default = Tree;

// node_modules/@antv/g2/esm/util/stat.js
function getMedian(array) {
  var arr = __spreadArray([], __read(array), false);
  arr.sort(function(a, b) {
    return a - b;
  });
  var len3 = arr.length;
  if (len3 === 0) {
    return 0;
  }
  if (len3 % 2 === 1) {
    return arr[(len3 - 1) / 2];
  }
  return (arr[len3 / 2] + arr[len3 / 2 - 1]) / 2;
}
function getMean(array) {
  var sum2 = reduce_default(array, function(r, num) {
    return r += isNaN(num) || !is_number_default(num) ? 0 : num;
  }, 0);
  return array.length === 0 ? 0 : sum2 / array.length;
}

// node_modules/@antv/g2/esm/util/annotation.js
function getNormalizedValue(val, scale8) {
  if (!scale8) {
    return null;
  }
  var scaled;
  switch (val) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    case "median": {
      scaled = scale8.isCategory ? getMedian(scale8.values.map(function(_, idx) {
        return idx;
      })) : getMedian(scale8.values);
      break;
    }
    case "mean": {
      scaled = scale8.isCategory ? (scale8.values.length - 1) / 2 : getMean(scale8.values);
      break;
    }
    case "min":
      scaled = scale8.isCategory ? 0 : scale8[val];
      break;
    case "max":
      scaled = scale8.isCategory ? scale8.values.length - 1 : scale8[val];
      break;
    default:
      scaled = val;
      break;
  }
  return scale8.scale(scaled);
}

// node_modules/@antv/g2/esm/chart/controller/annotation.js
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
var Annotation = (
  /** @class */
  function(_super) {
    __extends(Annotation2, _super);
    function Annotation2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = /* @__PURE__ */ new Map();
      _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.option = [];
      return _this;
    }
    Object.defineProperty(Annotation2.prototype, "name", {
      get: function() {
        return "annotation";
      },
      enumerable: false,
      configurable: true
    });
    Annotation2.prototype.init = function() {
    };
    Annotation2.prototype.layout = function() {
      this.update();
    };
    Annotation2.prototype.render = function() {
    };
    Annotation2.prototype.update = function() {
      var _this = this;
      this.onAfterRender(function() {
        var updated = /* @__PURE__ */ new Map();
        each_default(_this.option, function(option) {
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            var co = _this.updateOrCreate(option);
            if (co) {
              updated.set(_this.getCacheKey(option), co);
            }
          }
        });
        _this.cache = _this.syncCache(updated);
      });
      var updateCache = /* @__PURE__ */ new Map();
      each_default(this.option, function(option) {
        if (!contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updateCache.set(_this.getCacheKey(option), co);
          }
        }
      });
      this.cache = this.syncCache(updateCache);
    };
    Annotation2.prototype.clear = function(includeOption) {
      if (includeOption === void 0) {
        includeOption = false;
      }
      _super.prototype.clear.call(this);
      this.clearComponents();
      this.foregroundContainer.clear();
      this.backgroundContainer.clear();
      if (includeOption) {
        this.option = [];
      }
    };
    Annotation2.prototype.destroy = function() {
      this.clear(true);
      this.foregroundContainer.remove(true);
      this.backgroundContainer.remove(true);
    };
    Annotation2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value2) {
        co.push(value2);
      });
      return co;
    };
    Annotation2.prototype.clearComponents = function() {
      this.getComponents().forEach(function(co) {
        co.component.destroy();
      });
      this.cache.clear();
    };
    Annotation2.prototype.onAfterRender = function(doWhat) {
      var done = false;
      if (this.view.getOptions().animate) {
        this.view.geometries.forEach(function(g) {
          if (g.animateOption) {
            g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
              doWhat();
            });
            done = true;
          }
        });
      }
      if (!done) {
        this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
          doWhat();
        });
      }
    };
    Annotation2.prototype.createAnnotation = function(option) {
      var type = option.type;
      var Ctor = annotation_exports[upper_first_default(type)];
      if (Ctor) {
        var theme4 = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme4);
        if (!cfg) {
          return null;
        }
        var annotation4 = new Ctor(cfg);
        return {
          component: annotation4,
          layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.ANNOTATION,
          extra: option
        };
      }
    };
    Annotation2.prototype.annotation = function(option) {
      this.option.push(option);
    };
    Annotation2.prototype.arc = function(option) {
      this.annotation(__assign({ type: "arc" }, option));
      return this;
    };
    Annotation2.prototype.image = function(option) {
      this.annotation(__assign({ type: "image" }, option));
      return this;
    };
    Annotation2.prototype.line = function(option) {
      this.annotation(__assign({ type: "line" }, option));
      return this;
    };
    Annotation2.prototype.region = function(option) {
      this.annotation(__assign({ type: "region" }, option));
      return this;
    };
    Annotation2.prototype.text = function(option) {
      this.annotation(__assign({ type: "text" }, option));
      return this;
    };
    Annotation2.prototype.dataMarker = function(option) {
      this.annotation(__assign({ type: "dataMarker" }, option));
      return this;
    };
    Annotation2.prototype.dataRegion = function(option) {
      this.annotation(__assign({ type: "dataRegion" }, option));
    };
    Annotation2.prototype.regionFilter = function(option) {
      this.annotation(__assign({ type: "regionFilter" }, option));
    };
    Annotation2.prototype.shape = function(option) {
      this.annotation(__assign({ type: "shape" }, option));
    };
    Annotation2.prototype.html = function(option) {
      this.annotation(__assign({ type: "html" }, option));
    };
    Annotation2.prototype.parsePosition = function(p) {
      var e_1, _a6;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var position = is_function_default(p) ? p.call(null, xScale, yScales) : p;
      var x = 0;
      var y = 0;
      if (is_array_default(position)) {
        var _b = __read(position, 2), xPos = _b[0], yPos = _b[1];
        if (is_string_default(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
          return this.parsePercentPosition(position);
        }
        x = getNormalizedValue(xPos, xScale);
        y = getNormalizedValue(yPos, Object.values(yScales)[0]);
      } else if (!is_nil_default(position)) {
        try {
          for (var _c = __values(keys_default(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var key = _d.value;
            var value2 = position[key];
            if (key === xScale.field) {
              x = getNormalizedValue(value2, xScale);
            }
            if (yScales[key]) {
              y = getNormalizedValue(value2, yScales[key]);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a6 = _c.return))
              _a6.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      if (isNaN(x) || isNaN(y)) {
        return null;
      }
      return this.view.getCoordinate().convert({ x, y });
    };
    Annotation2.prototype.getRegionPoints = function(start, end) {
      var _this = this;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var yScale = Object.values(yScales)[0];
      var xField = xScale.field;
      var viewData = this.view.getData();
      var startXValue = is_array_default(start) ? start[0] : start[xField];
      var endXValue = is_array_default(end) ? end[0] : end[xField];
      var arr = [];
      var startIndex;
      each_default(viewData, function(item, idx) {
        if (item[xField] === startXValue) {
          startIndex = idx;
        }
        if (idx >= startIndex) {
          var point2 = _this.parsePosition([item[xField], item[yScale.field]]);
          if (point2) {
            arr.push(point2);
          }
        }
        if (item[xField] === endXValue) {
          return false;
        }
      });
      return arr;
    };
    Annotation2.prototype.parsePercentPosition = function(position) {
      var xPercent = parseFloat(position[0]) / 100;
      var yPercent = parseFloat(position[1]) / 100;
      var coordinate11 = this.view.getCoordinate();
      var start = coordinate11.start, end = coordinate11.end;
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      var x = coordinate11.getWidth() * xPercent + topLeft.x;
      var y = coordinate11.getHeight() * yPercent + topLeft.y;
      return { x, y };
    };
    Annotation2.prototype.getCoordinateBBox = function() {
      var coordinate11 = this.view.getCoordinate();
      var start = coordinate11.start, end = coordinate11.end;
      var width = coordinate11.getWidth();
      var height = coordinate11.getHeight();
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      return {
        x: topLeft.x,
        y: topLeft.y,
        minX: topLeft.x,
        minY: topLeft.y,
        maxX: topLeft.x + width,
        maxY: topLeft.y + height,
        width,
        height
      };
    };
    Annotation2.prototype.getAnnotationCfg = function(type, option, theme4) {
      var _this = this;
      var coordinate11 = this.view.getCoordinate();
      var canvas = this.view.getCanvas();
      var o = {};
      if (is_nil_default(option)) {
        return null;
      }
      var start = option.start, end = option.end, position = option.position;
      var sp = this.parsePosition(start);
      var ep = this.parsePosition(end);
      var textPoint = this.parsePosition(position);
      if (["arc", "image", "line", "region", "regionFilter"].includes(type) && (!sp || !ep)) {
        return null;
      } else if (["text", "dataMarker", "html"].includes(type) && !textPoint) {
        return null;
      }
      if (type === "arc") {
        var _a6 = option, start_1 = _a6.start, end_1 = _a6.end, rest2 = __rest(_a6, ["start", "end"]);
        var startAngle = getAngleByPoint(coordinate11, sp);
        var endAngle = getAngleByPoint(coordinate11, ep);
        if (startAngle > endAngle) {
          endAngle = Math.PI * 2 + endAngle;
        }
        o = __assign(__assign({}, rest2), { center: coordinate11.getCenter(), radius: getDistanceToCenter(coordinate11, sp), startAngle, endAngle });
      } else if (type === "image") {
        var _b = option, start_2 = _b.start, end_2 = _b.end, rest2 = __rest(_b, ["start", "end"]);
        o = __assign(__assign({}, rest2), { start: sp, end: ep, src: option.src });
      } else if (type === "line") {
        var _c = option, start_3 = _c.start, end_3 = _c.end, rest2 = __rest(_c, ["start", "end"]);
        o = __assign(__assign({}, rest2), { start: sp, end: ep, text: get_default(option, "text", null) });
      } else if (type === "region") {
        var _d = option, start_4 = _d.start, end_4 = _d.end, rest2 = __rest(_d, ["start", "end"]);
        o = __assign(__assign({}, rest2), { start: sp, end: ep });
      } else if (type === "text") {
        var filteredData = this.view.getData();
        var _e = option, position_1 = _e.position, content = _e.content, rest2 = __rest(_e, ["position", "content"]);
        var textContent = content;
        if (is_function_default(content)) {
          textContent = content(filteredData);
        }
        o = __assign(__assign(__assign({}, textPoint), rest2), { content: textContent });
      } else if (type === "dataMarker") {
        var _f = option, position_2 = _f.position, point2 = _f.point, line2 = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest2 = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
        o = __assign(__assign(__assign({}, rest2), textPoint), { coordinateBBox: this.getCoordinateBBox(), point: point2, line: line2, text, autoAdjust, direction: direction2 });
      } else if (type === "dataRegion") {
        var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest2 = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
        o = __assign(__assign({}, rest2), { points: this.getRegionPoints(start_5, end_5), region, text, lineLength });
      } else if (type === "regionFilter") {
        var _h = option, start_6 = _h.start, end_6 = _h.end, apply_1 = _h.apply, color3 = _h.color, rest2 = __rest(_h, ["start", "end", "apply", "color"]);
        var geometries = this.view.geometries;
        var shapes_1 = [];
        var addShapes_1 = function(item) {
          if (!item) {
            return;
          }
          if (item.isGroup()) {
            item.getChildren().forEach(function(child) {
              return addShapes_1(child);
            });
          } else {
            shapes_1.push(item);
          }
        };
        each_default(geometries, function(geom) {
          if (apply_1) {
            if (contains_default(apply_1, geom.type)) {
              each_default(geom.elements, function(elem) {
                addShapes_1(elem.shape);
              });
            }
          } else {
            each_default(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        });
        o = __assign(__assign({}, rest2), { color: color3, shapes: shapes_1, start: sp, end: ep });
      } else if (type === "shape") {
        var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
        var wrappedRender = function(container) {
          if (is_function_default(option.render)) {
            return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
          }
        };
        o = __assign(__assign({}, restOptions), { render: wrappedRender });
      } else if (type === "html") {
        var _k = option, html_1 = _k.html, position_3 = _k.position, restOptions = __rest(_k, ["html", "position"]);
        var wrappedHtml = function(container) {
          if (is_function_default(html_1)) {
            return html_1(container, _this.view);
          }
          return html_1;
        };
        o = __assign(__assign(__assign({}, restOptions), textPoint), {
          // html  parent
          parent: canvas.get("el").parentNode,
          html: wrappedHtml
        });
      }
      var cfg = deep_mix_default({}, theme4, __assign(__assign({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
      if (type !== "html") {
        cfg.container = this.getComponentContainer(cfg);
      }
      cfg.animate = this.view.getOptions().animate && cfg.animate && get_default(option, "animate", cfg.animate);
      cfg.animateOption = deep_mix_default({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
      return cfg;
    };
    Annotation2.prototype.isTop = function(option) {
      return get_default(option, "top", true);
    };
    Annotation2.prototype.getComponentContainer = function(option) {
      return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
    };
    Annotation2.prototype.getAnnotationTheme = function(type) {
      return get_default(this.view.getTheme(), ["components", "annotation", type], {});
    };
    Annotation2.prototype.updateOrCreate = function(option) {
      var co = this.cache.get(this.getCacheKey(option));
      if (co) {
        var type = option.type;
        var theme4 = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme4);
        if (cfg) {
          omit(cfg, ["container"]);
        }
        co.component.update(__assign(__assign({}, cfg || {}), { visible: !!cfg }));
        if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      } else {
        co = this.createAnnotation(option);
        if (co) {
          co.component.init();
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            co.component.render();
          }
        }
      }
      return co;
    };
    Annotation2.prototype.syncCache = function(updated) {
      var _this = this;
      var newCache = new Map(this.cache);
      updated.forEach(function(co, key) {
        newCache.set(key, co);
      });
      newCache.forEach(function(co, key) {
        if (!find_default(_this.option, function(option) {
          return key === _this.getCacheKey(option);
        })) {
          co.component.destroy();
          newCache.delete(key);
        }
      });
      return newCache;
    };
    Annotation2.prototype.getCacheKey = function(option) {
      return option;
    };
    return Annotation2;
  }(Controller)
);
var annotation_default = Annotation;

// node_modules/@antv/g2/esm/util/grid.js
function getGridThemeCfg(theme4, direction2) {
  var axisTheme = deep_mix_default({}, get_default(theme4, ["components", "axis", "common"]), get_default(theme4, ["components", "axis", direction2]));
  return get_default(axisTheme, ["grid"], {});
}
function getLineGridItems(coordinate11, scale8, dim, alignTick) {
  var items = [];
  var ticks = scale8.getTicks();
  if (coordinate11.isPolar) {
    ticks.push({
      value: 1,
      text: "",
      tickValue: ""
    });
  }
  ticks.reduce(function(preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;
    if (alignTick) {
      items.push({
        points: [
          coordinate11.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
          coordinate11.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
        ]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [
            coordinate11.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
            coordinate11.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
          ]
        });
      }
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function getCircleGridItems(coordinate11, xScale, yScale, alignTick, dim) {
  var count2 = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function(preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value;
    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;
    if (dim === "x") {
      items.push({
        points: [
          coordinate11.convert({
            x: alignTick ? currentValue : middleValue,
            y: 0
          }),
          coordinate11.convert({
            x: alignTick ? currentValue : middleValue,
            y: 1
          })
        ]
      });
    } else {
      items.push({
        points: map_default(Array(count2 + 1), function(__, idx) {
          return coordinate11.convert({
            x: idx / count2,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function showGrid(axisTheme, axisOption) {
  var userGrid = get_default(axisOption, "grid");
  if (userGrid === null) {
    return false;
  }
  var themeGrid = get_default(axisTheme, "grid");
  return !(userGrid === void 0 && themeGrid === null);
}

// node_modules/@antv/g2/esm/chart/controller/axis.js
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), { appear: null });
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = /* @__PURE__ */ new Map();
      _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Axis2.prototype, "name", {
      get: function() {
        return "axis";
      },
      enumerable: false,
      configurable: true
    });
    Axis2.prototype.init = function() {
    };
    Axis2.prototype.render = function() {
      this.update();
    };
    Axis2.prototype.layout = function() {
      var _this = this;
      var coordinate11 = this.view.getCoordinate();
      each_default(this.getComponents(), function(co) {
        var component2 = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
        var dim = extra.dim, scale8 = extra.scale, alignTick = extra.alignTick;
        var updated;
        if (type === COMPONENT_TYPE.AXIS) {
          if (coordinate11.isPolar) {
            if (dim === "x") {
              updated = coordinate11.isTransposed ? getAxisRegion(coordinate11, direction2) : getCircleAxisCenterRadius(coordinate11);
            } else if (dim === "y") {
              updated = coordinate11.isTransposed ? getCircleAxisCenterRadius(coordinate11) : getAxisRegion(coordinate11, direction2);
            }
          } else {
            updated = getAxisRegion(coordinate11, direction2);
          }
        } else if (type === COMPONENT_TYPE.GRID) {
          if (coordinate11.isPolar) {
            var items = void 0;
            if (coordinate11.isTransposed) {
              items = dim === "x" ? getCircleGridItems(coordinate11, _this.view.getYScales()[0], scale8, alignTick, dim) : getLineGridItems(coordinate11, scale8, dim, alignTick);
            } else {
              items = dim === "x" ? getLineGridItems(coordinate11, scale8, dim, alignTick) : getCircleGridItems(coordinate11, _this.view.getXScale(), scale8, alignTick, dim);
            }
            updated = {
              items,
              // coordinate center 
              center: _this.view.getCoordinate().getCenter()
            };
          } else {
            updated = { items: getLineGridItems(coordinate11, scale8, dim, alignTick) };
          }
        }
        component2.update(updated);
      });
    };
    Axis2.prototype.update = function() {
      this.option = this.view.getOptions().axes;
      var updatedCache = /* @__PURE__ */ new Map();
      this.updateXAxes(updatedCache);
      this.updateYAxes(updatedCache);
      var newCache = /* @__PURE__ */ new Map();
      this.cache.forEach(function(co, key) {
        if (updatedCache.has(key)) {
          newCache.set(key, co);
        } else {
          co.component.destroy();
        }
      });
      this.cache = newCache;
    };
    Axis2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.cache.clear();
      this.gridContainer.clear();
      this.gridForeContainer.clear();
      this.axisContainer.clear();
      this.axisForeContainer.clear();
    };
    Axis2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gridContainer.remove(true);
      this.gridForeContainer.remove(true);
      this.axisContainer.remove(true);
      this.axisForeContainer.remove(true);
    };
    Axis2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value2) {
        co.push(value2);
      });
      return co;
    };
    Axis2.prototype.updateXAxes = function(updatedCache) {
      var scale8 = this.view.getXScale();
      if (!scale8 || scale8.isIdentity) {
        return;
      }
      var xAxisOption = getAxisOption(this.option, scale8.field);
      if (xAxisOption === false) {
        return;
      }
      var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
      var layer = LAYER.BG;
      var dim = "x";
      var coordinate11 = this.view.getCoordinate();
      var axisId = this.getId("axis", scale8.field);
      var gridId = this.getId("grid", scale8.field);
      if (coordinate11.isRect) {
        var axis22 = this.cache.get(axisId);
        if (axis22) {
          var cfg = this.getLineAxisCfg(scale8, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis22.component.update(cfg);
          updatedCache.set(axisId, axis22);
        } else {
          axis22 = this.createLineAxis(scale8, xAxisOption, layer, direction2, dim);
          this.cache.set(axisId, axis22);
          updatedCache.set(axisId, axis22);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = this.getLineGridCfg(scale8, xAxisOption, direction2, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          grid = this.createLineGrid(scale8, xAxisOption, layer, direction2, dim);
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else if (coordinate11.isPolar) {
        var axis22 = this.cache.get(axisId);
        if (axis22) {
          var cfg = coordinate11.isTransposed ? this.getLineAxisCfg(scale8, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale8, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis22.component.update(cfg);
          updatedCache.set(axisId, axis22);
        } else {
          if (coordinate11.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              axis22 = this.createLineAxis(scale8, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            axis22 = this.createCircleAxis(scale8, xAxisOption, layer, direction2, dim);
          }
          this.cache.set(axisId, axis22);
          updatedCache.set(axisId, axis22);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = coordinate11.isTransposed ? this.getCircleGridCfg(scale8, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale8, xAxisOption, DIRECTION.CIRCLE, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          if (coordinate11.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              grid = this.createCircleGrid(scale8, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            grid = this.createLineGrid(scale8, xAxisOption, layer, DIRECTION.CIRCLE, dim);
          }
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else {
      }
    };
    Axis2.prototype.updateYAxes = function(updatedCache) {
      var _this = this;
      var yScales = this.view.getYScales();
      each_default(yScales, function(scale8, idx) {
        if (!scale8 || scale8.isIdentity) {
          return;
        }
        var field6 = scale8.field;
        var yAxisOption = getAxisOption(_this.option, field6);
        if (yAxisOption !== false) {
          var layer = LAYER.BG;
          var dim = "y";
          var axisId = _this.getId("axis", field6);
          var gridId = _this.getId("grid", field6);
          var coordinate11 = _this.view.getCoordinate();
          if (coordinate11.isRect) {
            var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
            var axis22 = _this.cache.get(axisId);
            if (axis22) {
              var cfg = _this.getLineAxisCfg(scale8, yAxisOption, direction2);
              omit(cfg, OMIT_CFG);
              axis22.component.update(cfg);
              updatedCache.set(axisId, axis22);
            } else {
              axis22 = _this.createLineAxis(scale8, yAxisOption, layer, direction2, dim);
              _this.cache.set(axisId, axis22);
              updatedCache.set(axisId, axis22);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = _this.getLineGridCfg(scale8, yAxisOption, direction2, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              grid = _this.createLineGrid(scale8, yAxisOption, layer, direction2, dim);
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else if (coordinate11.isPolar) {
            var axis22 = _this.cache.get(axisId);
            if (axis22) {
              var cfg = coordinate11.isTransposed ? _this.getCircleAxisCfg(scale8, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale8, yAxisOption, DIRECTION.RADIUS);
              omit(cfg, OMIT_CFG);
              axis22.component.update(cfg);
              updatedCache.set(axisId, axis22);
            } else {
              if (coordinate11.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  axis22 = _this.createCircleAxis(scale8, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                axis22 = _this.createLineAxis(scale8, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              _this.cache.set(axisId, axis22);
              updatedCache.set(axisId, axis22);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = coordinate11.isTransposed ? _this.getLineGridCfg(scale8, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale8, yAxisOption, DIRECTION.RADIUS, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              if (coordinate11.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  grid = _this.createLineGrid(scale8, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                grid = _this.createCircleGrid(scale8, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else {
          }
        }
      });
    };
    Axis2.prototype.createLineAxis = function(scale8, option, layer, direction2, dim) {
      var axis22 = {
        component: new LineAxis(this.getLineAxisCfg(scale8, option, direction2)),
        layer,
        direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale8 }
      };
      axis22.component.set("field", scale8.field);
      axis22.component.init();
      return axis22;
    };
    Axis2.prototype.createLineGrid = function(scale8, option, layer, direction2, dim) {
      var cfg = this.getLineGridCfg(scale8, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new LineGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale8,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.createCircleAxis = function(scale8, option, layer, direction2, dim) {
      var axis22 = {
        component: new CircleAxis(this.getCircleAxisCfg(scale8, option, direction2)),
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale8 }
      };
      axis22.component.set("field", scale8.field);
      axis22.component.init();
      return axis22;
    };
    Axis2.prototype.createCircleGrid = function(scale8, option, layer, direction2, dim) {
      var cfg = this.getCircleGridCfg(scale8, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new CircleGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale8,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.getLineAxisCfg = function(scale8, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate11 = this.view.getCoordinate();
      var region = getAxisRegion(coordinate11, direction2);
      var titleText = getAxisTitleText(scale8, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, region), { ticks: scale8.getTicks().map(function(tick) {
        return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
      }), verticalFactor: coordinate11.isPolar ? getAxisFactorByRegion(region, coordinate11.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate11.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a6 = this.getAnimateCfg(cfg), animate = _a6.animate, animateOption = _a6.animateOption;
      cfg.animateOption = animateOption;
      cfg.animate = animate;
      var isAxisVertical = isVertical(region);
      var verticalLimitLength = get_default(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
      if (verticalLimitLength <= 1) {
        var canvasWidth = this.view.getCanvas().get("width");
        var canvasHeight = this.view.getCanvas().get("height");
        cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
      }
      return cfg;
    };
    Axis2.prototype.getLineGridCfg = function(scale8, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale8, dim, get_default(gridCfg, "alignTick", true));
      return gridCfg;
    };
    Axis2.prototype.getCircleAxisCfg = function(scale8, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate11 = this.view.getCoordinate();
      var ticks = scale8.getTicks().map(function(tick) {
        return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
      });
      if (!scale8.isCategory && Math.abs(coordinate11.endAngle - coordinate11.startAngle) === Math.PI * 2) {
        if (ticks.length)
          ticks[ticks.length - 1].name = "";
      }
      var titleText = getAxisTitleText(scale8, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a6 = this.getAnimateCfg(cfg), animate = _a6.animate, animateOption = _a6.animateOption;
      cfg.animate = animate;
      cfg.animateOption = animateOption;
      return cfg;
    };
    Axis2.prototype.getCircleGridCfg = function(scale8, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
        center: this.view.getCoordinate().getCenter()
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      var alignTick = get_default(gridCfg, "alignTick", true);
      var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
      gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale8, alignTick, dim);
      return gridCfg;
    };
    Axis2.prototype.getId = function(name, key) {
      var coordinate11 = this.view.getCoordinate();
      return "".concat(name, "-").concat(key, "-").concat(coordinate11.type);
    };
    Axis2.prototype.getAnimateCfg = function(cfg) {
      return {
        animate: this.view.getOptions().animate && get_default(cfg, "animate"),
        animateOption: cfg && cfg.animateOption ? deep_mix_default({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
      };
    };
    return Axis2;
  }(Controller)
);
var axis_default = Axis;

// node_modules/@antv/g2/esm/util/direction.js
function directionToPosition(parentBBox, bbox, direction2) {
  if (direction2 === DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction2 === DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction2 === DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}

// node_modules/@antv/g2/esm/chart/controller/legend.js
function getLegendOption(legends, field6) {
  if (is_boolean_default(legends)) {
    return legends === false ? false : {};
  }
  return get_default(legends, [field6], legends);
}
function getDirection(legendOption) {
  return get_default(legendOption, "position", DIRECTION.BOTTOM);
}
var Legend = (
  /** @class */
  function(_super) {
    __extends(Legend2, _super);
    function Legend2(view) {
      var _this = _super.call(this, view) || this;
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Legend2.prototype, "name", {
      get: function() {
        return "legend";
      },
      enumerable: false,
      configurable: true
    });
    Legend2.prototype.init = function() {
    };
    Legend2.prototype.render = function() {
      this.update();
    };
    Legend2.prototype.layout = function() {
      var _this = this;
      this.layoutBBox = this.view.viewBBox;
      each_default(this.components, function(co) {
        var component2 = co.component, direction2 = co.direction;
        var layout2 = getLegendLayout(direction2);
        var maxWidthRatio = component2.get("maxWidthRatio");
        var maxHeightRatio = component2.get("maxHeightRatio");
        var maxSize = _this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
        var maxWidth = component2.get("maxWidth");
        var maxHeight = component2.get("maxHeight");
        component2.update({
          maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
          maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
        });
        var padding3 = component2.get("padding");
        var bboxObject = component2.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding3);
        var _a6 = __read(directionToPosition(_this.view.viewBBox, bbox, direction2), 2), x1 = _a6[0], y1 = _a6[1];
        var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction2), 2), x2 = _b[0], y2 = _b[1];
        var x = 0;
        var y = 0;
        if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
          x = x1;
          y = y2;
        } else {
          x = x2;
          y = y1;
        }
        component2.setLocation({ x: x + padding3[3], y: y + padding3[0] });
        _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
      });
    };
    Legend2.prototype.update = function() {
      var _this = this;
      this.option = this.view.getOptions().legends;
      var updated = {};
      var eachLegend = function(geometry35, attr, scale8) {
        var id2 = _this.getId(scale8.field);
        var existCo2 = _this.getComponentById(id2);
        if (existCo2) {
          var cfg = void 0;
          var legendOption = getLegendOption(_this.option, scale8.field);
          if (legendOption !== false) {
            if (get_default(legendOption, "custom")) {
              cfg = _this.getCategoryCfg(geometry35, attr, scale8, legendOption, true);
            } else {
              if (scale8.isLinear) {
                cfg = _this.getContinuousCfg(geometry35, attr, scale8, legendOption);
              } else if (scale8.isCategory) {
                cfg = _this.getCategoryCfg(geometry35, attr, scale8, legendOption);
              }
            }
          }
          if (cfg) {
            omit(cfg, ["container"]);
            existCo2.direction = getDirection(legendOption);
            existCo2.component.update(cfg);
            updated[id2] = true;
          }
        } else {
          var legend18 = _this.createFieldLegend(geometry35, attr, scale8);
          if (legend18) {
            legend18.component.init();
            _this.components.push(legend18);
            updated[id2] = true;
          }
        }
      };
      if (get_default(this.option, "custom")) {
        var id = "global-custom";
        var existCo = this.getComponentById(id);
        if (existCo) {
          var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
          omit(customCfg, ["container"]);
          existCo.component.update(customCfg);
          updated[id] = true;
        } else {
          var component2 = this.createCustomLegend(void 0, void 0, void 0, this.option);
          if (component2) {
            component2.init();
            var layer = LAYER.FORE;
            var direction2 = getDirection(this.option);
            this.components.push({
              id,
              component: component2,
              layer,
              direction: direction2,
              type: COMPONENT_TYPE.LEGEND,
              extra: void 0
            });
            updated[id] = true;
          }
        }
      } else {
        this.loopLegends(eachLegend);
      }
      var components = [];
      each_default(this.getComponents(), function(co) {
        if (updated[co.id]) {
          components.push(co);
        } else {
          co.component.destroy();
        }
      });
      this.components = components;
    };
    Legend2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.container.clear();
    };
    Legend2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.container.remove(true);
    };
    Legend2.prototype.getGeometries = function(view) {
      var _this = this;
      var geometries = view.geometries;
      each_default(view.views, function(v) {
        geometries = geometries.concat(_this.getGeometries(v));
      });
      return geometries;
    };
    Legend2.prototype.loopLegends = function(doEach) {
      var isRootView = this.view.getRootView() === this.view;
      if (!isRootView) {
        return;
      }
      var geometries = this.getGeometries(this.view);
      var looped = {};
      each_default(geometries, function(geometry35) {
        var attributes = geometry35.getGroupAttributes();
        each_default(attributes, function(attr) {
          var scale8 = attr.getScale(attr.type);
          if (!scale8 || scale8.type === "identity" || looped[scale8.field]) {
            return;
          }
          doEach(geometry35, attr, scale8);
          looped[scale8.field] = true;
        });
      });
    };
    Legend2.prototype.createFieldLegend = function(geometry35, attr, scale8) {
      var component2;
      var legendOption = getLegendOption(this.option, scale8.field);
      var layer = LAYER.FORE;
      var direction2 = getDirection(legendOption);
      if (legendOption !== false) {
        if (get_default(legendOption, "custom")) {
          component2 = this.createCustomLegend(geometry35, attr, scale8, legendOption);
        } else {
          if (scale8.isLinear) {
            component2 = this.createContinuousLegend(geometry35, attr, scale8, legendOption);
          } else if (scale8.isCategory) {
            component2 = this.createCategoryLegend(geometry35, attr, scale8, legendOption);
          }
        }
      }
      if (component2) {
        component2.set("field", scale8.field);
        return {
          id: this.getId(scale8.field),
          component: component2,
          layer,
          direction: direction2,
          type: COMPONENT_TYPE.LEGEND,
          extra: { scale: scale8 }
        };
      }
    };
    Legend2.prototype.createCustomLegend = function(geometry35, attr, scale8, legendOption) {
      var cfg = this.getCategoryCfg(geometry35, attr, scale8, legendOption, true);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.createContinuousLegend = function(geometry35, attr, scale8, legendOption) {
      var cfg = this.getContinuousCfg(geometry35, attr, scale8, omit(legendOption, ["value"]));
      return new ContinuousLegend(cfg);
    };
    Legend2.prototype.createCategoryLegend = function(geometry35, attr, scale8, legendOption) {
      var cfg = this.getCategoryCfg(geometry35, attr, scale8, legendOption);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.getContinuousCfg = function(geometry35, attr, scale8, legendOption) {
      var ticks = scale8.getTicks();
      var containMin = find_default(ticks, function(tick) {
        return tick.value === 0;
      });
      var containMax = find_default(ticks, function(tick) {
        return tick.value === 1;
      });
      var items = ticks.map(function(tick) {
        var value2 = tick.value, tickValue = tick.tickValue;
        var attrValue = attr.mapping(scale8.invert(value2)).join("");
        return {
          value: tickValue,
          attrValue,
          color: attrValue,
          scaleValue: value2
        };
      });
      if (!containMin) {
        items.push({
          value: scale8.min,
          attrValue: attr.mapping(scale8.invert(0)).join(""),
          color: attr.mapping(scale8.invert(0)).join(""),
          scaleValue: 0
        });
      }
      if (!containMax) {
        items.push({
          value: scale8.max,
          attrValue: attr.mapping(scale8.invert(1)).join(""),
          color: attr.mapping(scale8.invert(1)).join(""),
          scaleValue: 1
        });
      }
      items.sort(function(a, b) {
        return a.value - b.value;
      });
      var attrLegendCfg = {
        min: head(items).value,
        max: last(items).value,
        colors: [],
        rail: {
          type: attr.type
        },
        track: {}
      };
      if (attr.type === "size") {
        attrLegendCfg.track = {
          style: {
            // size  color color 
            // @ts-ignore
            fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
          }
        };
      }
      if (attr.type === "color") {
        attrLegendCfg.colors = items.map(function(item) {
          return item.attrValue;
        });
      }
      var container = this.container;
      var direction2 = getDirection(legendOption);
      var layout2 = getLegendLayout(direction2);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: getName(scale8)
        }, title);
      }
      attrLegendCfg.container = container;
      attrLegendCfg.layout = layout2;
      attrLegendCfg.title = title;
      attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
      return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
    };
    Legend2.prototype.getCategoryCfg = function(geometry35, attr, scale8, legendOption, custom12) {
      var container = this.container;
      var direction2 = get_default(legendOption, "position", DIRECTION.BOTTOM);
      var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
      var themeMarker = get_default(legendTheme, ["marker"]);
      var userMarker = get_default(legendOption, "marker");
      var layout2 = getLegendLayout(direction2);
      var themePageNavigator = get_default(legendTheme, ["pageNavigator"]);
      var userPageNavigator = get_default(legendOption, "pageNavigator");
      var items = custom12 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry35, attr, themeMarker, userMarker);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: scale8 ? getName(scale8) : ""
        }, title);
      }
      var maxWidthRatio = get_default(legendOption, "maxWidthRatio");
      var maxHeightRatio = get_default(legendOption, "maxHeightRatio");
      var baseCfg = this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
      baseCfg.container = container;
      baseCfg.layout = layout2;
      baseCfg.items = items;
      baseCfg.title = title;
      baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
      baseCfg.pageNavigator = deep_mix_default({}, themePageNavigator, userPageNavigator);
      var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
      if (categoryCfg.reversed) {
        categoryCfg.items.reverse();
      }
      var maxItemWidth = get_default(categoryCfg, "maxItemWidth");
      if (maxItemWidth && maxItemWidth <= 1) {
        categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
      }
      return categoryCfg;
    };
    Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
      var position = direction2.split("-")[0];
      var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
      return deep_mix_default({}, themeObject, baseCfg, legendOption);
    };
    Legend2.prototype.getId = function(key) {
      return "".concat(this.name, "-").concat(key);
    };
    Legend2.prototype.getComponentById = function(id) {
      return find_default(this.components, function(co) {
        return co.id === id;
      });
    };
    Legend2.prototype.getCategoryLegendSizeCfg = function(layout2, maxWidthRatio, maxHeightRatio) {
      if (maxWidthRatio === void 0) {
        maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      if (maxHeightRatio === void 0) {
        maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      var _a6 = this.view.viewBBox, vw = _a6.width, vh = _a6.height;
      return layout2 === "vertical" ? {
        maxWidth: vw * maxWidthRatio,
        maxHeight: vh
      } : {
        maxWidth: vw,
        maxHeight: vh * maxHeightRatio
      };
    };
    return Legend2;
  }(Controller)
);
var legend_default = Legend;

// node_modules/@antv/g2/esm/chart/controller/slider.js
var Slider2 = (
  /** @class */
  function(_super) {
    __extends(Slider3, _super);
    function Slider3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(v) {
        var _a6 = __read(v, 2), min5 = _a6[0], max5 = _a6[1];
        _this.start = min5;
        _this.end = max5;
        _this.changeViewData(min5, max5);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.width = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Slider3.prototype, "name", {
      get: function() {
        return "slider";
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Slider3.prototype.init = function() {
    };
    Slider3.prototype.render = function() {
      this.option = this.view.getOptions().slider;
      var _a6 = this.getSliderCfg(), start = _a6.start, end = _a6.end;
      if (is_nil_default(this.start)) {
        this.start = start;
        this.end = end;
      }
      var viewData = this.view.getOptions().data;
      if (this.option && !is_empty_default(viewData)) {
        if (this.slider) {
          this.slider = this.updateSlider();
        } else {
          this.slider = this.createSlider();
          this.slider.component.on("sliderchange", this.onChangeFn);
        }
      } else {
        if (this.slider) {
          this.slider.component.destroy();
          this.slider = void 0;
        } else {
        }
      }
    };
    Slider3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.width) {
        this.measureSlider();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.start, _this.end);
          }
        }, 0);
      }
      if (this.slider) {
        var width = this.view.coordinateBBox.width;
        var padding3 = this.slider.component.get("padding");
        var _a6 = __read(padding3, 4), paddingTop = _a6[0], paddingRight = _a6[1], paddingBottom = _a6[2], paddingLeft = _a6[3];
        var bboxObject = this.slider.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding3);
        var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText;
        var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2), x1 = _c[0], y1 = _c[1];
        var _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _d[0], y2 = _d[1];
        this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
        this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
      }
    };
    Slider3.prototype.update = function() {
      this.render();
    };
    Slider3.prototype.createSlider = function() {
      var cfg = this.getSliderCfg();
      var component2 = new Slider(__assign({ container: this.container }, cfg));
      component2.init();
      return {
        component: component2,
        layer: LAYER.FORE,
        direction: DIRECTION.BOTTOM,
        type: COMPONENT_TYPE.SLIDER
      };
    };
    Slider3.prototype.updateSlider = function() {
      var cfg = this.getSliderCfg();
      if (this.width) {
        var _a6 = this.getMinMaxText(this.start, this.end), minText = _a6.minText, maxText = _a6.maxText;
        cfg = __assign(__assign({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
      }
      this.slider.component.update(cfg);
      return this.slider;
    };
    Slider3.prototype.measureSlider = function() {
      var width = this.getSliderCfg().width;
      this.width = width;
    };
    Slider3.prototype.getSliderCfg = function() {
      var cfg = {
        height: 16,
        start: 0,
        end: 1,
        minText: "",
        maxText: "",
        x: 0,
        y: 0,
        width: this.view.coordinateBBox.width
      };
      if (is_object_default(this.option)) {
        var trendCfg = __assign({ data: this.getData() }, get_default(this.option, "trendCfg", {}));
        cfg = deep_mix_default({}, cfg, this.getThemeOptions(), this.option);
        cfg = __assign(__assign({}, cfg), { trendCfg });
      }
      cfg.start = clamp_default(Math.min(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      cfg.end = clamp_default(Math.max(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      return cfg;
    };
    Slider3.prototype.getData = function() {
      var data3 = this.view.getOptions().data;
      var _a6 = __read(this.view.getYScales(), 1), yScale = _a6[0];
      var groupScales = this.view.getGroupScales();
      if (groupScales.length) {
        var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
        return data3.reduce(function(pre, cur) {
          if (cur[field_1] === ticks_1[0]) {
            pre.push(cur[yScale.field]);
          }
          return pre;
        }, []);
      }
      return data3.map(function(datum) {
        return datum[yScale.field] || 0;
      });
    };
    Slider3.prototype.getThemeOptions = function() {
      var theme4 = this.view.getTheme();
      return get_default(theme4, ["components", "slider", "common"], {});
    };
    Slider3.prototype.getMinMaxText = function(min5, max5) {
      var data3 = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var isHorizontal2 = true;
      var values3 = values_of_key_default(data3, xScale.field);
      if (xScale.isLinear) {
        values3 = values3.sort();
      }
      var xValues = isHorizontal2 ? values3 : values3.reverse();
      var dataSize = size(data3);
      if (!xScale || !dataSize) {
        return {};
      }
      var xTickCount = size(xValues);
      var minIndex = Math.round(min5 * (xTickCount - 1));
      var maxIndex = Math.round(max5 * (xTickCount - 1));
      var minText = get_default(xValues, [minIndex]);
      var maxText = get_default(xValues, [maxIndex]);
      var formatter = this.getSliderCfg().formatter;
      if (formatter) {
        minText = formatter(minText, data3[minIndex], minIndex);
        maxText = formatter(maxText, data3[maxIndex], maxIndex);
      }
      return {
        minText,
        maxText
      };
    };
    Slider3.prototype.changeViewData = function(min5, max5) {
      var data3 = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var dataSize = size(data3);
      if (!xScale || !dataSize) {
        return;
      }
      var isHorizontal2 = true;
      var values3 = values_of_key_default(data3, xScale.field);
      var xScaleValues = this.view.getXScale().isLinear ? values3.sort(function(a, b) {
        return Number(a) - Number(b);
      }) : values3;
      var xValues = isHorizontal2 ? xScaleValues : xScaleValues.reverse();
      var xTickCount = size(xValues);
      var minIndex = Math.round(min5 * (xTickCount - 1));
      var maxIndex = Math.round(max5 * (xTickCount - 1));
      this.view.filter(xScale.field, function(value2, datum) {
        var idx = xValues.indexOf(value2);
        return idx > -1 ? isBetween2(idx, minIndex, maxIndex) : true;
      });
      this.view.render(true);
    };
    Slider3.prototype.getComponents = function() {
      return this.slider ? [this.slider] : [];
    };
    Slider3.prototype.clear = function() {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
      this.width = 0;
      this.start = void 0;
      this.end = void 0;
    };
    return Slider3;
  }(Controller)
);
var slider_default = Slider2;

// node_modules/@antv/g2/esm/chart/controller/scrollbar.js
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar2 = (
  /** @class */
  function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(_a6) {
        var ratio = _a6.ratio;
        var animate = _this.getValidScrollbarCfg().animate;
        _this.ratio = clamp_default(ratio, 0, 1);
        var originalAnimate = _this.view.getOptions().animate;
        if (!animate) {
          _this.view.animate(false);
        }
        _this.changeViewData(_this.getScrollRange(), true);
        _this.view.animate(originalAnimate);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.trackLen = 0;
      _this.thumbLen = 0;
      _this.ratio = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Scrollbar3.prototype, "name", {
      get: function() {
        return "scrollbar";
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Scrollbar3.prototype.init = function() {
    };
    Scrollbar3.prototype.render = function() {
      this.option = this.view.getOptions().scrollbar;
      if (this.option) {
        if (this.scrollbar) {
          this.scrollbar = this.updateScrollbar();
        } else {
          this.scrollbar = this.createScrollbar();
          this.scrollbar.component.on("scrollchange", this.onChangeFn);
        }
      } else {
        if (this.scrollbar) {
          this.scrollbar.component.destroy();
          this.scrollbar = void 0;
        }
      }
    };
    Scrollbar3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.trackLen) {
        this.measureScrollbar();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.getScrollRange(), true);
          }
        });
      }
      if (this.scrollbar) {
        var width = this.view.coordinateBBox.width;
        var padding3 = this.scrollbar.component.get("padding");
        var bboxObject = this.scrollbar.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding3);
        var cfg = this.getScrollbarComponentCfg();
        var x = void 0;
        var y = void 0;
        if (cfg.isHorizontal) {
          var _a6 = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2), x1 = _a6[0], y1 = _a6[1];
          var _b = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _b[0], y2 = _b[1];
          x = x2;
          y = y1;
        } else {
          var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x1 = _c[0], y1 = _c[1];
          var _d = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x2 = _d[0], y2 = _d[1];
          x = x2;
          y = y1;
        }
        x += padding3[3];
        y += padding3[0];
        if (this.trackLen) {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
        } else {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y }));
        }
        this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
      }
    };
    Scrollbar3.prototype.update = function() {
      this.render();
    };
    Scrollbar3.prototype.getComponents = function() {
      return this.scrollbar ? [this.scrollbar] : [];
    };
    Scrollbar3.prototype.clear = function() {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
      this.trackLen = 0;
      this.thumbLen = 0;
      this.ratio = 0;
      this.cnt = 0;
      this.step = 0;
      this.data = void 0;
      this.xScaleCfg = void 0;
      this.yScalesCfg = [];
    };
    Scrollbar3.prototype.setValue = function(ratio) {
      this.onValueChange({ ratio });
    };
    Scrollbar3.prototype.getValue = function() {
      return this.ratio;
    };
    Scrollbar3.prototype.getThemeOptions = function() {
      var theme4 = this.view.getTheme();
      return get_default(theme4, ["components", "scrollbar", "common"], {});
    };
    Scrollbar3.prototype.getScrollbarTheme = function(style) {
      var theme4 = get_default(this.view.getTheme(), ["components", "scrollbar"]);
      var _a6 = style || {}, thumbHighlightColor = _a6.thumbHighlightColor, restStyles = __rest(_a6, ["thumbHighlightColor"]);
      return {
        default: deep_mix_default({}, get_default(theme4, ["default", "style"], {}), restStyles),
        hover: deep_mix_default({}, get_default(theme4, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
      };
    };
    Scrollbar3.prototype.measureScrollbar = function() {
      var xScale = this.view.getXScale();
      var yScales = this.view.getYScales().slice();
      this.data = this.getScrollbarData();
      this.step = this.getStep();
      this.cnt = this.getCnt();
      var _a6 = this.getScrollbarComponentCfg(), trackLen = _a6.trackLen, thumbLen = _a6.thumbLen;
      this.trackLen = trackLen;
      this.thumbLen = thumbLen;
      this.xScaleCfg = {
        field: xScale.field,
        values: xScale.values || []
      };
      this.yScalesCfg = yScales;
    };
    Scrollbar3.prototype.getScrollRange = function() {
      var startIdx = Math.floor((this.cnt - this.step) * clamp_default(this.ratio, 0, 1));
      var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
      return [startIdx, endIdx];
    };
    Scrollbar3.prototype.changeViewData = function(_a6, render) {
      var _this = this;
      var _b = __read(_a6, 2), startIdx = _b[0], endIdx = _b[1];
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal2 = type !== "vertical";
      var values3 = values_of_key_default(this.data, this.xScaleCfg.field);
      var xScaleValues = this.view.getXScale().isLinear ? values3.sort(function(a, b) {
        return Number(a) - Number(b);
      }) : values3;
      var xValues = isHorizontal2 ? xScaleValues : xScaleValues.reverse();
      this.yScalesCfg.forEach(function(cfg) {
        _this.view.scale(cfg.field, {
          formatter: cfg.formatter,
          type: cfg.type,
          min: cfg.min,
          max: cfg.max,
          tickMethod: cfg.tickMethod
        });
      });
      this.view.filter(this.xScaleCfg.field, function(val) {
        var idx = xValues.indexOf(val);
        return idx > -1 ? isBetween2(idx, startIdx, endIdx) : true;
      });
      this.view.render(true);
    };
    Scrollbar3.prototype.createScrollbar = function() {
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal2 = type !== "vertical";
      var component2 = new Scrollbar(__assign(__assign({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
      component2.init();
      return {
        component: component2,
        layer: LAYER.FORE,
        direction: isHorizontal2 ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
        type: COMPONENT_TYPE.SCROLLBAR
      };
    };
    Scrollbar3.prototype.updateScrollbar = function() {
      var config = this.getScrollbarComponentCfg();
      var realConfig = this.trackLen ? __assign(__assign({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign({}, config);
      this.scrollbar.component.update(realConfig);
      return this.scrollbar;
    };
    Scrollbar3.prototype.getStep = function() {
      if (this.step) {
        return this.step;
      }
      var coordinateBBox = this.view.coordinateBBox;
      var _a6 = this.getValidScrollbarCfg(), type = _a6.type, categorySize = _a6.categorySize;
      var isHorizontal2 = type !== "vertical";
      return Math.floor((isHorizontal2 ? coordinateBBox.width : coordinateBBox.height) / categorySize);
    };
    Scrollbar3.prototype.getCnt = function() {
      if (this.cnt) {
        return this.cnt;
      }
      var xScale = this.view.getXScale();
      var data3 = this.getScrollbarData();
      var values3 = values_of_key_default(data3, xScale.field);
      return size(values3);
    };
    Scrollbar3.prototype.getScrollbarComponentCfg = function() {
      var _a6 = this.view, coordinateBBox = _a6.coordinateBBox, viewBBox = _a6.viewBBox;
      var _b = this.getValidScrollbarCfg(), type = _b.type, padding3 = _b.padding, width = _b.width, height = _b.height, style = _b.style;
      var isHorizontal2 = type !== "vertical";
      var _c = __read(padding3, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
      var position = isHorizontal2 ? {
        x: coordinateBBox.minX + paddingLeft,
        y: viewBBox.maxY - height - paddingBottom
      } : {
        x: viewBBox.maxX - width - paddingRight,
        y: coordinateBBox.minY + paddingTop
      };
      var step = this.getStep();
      var cnt = this.getCnt();
      var trackLen = isHorizontal2 ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
      var thumbLen = Math.max(trackLen * clamp_default(step / cnt, 0, 1), MIN_THUMB_LENGTH);
      return __assign(__assign({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal2 ? height : width, isHorizontal: isHorizontal2, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
    };
    Scrollbar3.prototype.getValidScrollbarCfg = function() {
      var cfg = {
        type: "horizontal",
        categorySize: DEFAULT_CATEGORY_SIZE,
        width: DEFAULT_SIZE,
        height: DEFAULT_SIZE,
        padding: [0, 0, 0, 0],
        animate: true,
        style: {}
      };
      if (is_object_default(this.option)) {
        cfg = __assign(__assign({}, cfg), this.option);
      }
      if (!is_object_default(this.option) || !this.option.padding) {
        cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
      }
      return cfg;
    };
    Scrollbar3.prototype.getScrollbarData = function() {
      var coordinate11 = this.view.getCoordinate();
      var cfg = this.getValidScrollbarCfg();
      var data3 = this.view.getOptions().data || [];
      if (coordinate11.isReflect("y") && cfg.type === "vertical") {
        data3 = __spreadArray([], __read(data3), false).reverse();
      }
      return data3;
    };
    return Scrollbar3;
  }(Controller)
);
var scrollbar_default = Scrollbar2;

// node_modules/@antv/g2/esm/interaction/action/active-region.js
var DEFAULT_REGION_PATH_STYLE = {
  fill: "#CCD6EC",
  opacity: 0.3
};
function getItemsOfView(view, point2, tooltipCfg) {
  var e_1, _a6, e_2, _b, e_3, _c;
  var items = findItemsFromViewRecurisive(view, point2, tooltipCfg);
  if (items.length) {
    items = flatten_default(items);
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var itemArr = items_1_1.value;
        try {
          for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
            var item = itemArr_1_1.value;
            var _d = item.mappingData, x = _d.x, y = _d.y;
            item.x = is_array_default(x) ? x[x.length - 1] : x;
            item.y = is_array_default(y) ? y[y.length - 1] : y;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
              _b.call(itemArr_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a6 = items_1.return))
          _a6.call(items_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var shared = tooltipCfg.shared;
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min5 = Math.abs(point2.y - snapItem[0].y);
      try {
        for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
          var aItem = items_2_1.value;
          var yDistance = Math.abs(point2.y - aItem[0].y);
          if (yDistance <= min5) {
            snapItem = aItem;
            min5 = yDistance;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (items_2_1 && !items_2_1.done && (_c = items_2.return))
            _c.call(items_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      items = [snapItem];
    }
    return uniq(flatten_default(items));
  }
  return [];
}
var ActiveRegion = (
  /** @class */
  function(_super) {
    __extends(ActiveRegion2, _super);
    function ActiveRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActiveRegion2.prototype.show = function(args) {
      var view = this.context.view;
      var ev = this.context.event;
      var tooltipCfg = view.getController("tooltip").getTooltipCfg();
      var tooltipItems = getItemsOfView(view, {
        x: ev.x,
        y: ev.y
      }, tooltipCfg);
      if (is_equal_default(tooltipItems, this.items)) {
        return;
      }
      this.items = tooltipItems;
      if (tooltipItems.length) {
        var xField_1 = view.getXScale().field;
        var xValue_1 = tooltipItems[0].data[xField_1];
        var elements_1 = [];
        var geometries = view.geometries;
        each_default(geometries, function(geometry35) {
          if (geometry35.type === "interval" || geometry35.type === "schema") {
            var result2 = geometry35.getElementsBy(function(ele) {
              var eleData = ele.getData();
              return eleData[xField_1] === xValue_1;
            });
            elements_1 = elements_1.concat(result2);
          }
        });
        if (elements_1.length) {
          var coordinate_1 = view.getCoordinate();
          var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
          var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
          var groupBBox_1 = firstBBox_1;
          each_default(elements_1, function(ele) {
            var bbox = ele.shape.getCanvasBBox();
            if (coordinate_1.isTransposed) {
              if (bbox.minY < firstBBox_1.minY) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxY > lastBBox_1.maxY) {
                lastBBox_1 = bbox;
              }
            } else {
              if (bbox.minX < firstBBox_1.minX) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxX > lastBBox_1.maxX) {
                lastBBox_1 = bbox;
              }
            }
            groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
            groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
            groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
            groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
          });
          var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
          var path = void 0;
          if (coordinate_1.isRect) {
            var xScale = view.getXScale();
            var _a6 = args || {}, appendRatio = _a6.appendRatio, appendWidth = _a6.appendWidth;
            if (is_nil_default(appendWidth)) {
              appendRatio = is_nil_default(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
              appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
            }
            var minX = void 0;
            var minY = void 0;
            var width = void 0;
            var height = void 0;
            if (coordinate_1.isTransposed) {
              minX = coordinateBBox.minX;
              minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
              width = coordinateBBox.width;
              height = groupBBox_1.height + appendWidth * 2;
            } else {
              minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
              minY = coordinateBBox.minY;
              width = groupBBox_1.width + appendWidth * 2;
              height = coordinateBBox.height;
            }
            path = [
              ["M", minX, minY],
              ["L", minX + width, minY],
              ["L", minX + width, minY + height],
              ["L", minX, minY + height],
              ["Z"]
            ];
          } else {
            var firstElement = head(elements_1);
            var lastElement = last(elements_1);
            var startAngle = getAngle2(firstElement.getModel(), coordinate_1).startAngle;
            var endAngle = getAngle2(lastElement.getModel(), coordinate_1).endAngle;
            var center2 = coordinate_1.getCenter();
            var radius = coordinate_1.getRadius();
            var innterRadius = coordinate_1.innerRadius * radius;
            path = getSectorPath(center2.x, center2.y, radius, startAngle, endAngle, innterRadius);
          }
          if (this.regionPath) {
            this.regionPath.attr("path", path);
            this.regionPath.show();
          } else {
            var style = get_default(args, "style", DEFAULT_REGION_PATH_STYLE);
            this.regionPath = backgroundGroup.addShape({
              type: "path",
              name: "active-region",
              capture: false,
              attrs: __assign(__assign({}, style), { path })
            });
          }
        }
      }
    };
    ActiveRegion2.prototype.hide = function() {
      if (this.regionPath) {
        this.regionPath.hide();
      }
      this.items = null;
    };
    ActiveRegion2.prototype.destroy = function() {
      this.hide();
      if (this.regionPath) {
        this.regionPath.remove(true);
      }
      _super.prototype.destroy.call(this);
    };
    return ActiveRegion2;
  }(base_default12)
);
var active_region_default = ActiveRegion;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js
var TooltipAction = (
  /** @class */
  function(_super) {
    __extends(TooltipAction2, _super);
    function TooltipAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    TooltipAction2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var view = context.view;
      var isTooltipLocked = view.isTooltipLocked();
      if (isTooltipLocked) {
        return;
      }
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      var showDelay = get_default(context.view.getOptions(), "tooltip.showDelay", 16);
      if (timeStamp - lastTimeStamp > showDelay) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(view, curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    TooltipAction2.prototype.hide = function() {
      var view = this.context.view;
      var tooltip11 = view.getController("tooltip");
      var _a6 = this.context.event, clientX = _a6.clientX, clientY = _a6.clientY;
      if (tooltip11.isCursorEntered({ x: clientX, y: clientY })) {
        return;
      }
      if (view.isTooltipLocked()) {
        return;
      }
      this.hideTooltip(view);
      this.location = null;
    };
    TooltipAction2.prototype.showTooltip = function(view, point2) {
      view.showTooltip(point2);
    };
    TooltipAction2.prototype.hideTooltip = function(view) {
      view.hideTooltip();
    };
    return TooltipAction2;
  }(base_default12)
);
var geometry_default = TooltipAction;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js
var SiblingTooltip = (
  /** @class */
  function(_super) {
    __extends(SiblingTooltip2, _super);
    function SiblingTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingTooltip2.prototype.showTooltip = function(view, point2) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var siblingPoint = getSiblingPoint(view, sibling, point2);
        sibling.showTooltip(siblingPoint);
      });
    };
    SiblingTooltip2.prototype.hideTooltip = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.hideTooltip();
      });
    };
    return SiblingTooltip2;
  }(geometry_default)
);
var sibling_default = SiblingTooltip;

// node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js
var EllipsisText = (
  /** @class */
  function(_super) {
    __extends(EllipsisText2, _super);
    function EllipsisText2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    EllipsisText2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    EllipsisText2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      if (timeStamp - lastTimeStamp > 16) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    EllipsisText2.prototype.hide = function() {
      this.hideTooltip();
      this.location = null;
    };
    EllipsisText2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target = ev.target;
      if (target && target.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var tipContent = target.get("tip");
        this.tooltip.update(__assign({ title: tipContent }, curLoc));
        this.tooltip.show();
      }
    };
    EllipsisText2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    EllipsisText2.prototype.renderTooltip = function() {
      var _a6;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var theme4 = view.getTheme();
      var tooltipStyles = get_default(theme4, ["components", "tooltip", "domStyles"], {});
      var tooltip11 = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        crosshairs: null,
        domStyles: __assign({}, deep_mix_default({}, tooltipStyles, (_a6 = {}, // tooltip tip  50%
        _a6[css_const_exports2.CONTAINER_CLASS] = { "max-width": "50%" }, _a6[css_const_exports2.TITLE_CLASS] = { "word-break": "break-all" }, _a6)))
      });
      tooltip11.init();
      tooltip11.setCapture(false);
      this.tooltip = tooltip11;
    };
    return EllipsisText2;
  }(base_default12)
);
var ellipsis_text_default = EllipsisText;

// node_modules/@antv/g2/esm/interaction/action/element/state-base.js
var StateBase = (
  /** @class */
  function(_super) {
    __extends(StateBase2, _super);
    function StateBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      return _this;
    }
    StateBase2.prototype.hasState = function(element) {
      return element.hasState(this.stateName);
    };
    StateBase2.prototype.setElementState = function(element, enable) {
      element.setState(this.stateName, enable);
    };
    StateBase2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    StateBase2.prototype.clear = function() {
      var view = this.context.view;
      this.clearViewState(view);
    };
    StateBase2.prototype.clearViewState = function(view) {
      var _this = this;
      var elements = getElementsByState(view, this.stateName);
      each_default(elements, function(el) {
        _this.setElementState(el, false);
      });
    };
    return StateBase2;
  }(base_default12)
);
var state_base_default = StateBase;

// node_modules/@antv/g2/esm/interaction/action/element/state.js
function getItem(shape) {
  return get_default(shape.get("delegateObject"), "item");
}
var ElementState = (
  /** @class */
  function(_super) {
    __extends(ElementState2, _super);
    function ElementState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.ignoreListItemStates = ["unchecked"];
      return _this;
    }
    ElementState2.prototype.isItemIgnore = function(item, list) {
      var states = this.ignoreListItemStates;
      var filtered = states.filter(function(state2) {
        return list.hasState(item, state2);
      });
      return !!filtered.length;
    };
    ElementState2.prototype.setStateByComponent = function(component2, item, enable) {
      var view = this.context.view;
      var field6 = component2.get("field");
      var elements = getElements(view);
      this.setElementsStateByItem(elements, field6, item, enable);
    };
    ElementState2.prototype.setStateByElement = function(element, enable) {
      this.setElementState(element, enable);
    };
    ElementState2.prototype.isMathItem = function(element, field6, item) {
      var view = this.context.view;
      var scale8 = getScaleByField(view, field6);
      var value2 = getElementValue(element, field6);
      return !is_nil_default(value2) && item.name === scale8.getText(value2);
    };
    ElementState2.prototype.setElementsStateByItem = function(elements, field6, item, enable) {
      var _this = this;
      each_default(elements, function(el) {
        if (_this.isMathItem(el, field6, item)) {
          el.setState(_this.stateName, enable);
        }
      });
    };
    ElementState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (isElementChange(this.context)) {
          this.setStateByElement(element, enable);
        }
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component2 = delegateObject.component;
          if (item && component2 && !this.isItemIgnore(item, component2)) {
            var event_1 = this.context.event.gEvent;
            if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
              return;
            }
            this.setStateByComponent(component2, item, enable);
          }
        }
      }
    };
    ElementState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setElementState(element, !hasState);
      }
    };
    ElementState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementState2;
  }(state_base_default)
);
var state_default = ElementState;

// node_modules/@antv/g2/esm/interaction/action/element/active.js
var ElementActive = (
  /** @class */
  function(_super) {
    __extends(ElementActive2, _super);
    function ElementActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementActive2.prototype.active = function() {
      this.setState();
    };
    return ElementActive2;
  }(state_default)
);
var active_default = ElementActive;

// node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js
var LinkByColor = (
  /** @class */
  function(_super) {
    __extends(LinkByColor2, _super);
    function LinkByColor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = {};
      return _this;
    }
    LinkByColor2.prototype.getColorScale = function(view, element) {
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return null;
      }
      var scale8 = view.getScaleByField(colorAttr.getFields()[0]);
      return scale8;
    };
    LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
      var view = this.context.view;
      var isTransposed = view.getCoordinate().isTransposed;
      var bbox = element.shape.getCanvasBBox();
      var nextBBox = nextElement.shape.getCanvasBBox();
      var path = isTransposed ? [
        ["M", bbox.minX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", nextBBox.maxX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.minY],
        ["Z"]
      ] : [
        ["M", bbox.maxX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.maxY],
        ["Z"]
      ];
      return path;
    };
    LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
      var style = {
        opacity: 0.4,
        fill: element.shape.attr("fill")
      };
      group2.addShape({
        type: "path",
        attrs: __assign(__assign({}, deep_mix_default({}, style, is_function_default(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
      });
    };
    LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
      var _this = this;
      var view = this.context.view;
      var scale8 = this.getColorScale(view, element);
      if (!scale8) {
        return;
      }
      var value2 = getElementValue(element, scale8.field);
      if (!this.cache[value2]) {
        var elements_1 = getElementsByField(view, scale8.field, value2);
        var linkGroup = this.linkGroup;
        var group_1 = linkGroup.addGroup();
        this.cache[value2] = group_1;
        var count_1 = elements_1.length;
        each_default(elements_1, function(el, index) {
          if (index < count_1 - 1) {
            var nextEl = elements_1[index + 1];
            _this.addLinkShape(group_1, el, nextEl, activeStyle);
          }
        });
      }
    };
    LinkByColor2.prototype.removeLink = function(element) {
      var scale8 = this.getColorScale(this.context.view, element);
      if (!scale8) {
        return;
      }
      var value2 = getElementValue(element, scale8.field);
      if (this.cache[value2]) {
        this.cache[value2].remove();
        this.cache[value2] = null;
      }
    };
    LinkByColor2.prototype.link = function(args) {
      var context = this.context;
      if (!this.linkGroup) {
        this.linkGroup = context.view.foregroundGroup.addGroup({
          id: "link-by-color-group",
          capture: false
        });
      }
      var element = getCurrentElement(context);
      if (element) {
        this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
      }
    };
    LinkByColor2.prototype.unlink = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        this.removeLink(element);
      }
    };
    LinkByColor2.prototype.clear = function() {
      if (this.linkGroup) {
        this.linkGroup.clear();
      }
      this.cache = {};
    };
    LinkByColor2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.linkGroup) {
        this.linkGroup.remove();
      }
    };
    return LinkByColor2;
  }(base_default12)
);
var link_by_color_default = LinkByColor;

// node_modules/@antv/g2/esm/interaction/action/element/range-state.js
var ElementRangeState = (
  /** @class */
  function(_super) {
    __extends(ElementRangeState2, _super);
    function ElementRangeState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.endPoint = null;
      _this.isStarted = false;
      _this.effectSiblings = false;
      _this.effectByRecord = false;
      return _this;
    }
    ElementRangeState2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    ElementRangeState2.prototype.start = function() {
      this.clear();
      this.startPoint = this.getCurrentPoint();
      this.isStarted = true;
    };
    ElementRangeState2.prototype.getIntersectElements = function() {
      var elements = null;
      if (isMask(this.context)) {
        elements = getMaskedElements(this.context, 10);
      } else {
        var startPoint = this.startPoint;
        var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
        if (!startPoint || !endPoint) {
          return;
        }
        var box2 = {
          minX: Math.min(startPoint.x, endPoint.x),
          minY: Math.min(startPoint.y, endPoint.y),
          maxX: Math.max(startPoint.x, endPoint.x),
          maxY: Math.max(startPoint.y, endPoint.y)
        };
        var view = this.context.view;
        elements = getIntersectElements(view, box2);
      }
      return elements;
    };
    ElementRangeState2.prototype.setStateEnable = function(enable) {
      if (this.effectSiblings && !this.effectByRecord) {
        this.setSiblingsState(enable);
      } else {
        var allElements = getElements(this.context.view);
        var elements = this.getIntersectElements();
        if (elements && elements.length) {
          if (this.effectByRecord) {
            this.setSiblingsStateByRecord(elements, enable);
          } else {
            this.setElementsState(elements, enable, allElements);
          }
        } else {
          this.clear();
        }
      }
    };
    ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      var records = elements.map(function(el) {
        return el.getModel().data;
      });
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      each_default(siblings, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = allElements.filter(function(el) {
          var record = el.getModel().data;
          return isInRecords(records, record, xFiled, yField);
        });
        _this.setElementsState(effectElements, enable, allElements);
      });
    };
    ElementRangeState2.prototype.setSiblingsState = function(enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      if (isMask(this.context)) {
        each_default(siblings, function(sibling) {
          var allElements = getElements(sibling);
          var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
          if (effectElements && effectElements.length) {
            _this.setElementsState(effectElements, enable, allElements);
          } else {
            _this.clearViewState(sibling);
          }
        });
      }
    };
    ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
      var _this = this;
      each_default(allElements, function(el) {
        if (!elements.includes(el)) {
          _this.setElementState(el, false);
        } else {
          _this.setElementState(el, enable);
        }
      });
    };
    ElementRangeState2.prototype.end = function() {
      this.isStarted = false;
      this.endPoint = this.getCurrentPoint();
    };
    ElementRangeState2.prototype.clear = function() {
      var _this = this;
      var view = this.context.view;
      if (this.effectSiblings) {
        var siblings = getSilbings(view);
        each_default(siblings, function(sibling) {
          _this.clearViewState(sibling);
        });
      } else {
        this.clearViewState(view);
      }
    };
    return ElementRangeState2;
  }(state_base_default)
);
var range_state_default = ElementRangeState;

// node_modules/@antv/g2/esm/interaction/action/element/range-active.js
var ElementRangeActive = (
  /** @class */
  function(_super) {
    __extends(ElementRangeActive2, _super);
    function ElementRangeActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeActive2.prototype.active = function() {
      this.setState();
    };
    return ElementRangeActive2;
  }(range_state_default)
);
var range_active_default = ElementRangeActive;

// node_modules/@antv/g2/esm/interaction/action/element/single-state.js
var ElementSingleState = (
  /** @class */
  function(_super) {
    __extends(ElementSingleState2, _super);
    function ElementSingleState2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementSingleState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (!isElementChange(this.context)) {
          return;
        }
        if (enable) {
          this.clear();
          this.setElementState(element, true);
        } else if (this.hasState(element)) {
          this.setElementState(element, false);
        }
      }
    };
    ElementSingleState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = this.hasState(element);
        if (!hasState) {
          this.clear();
        }
        this.setElementState(element, !hasState);
      }
    };
    ElementSingleState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementSingleState2;
  }(state_base_default)
);
var single_state_default = ElementSingleState;

// node_modules/@antv/g2/esm/interaction/action/element/single-active.js
var ElementSingleActive = (
  /** @class */
  function(_super) {
    __extends(ElementSingleActive2, _super);
    function ElementSingleActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleActive2.prototype.active = function() {
      this.setState();
    };
    return ElementSingleActive2;
  }(single_state_default)
);
var single_active_default = ElementSingleActive;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
function clearHighlight(view) {
  var elements = getElements(view);
  each_default(elements, function(el) {
    if (el.hasState(STATUS_ACTIVE)) {
      el.setState(STATUS_ACTIVE, false);
    }
    if (el.hasState(STATUS_UNACTIVE)) {
      el.setState(STATUS_UNACTIVE, false);
    }
  });
}
function setHighlightBy(elements, callback, enable) {
  each_default(elements, function(el) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }
      el.setState(STATUS_ACTIVE, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }
      el.setState(STATUS_UNACTIVE, enable);
    }
  });
}

// node_modules/@antv/g2/esm/interaction/action/element/highlight.js
var STATUS_UNACTIVE2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE2 = ELEMENT_STATE.ACTIVE;
var ElementHighlight = (
  /** @class */
  function(_super) {
    __extends(ElementHighlight2, _super);
    function ElementHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE2;
      return _this;
    }
    ElementHighlight2.prototype.setElementsStateByItem = function(elements, field6, item, enable) {
      var _this = this;
      var callback = function(el) {
        return _this.isMathItem(el, field6, item);
      };
      this.setHighlightBy(elements, callback, enable);
    };
    ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else if (!el.hasState(STATUS_ACTIVE2)) {
        el.setState(STATUS_UNACTIVE2, true);
      }
    };
    ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
      var _this = this;
      if (enable) {
        each_default(elements, function(el) {
          _this.setElementHighlight(el, callback);
        });
      } else {
        var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE2);
        var allCancel_1 = true;
        each_default(activeElements, function(el) {
          if (!callback(el)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(elements, function(el) {
            if (callback(el)) {
              if (el.hasState(STATUS_ACTIVE2)) {
                el.setState(STATUS_ACTIVE2, false);
              }
              el.setState(STATUS_UNACTIVE2, true);
            }
          });
        }
      }
    };
    ElementHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      this.setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementHighlight2;
  }(state_default)
);
var highlight_default = ElementHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js
var HighlightColor = (
  /** @class */
  function(_super) {
    __extends(HighlightColor2, _super);
    function HighlightColor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightColor2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return;
      }
      var scale8 = view.getScaleByField(colorAttr.getFields()[0]);
      var value2 = getElementValue(element, scale8.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale8.field) === value2;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    return HighlightColor2;
  }(highlight_default)
);
var highlight_by_color_default = HighlightColor;

// node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js
var HighlightX = (
  /** @class */
  function(_super) {
    __extends(HighlightX2, _super);
    function HighlightX2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightX2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else {
        el.setState(STATUS_UNACTIVE2, true);
        if (el.hasState(STATUS_ACTIVE2)) {
          el.setState(STATUS_ACTIVE2, false);
        }
      }
    };
    HighlightX2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var scale8 = view.getXScale();
      var value2 = getElementValue(element, scale8.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale8.field) === value2;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    HighlightX2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setStateByElement(element, !hasState);
      }
    };
    return HighlightX2;
  }(highlight_default)
);
var highlight_by_x_default = HighlightX;

// node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js
var EVENTS2;
(function(EVENTS4) {
  EVENTS4["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS4["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS4["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS4["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS2 || (EVENTS2 = {}));
var ElementRangeHighlight = (
  /** @class */
  function(_super) {
    __extends(ElementRangeHighlight2, _super);
    function ElementRangeHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeHighlight2.prototype.clearViewState = function(view) {
      clearHighlight(view);
    };
    ElementRangeHighlight2.prototype.highlight = function() {
      var _a6 = this.context, view = _a6.view, event = _a6.event;
      var elements = this.getIntersectElements();
      var payload = { view, event, highlightElements: elements };
      view.emit(EVENTS2.BEFORE_HIGHLIGHT, event_default.fromData(view, EVENTS2.BEFORE_HIGHLIGHT, payload));
      this.setState();
      view.emit(EVENTS2.AFTER_HIGHLIGHT, event_default.fromData(view, EVENTS2.AFTER_HIGHLIGHT, payload));
    };
    ElementRangeHighlight2.prototype.clear = function() {
      var view = this.context.view;
      view.emit(EVENTS2.BEFORE_CLEAR, event_default.fromData(view, EVENTS2.BEFORE_CLEAR, {}));
      _super.prototype.clear.call(this);
      view.emit(EVENTS2.AFTER_CLEAR, event_default.fromData(view, EVENTS2.AFTER_CLEAR, {}));
    };
    ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
      setHighlightBy(allElements, function(el) {
        return elements.indexOf(el) >= 0;
      }, enable);
    };
    return ElementRangeHighlight2;
  }(range_state_default)
);
var range_highlight_default = ElementRangeHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js
var ElementSingleHighlight = (
  /** @class */
  function(_super) {
    __extends(ElementSingleHighlight2, _super);
    function ElementSingleHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementSingleHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementSingleHighlight2;
  }(single_state_default)
);
var single_highlight_default = ElementSingleHighlight;

// node_modules/@antv/g2/esm/interaction/action/element/range-selected.js
var ElementRangeSelected = (
  /** @class */
  function(_super) {
    __extends(ElementRangeSelected2, _super);
    function ElementRangeSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementRangeSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementRangeSelected2;
  }(range_state_default)
);
var range_selected_default = ElementRangeSelected;

// node_modules/@antv/g2/esm/interaction/action/element/selected.js
var ElementMultipleSelected = (
  /** @class */
  function(_super) {
    __extends(ElementMultipleSelected2, _super);
    function ElementMultipleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementMultipleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementMultipleSelected2;
  }(state_default)
);
var selected_default = ElementMultipleSelected;

// node_modules/@antv/g2/esm/interaction/action/element/single-selected.js
var ElementSingleSelected = (
  /** @class */
  function(_super) {
    __extends(ElementSingleSelected2, _super);
    function ElementSingleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementSingleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementSingleSelected2;
  }(single_state_default)
);
var single_selected_default = ElementSingleSelected;

// node_modules/@antv/g2/esm/interaction/action/component/list-state.js
var ListState = (
  /** @class */
  function(_super) {
    __extends(ListState2, _super);
    function ListState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      _this.ignoreItemStates = [];
      return _this;
    }
    ListState2.prototype.getTriggerListInfo = function() {
      var delegateObject = getDelegationObject(this.context);
      var info = null;
      if (isList(delegateObject)) {
        info = {
          item: delegateObject.item,
          list: delegateObject.component
        };
      }
      return info;
    };
    ListState2.prototype.getAllowComponents = function() {
      var _this = this;
      var view = this.context.view;
      var components = getComponents(view);
      var rst = [];
      each_default(components, function(component2) {
        if (component2.isList() && _this.allowSetStateByElement(component2)) {
          rst.push(component2);
        }
      });
      return rst;
    };
    ListState2.prototype.hasState = function(list, item) {
      return list.hasState(item, this.stateName);
    };
    ListState2.prototype.clearAllComponentsState = function() {
      var _this = this;
      var components = this.getAllowComponents();
      each_default(components, function(component2) {
        component2.clearItemsState(_this.stateName);
      });
    };
    ListState2.prototype.allowSetStateByElement = function(component2) {
      var field6 = component2.get("field");
      if (!field6) {
        return false;
      }
      if (this.cfg && this.cfg.componentNames) {
        var name_1 = component2.get("name");
        if (this.cfg.componentNames.indexOf(name_1) === -1) {
          return false;
        }
      }
      var view = this.context.view;
      var scale8 = getScaleByField(view, field6);
      return scale8 && scale8.isCategory;
    };
    ListState2.prototype.allowSetStateByItem = function(item, list) {
      var ignoreStates = this.ignoreItemStates;
      if (ignoreStates.length) {
        var filterStates = ignoreStates.filter(function(state2) {
          return list.hasState(item, state2);
        });
        return filterStates.length === 0;
      }
      return true;
    };
    ListState2.prototype.setStateByElement = function(component2, element, enable) {
      var field6 = component2.get("field");
      var view = this.context.view;
      var scale8 = getScaleByField(view, field6);
      var value2 = getElementValue(element, field6);
      var text = scale8.getText(value2);
      this.setItemsState(component2, text, enable);
    };
    ListState2.prototype.setStateEnable = function(enable) {
      var _this = this;
      var element = getCurrentElement(this.context);
      if (element) {
        var components = this.getAllowComponents();
        each_default(components, function(component3) {
          _this.setStateByElement(component3, element, enable);
        });
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component2 = delegateObject.component;
          if (this.allowSetStateByElement(component2) && this.allowSetStateByItem(item, component2)) {
            this.setItemState(component2, item, enable);
          }
        }
      }
    };
    ListState2.prototype.setItemsState = function(list, name, enable) {
      var _this = this;
      var items = list.getItems();
      each_default(items, function(item) {
        if (item.name === name) {
          _this.setItemState(list, item, enable);
        }
      });
    };
    ListState2.prototype.setItemState = function(list, item, enable) {
      list.setItemState(item, this.stateName, enable);
    };
    ListState2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    ListState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    ListState2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        var enable = this.hasState(list, item);
        this.setItemState(list, item, !enable);
      }
    };
    ListState2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        triggerInfo.list.clearItemsState(this.stateName);
      } else {
        this.clearAllComponentsState();
      }
    };
    return ListState2;
  }(base_default12)
);
var list_state_default = ListState;

// node_modules/@antv/g2/esm/interaction/action/component/list-active.js
var ListActive = (
  /** @class */
  function(_super) {
    __extends(ListActive2, _super);
    function ListActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ListActive2.prototype.active = function() {
      this.setState();
    };
    return ListActive2;
  }(list_state_default)
);
var list_active_default = ListActive;

// node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js
var STATUS_UNACTIVE3 = "inactive";
var STATUS_ACTIVE3 = "active";
function clearList(list) {
  var items = list.getItems();
  each_default(items, function(item) {
    if (list.hasState(item, STATUS_ACTIVE3)) {
      list.setItemState(item, STATUS_ACTIVE3, false);
    }
    if (list.hasState(item, STATUS_UNACTIVE3)) {
      list.setItemState(item, STATUS_UNACTIVE3, false);
    }
  });
}

// node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js
var STATUS_UNACTIVE4 = "inactive";
var STATUS_ACTIVE4 = "active";
var ListHighlight = (
  /** @class */
  function(_super) {
    __extends(ListHighlight2, _super);
    function ListHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE4;
      _this.ignoreItemStates = ["unchecked"];
      return _this;
    }
    ListHighlight2.prototype.setItemsState = function(list, name, enable) {
      this.setHighlightBy(list, function(item) {
        return item.name === name;
      }, enable);
    };
    ListHighlight2.prototype.setItemState = function(list, item, enable) {
      var items = list.getItems();
      this.setHighlightBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNACTIVE4)) {
              list.setItemState(item, STATUS_UNACTIVE4, false);
            }
            list.setItemState(item, STATUS_ACTIVE4, true);
          } else if (!list.hasState(item, STATUS_ACTIVE4)) {
            list.setItemState(item, STATUS_UNACTIVE4, true);
          }
        });
      } else {
        var activeItems = list.getItemsByState(STATUS_ACTIVE4);
        var allCancel_1 = true;
        each_default(activeItems, function(item) {
          if (!callback(item)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(items, function(item) {
            if (callback(item)) {
              if (list.hasState(item, STATUS_ACTIVE4)) {
                list.setItemState(item, STATUS_ACTIVE4, false);
              }
              list.setItemState(item, STATUS_UNACTIVE4, true);
            }
          });
        }
      }
    };
    ListHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ListHighlight2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        clearList(triggerInfo.list);
      } else {
        var components = this.getAllowComponents();
        each_default(components, function(component2) {
          component2.clearItemsState(STATUS_ACTIVE4);
          component2.clearItemsState(STATUS_UNACTIVE4);
        });
      }
    };
    return ListHighlight2;
  }(list_state_default)
);
var list_highlight_default = ListHighlight;

// node_modules/@antv/g2/esm/interaction/action/component/list-selected.js
var ListSelected = (
  /** @class */
  function(_super) {
    __extends(ListSelected2, _super);
    function ListSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ListSelected2.prototype.selected = function() {
      this.setState();
    };
    return ListSelected2;
  }(list_state_default)
);
var list_selected_default = ListSelected;

// node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js
var ListUnchecked = (
  /** @class */
  function(_super) {
    __extends(ListUnchecked2, _super);
    function ListUnchecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "unchecked";
      return _this;
    }
    ListUnchecked2.prototype.unchecked = function() {
      this.setState();
    };
    return ListUnchecked2;
  }(list_state_default)
);
var list_unchecked_default = ListUnchecked;

// node_modules/@antv/g2/esm/interaction/action/component/list-checked.js
var STATUS_UNCHECKED = "unchecked";
var STATUS_CHECKED = "checked";
var ListChecked = (
  /** @class */
  function(_super) {
    __extends(ListChecked2, _super);
    function ListChecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_CHECKED;
      return _this;
    }
    ListChecked2.prototype.setItemState = function(list, item, enable) {
      this.setCheckedBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNCHECKED)) {
              list.setItemState(item, STATUS_UNCHECKED, false);
            }
            list.setItemState(item, STATUS_CHECKED, true);
          } else if (!list.hasState(item, STATUS_CHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED, true);
          }
        });
      }
    };
    ListChecked2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list_1 = triggerInfo.list, item = triggerInfo.item;
        var allChecked = !some_default(list_1.getItems(), function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED);
        });
        if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
          this.setItemState(list_1, item, true);
        } else {
          this.reset();
        }
      }
    };
    ListChecked2.prototype.checked = function() {
      this.setState();
    };
    ListChecked2.prototype.reset = function() {
      var components = this.getAllowComponents();
      each_default(components, function(component2) {
        component2.clearItemsState(STATUS_CHECKED);
        component2.clearItemsState(STATUS_UNCHECKED);
      });
    };
    return ListChecked2;
  }(list_state_default)
);
var list_checked_default = ListChecked;

// node_modules/@antv/g2/esm/interaction/action/component/list-focus.js
var STATUS_UNCHECKED2 = "unchecked";
var ListFocus = (
  /** @class */
  function(_super) {
    __extends(ListFocus2, _super);
    function ListFocus2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ListFocus2.prototype.toggle = function() {
      var e_1, _a6, e_2, _b, e_3, _c, e_4, _d;
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
        var items = list_1.getItems();
        var checkedItems = items.filter(function(t) {
          return !list_1.hasState(t, STATUS_UNCHECKED2);
        });
        var uncheckedItems = items.filter(function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED2);
        });
        var checkedItem = checkedItems[0];
        if (items.length === checkedItems.length) {
          try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
              var item = items_1_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (items_1_1 && !items_1_1.done && (_a6 = items_1.return))
                _a6.call(items_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else if (items.length - uncheckedItems.length === 1) {
          if (checkedItem.id === clickedItem.id) {
            try {
              for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                var item = items_2_1.value;
                list_1.setItemState(item, STATUS_UNCHECKED2, false);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (items_2_1 && !items_2_1.done && (_b = items_2.return))
                  _b.call(items_2);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          } else {
            try {
              for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                var item = items_3_1.value;
                list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (items_3_1 && !items_3_1.done && (_c = items_3.return))
                  _c.call(items_3);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
          }
        } else {
          try {
            for (var items_4 = __values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
              var item = items_4_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED2, item.id !== clickedItem.id);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (items_4_1 && !items_4_1.done && (_d = items_4.return))
                _d.call(items_4);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
        }
      }
    };
    return ListFocus2;
  }(list_state_default)
);
var list_focus_default = ListFocus;

// node_modules/@antv/g2/esm/interaction/action/component/list-radio.js
var STATUS_SHOW = "showRadio";
var TIP_ID = "legend-radio-tip";
var ListRadio = (
  /** @class */
  function(_super) {
    __extends(ListRadio2, _super);
    function ListRadio2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    ListRadio2.prototype.show = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        list.setItemState(item, STATUS_SHOW, true);
      }
    };
    ListRadio2.prototype.hide = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        list.setItemState(item, STATUS_SHOW, false);
      }
    };
    ListRadio2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    ListRadio2.prototype.showTip = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      var target = this.context.event.target;
      if (timeStamp - lastTimeStamp > 16 && target.get("name") === "legend-item-radio") {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        this.timeStamp = timeStamp;
        this.location = curLoc;
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
      }
    };
    ListRadio2.prototype.hideTip = function() {
      this.hideTooltip();
      this.location = null;
    };
    ListRadio2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target = ev.target;
      if (target && target.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var _a6 = context.view.getCanvas().get("el").getBoundingClientRect(), offsetX = _a6.x, offsetY = _a6.y;
        this.tooltip.update(__assign(__assign({ title: target.get("tip") }, curLoc), { x: curLoc.x + offsetX, y: curLoc.y + offsetY }));
        this.tooltip.show();
      }
    };
    ListRadio2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    ListRadio2.prototype.renderTooltip = function() {
      var _a6;
      var tooltipStyles = (_a6 = {}, _a6[css_const_exports2.CONTAINER_CLASS] = {
        padding: "6px 8px",
        transform: "translate(-50%, -80%)",
        background: "rgba(0,0,0,0.75)",
        color: "#fff",
        "border-radius": "2px",
        // 
        "z-index": 100
      }, _a6[css_const_exports2.TITLE_CLASS] = {
        "font-size": "12px",
        "line-height": "14px",
        "margin-bottom": 0,
        "word-break": "break-all"
      }, _a6);
      if (document.getElementById(TIP_ID)) {
        document.body.removeChild(document.getElementById(TIP_ID));
      }
      var tooltip11 = new HtmlTooltip({
        parent: document.body,
        // tooltip 
        region: null,
        visible: false,
        crosshairs: null,
        domStyles: tooltipStyles,
        containerId: TIP_ID
      });
      tooltip11.init();
      tooltip11.setCapture(false);
      this.tooltip = tooltip11;
    };
    return ListRadio2;
  }(list_state_default)
);
var list_radio_default = ListRadio;

// node_modules/@antv/g2/esm/interaction/action/mask/base.js
var MaskBase = (
  /** @class */
  function(_super) {
    __extends(MaskBase2, _super);
    function MaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShape = null;
      _this.points = [];
      _this.starting = false;
      _this.moving = false;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      return _this;
    }
    MaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MaskBase2.prototype.emitEvent = function(type) {
      var eventName = "mask:".concat(type);
      var view = this.context.view;
      var event = this.context.event;
      view.emit(eventName, {
        target: this.maskShape,
        shape: this.maskShape,
        points: this.points,
        x: event.x,
        y: event.y
      });
    };
    MaskBase2.prototype.createMask = function() {
      var view = this.context.view;
      var maskAttrs = this.getMaskAttrs();
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      return maskShape;
    };
    MaskBase2.prototype.getMaskPath = function() {
      return [];
    };
    MaskBase2.prototype.show = function() {
      if (this.maskShape) {
        this.maskShape.show();
        this.emitEvent("show");
      }
    };
    MaskBase2.prototype.start = function(arg) {
      this.starting = true;
      this.moving = false;
      this.points = [this.getCurrentPoint()];
      if (!this.maskShape) {
        this.maskShape = this.createMask();
        this.maskShape.set("capture", false);
      }
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
    };
    MaskBase2.prototype.move = function() {
      if (!this.moving || !this.maskShape) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var points2 = this.points;
      each_default(points2, function(point2) {
        point2.x += dx;
        point2.y += dy;
      });
      this.updateMask();
      this.emitEvent("change");
      this.preMovePoint = currentPoint;
    };
    MaskBase2.prototype.updateMask = function(maskStyle) {
      var attrs = deep_mix_default({}, this.getMaskAttrs(), maskStyle);
      this.maskShape.attr(attrs);
    };
    MaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
    };
    MaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      if (this.maskShape) {
        this.maskShape.set("capture", true);
      }
    };
    MaskBase2.prototype.hide = function() {
      if (this.maskShape) {
        this.maskShape.hide();
        this.emitEvent("hide");
      }
    };
    MaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShape) {
        this.points.push(this.getCurrentPoint());
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MaskBase2.prototype.destroy = function() {
      this.points = [];
      if (this.maskShape) {
        this.maskShape.remove();
      }
      this.maskShape = null;
      this.preMovePoint = null;
      _super.prototype.destroy.call(this);
    };
    return MaskBase2;
  }(base_default12)
);
var base_default17 = MaskBase;

// node_modules/@antv/g2/esm/interaction/action/mask/circle.js
function getMaskAttrs(points2) {
  var currentPoint = last(points2);
  var r = 0;
  var x = 0;
  var y = 0;
  if (points2.length) {
    var first = points2[0];
    r = distance6(first, currentPoint) / 2;
    x = (currentPoint.x + first.x) / 2;
    y = (currentPoint.y + first.y) / 2;
  }
  return {
    x,
    y,
    r
  };
}
var CircleMask = (
  /** @class */
  function(_super) {
    __extends(CircleMask2, _super);
    function CircleMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      return _this;
    }
    CircleMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs(this.points);
    };
    return CircleMask2;
  }(base_default17)
);
var circle_default8 = CircleMask;

// node_modules/@antv/g2/esm/interaction/action/mask/rect.js
function getRegion(points2) {
  return {
    start: head(points2),
    end: last(points2)
  };
}
function getMaskAttrs2(start, end) {
  var x = Math.min(start.x, end.x);
  var y = Math.min(start.y, end.y);
  var width = Math.abs(end.x - start.x);
  var height = Math.abs(end.y - start.y);
  return {
    x,
    y,
    width,
    height
  };
}
var RectMask = (
  /** @class */
  function(_super) {
    __extends(RectMask2, _super);
    function RectMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMask2.prototype.getRegion = function() {
      return getRegion(this.points);
    };
    RectMask2.prototype.getMaskAttrs = function() {
      var _a6 = this.getRegion(), start = _a6.start, end = _a6.end;
      return getMaskAttrs2(start, end);
    };
    return RectMask2;
  }(base_default17)
);
var rect_default5 = RectMask;

// node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js
function clampPoint(point2) {
  point2.x = clamp_default(point2.x, 0, 1);
  point2.y = clamp_default(point2.y, 0, 1);
}
function getRegion2(points2, dim, inPlot, coord2) {
  var start = null;
  var end = null;
  var normalStart = coord2.invert(head(points2));
  var normalEnd = coord2.invert(last(points2));
  if (inPlot) {
    clampPoint(normalStart);
    clampPoint(normalEnd);
  }
  if (dim === "x") {
    start = coord2.convert({
      x: normalStart.x,
      y: 0
    });
    end = coord2.convert({
      x: normalEnd.x,
      y: 1
    });
  } else {
    start = coord2.convert({
      x: 0,
      y: normalStart.y
    });
    end = coord2.convert({
      x: 1,
      y: normalEnd.y
    });
  }
  return {
    start,
    end
  };
}
var DimRect = (
  /** @class */
  function(_super) {
    __extends(DimRect2, _super);
    function DimRect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRect2.prototype.getRegion = function() {
      var coord2 = this.context.view.getCoordinate();
      return getRegion2(this.points, this.dim, this.inPlot, coord2);
    };
    return DimRect2;
  }(rect_default5)
);
var dim_rect_default = DimRect;

// node_modules/@antv/g2/esm/interaction/action/mask/path.js
function getMaskPath2(points2) {
  var path = [];
  if (points2.length) {
    each_default(points2, function(point2, index) {
      if (index === 0) {
        path.push(["M", point2.x, point2.y]);
      } else {
        path.push(["L", point2.x, point2.y]);
      }
    });
    path.push(["L", points2[0].x, points2[0].y]);
  }
  return path;
}
function getMaskAttrs3(points2) {
  return {
    path: getMaskPath2(points2)
  };
}
var PathMask = (
  /** @class */
  function(_super) {
    __extends(PathMask2, _super);
    function PathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PathMask2.prototype.getMaskPath = function() {
      return getMaskPath2(this.points);
    };
    PathMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs3(this.points);
    };
    PathMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMask2;
  }(base_default17)
);
var path_default6 = PathMask;

// node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js
function getMaskPath3(points2) {
  return getSpline(points2, true);
}
function getMaskAttrs4(points2) {
  return {
    path: getMaskPath3(points2)
  };
}
var SmoothPathMask = (
  /** @class */
  function(_super) {
    __extends(SmoothPathMask2, _super);
    function SmoothPathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SmoothPathMask2.prototype.getMaskPath = function() {
      return getMaskPath3(this.points);
    };
    SmoothPathMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs4(this.points);
    };
    return SmoothPathMask2;
  }(path_default6)
);
var smooth_path_default = SmoothPathMask;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/base.js
var MultipleMaskBase = (
  /** @class */
  function(_super) {
    __extends(MultipleMaskBase2, _super);
    function MultipleMaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShapes = [];
      _this.starting = false;
      _this.moving = false;
      _this.recordPoints = null;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      _this.maskType = "multi-mask";
      return _this;
    }
    MultipleMaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MultipleMaskBase2.prototype.emitEvent = function(type) {
      var eventName = "".concat(this.maskType, ":").concat(type);
      var view = this.context.view;
      var event = this.context.event;
      var target = {
        type: this.shapeType,
        name: this.maskType,
        get: function(key) {
          return target.hasOwnProperty(key) ? target[key] : void 0;
        }
      };
      view.emit(eventName, {
        target,
        maskShapes: this.maskShapes,
        multiPoints: this.recordPoints,
        x: event.x,
        y: event.y
      });
    };
    MultipleMaskBase2.prototype.createMask = function(index) {
      var view = this.context.view;
      var points2 = this.recordPoints[index];
      var maskAttrs = this.getMaskAttrs(points2);
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      this.maskShapes.push(maskShape);
    };
    MultipleMaskBase2.prototype.getMaskPath = function(points2) {
      return [];
    };
    MultipleMaskBase2.prototype.show = function() {
      if (this.maskShapes.length > 0) {
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.show();
        });
        this.emitEvent("show");
      }
    };
    MultipleMaskBase2.prototype.start = function(arg) {
      this.recordPointStart();
      this.starting = true;
      this.moving = false;
      var index = this.recordPoints.length - 1;
      this.createMask(index);
      this.updateShapesCapture(false);
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MultipleMaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
      this.updateShapesCapture(false);
    };
    MultipleMaskBase2.prototype.move = function() {
      if (!this.moving || this.maskShapes.length === 0) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var index = this.getCurMaskShapeIndex();
      if (index > -1) {
        this.recordPoints[index].forEach(function(point2) {
          point2.x += dx;
          point2.y += dy;
        });
        this.updateMask();
        this.emitEvent("change");
        this.preMovePoint = currentPoint;
      }
    };
    MultipleMaskBase2.prototype.updateMask = function(maskStyle) {
      var _this = this;
      this.recordPoints.forEach(function(points2, index) {
        var attrs = deep_mix_default({}, _this.getMaskAttrs(points2), maskStyle);
        _this.maskShapes[index].attr(attrs);
      });
    };
    MultipleMaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShapes.length > 0) {
        this.recordPointContinue();
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MultipleMaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
      this.updateShapesCapture(true);
    };
    MultipleMaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      this.updateShapesCapture(true);
    };
    MultipleMaskBase2.prototype.hide = function() {
      if (this.maskShapes.length > 0) {
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.hide();
        });
        this.emitEvent("hide");
      }
    };
    MultipleMaskBase2.prototype.remove = function() {
      var index = this.getCurMaskShapeIndex();
      if (index > -1) {
        this.recordPoints.splice(index, 1);
        this.maskShapes[index].remove();
        this.maskShapes.splice(index, 1);
        this.preMovePoint = null;
        this.updateShapesCapture(true);
        this.emitEvent("change");
      }
    };
    MultipleMaskBase2.prototype.clearAll = function() {
      this.recordPointClear();
      this.maskShapes.forEach(function(maskShape) {
        return maskShape.remove();
      });
      this.maskShapes = [];
      this.preMovePoint = null;
    };
    MultipleMaskBase2.prototype.clear = function() {
      var index = this.getCurMaskShapeIndex();
      if (index === -1) {
        this.recordPointClear();
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.remove();
        });
        this.maskShapes = [];
        this.emitEvent("clearAll");
      } else {
        this.recordPoints.splice(index, 1);
        this.maskShapes[index].remove();
        this.maskShapes.splice(index, 1);
        this.preMovePoint = null;
        this.emitEvent("clearSingle");
      }
      this.preMovePoint = null;
    };
    MultipleMaskBase2.prototype.destroy = function() {
      this.clear();
      _super.prototype.destroy.call(this);
    };
    MultipleMaskBase2.prototype.getRecordPoints = function() {
      var _a6;
      return __spreadArray([], __read((_a6 = this.recordPoints) !== null && _a6 !== void 0 ? _a6 : []), false);
    };
    MultipleMaskBase2.prototype.recordPointStart = function() {
      var recordPoints = this.getRecordPoints();
      var currentPoint = this.getCurrentPoint();
      this.recordPoints = __spreadArray(__spreadArray([], __read(recordPoints), false), [[currentPoint]], false);
    };
    MultipleMaskBase2.prototype.recordPointContinue = function() {
      var recordPoints = this.getRecordPoints();
      var currentPoint = this.getCurrentPoint();
      var lastPoints = recordPoints.splice(-1, 1)[0] || [];
      lastPoints.push(currentPoint);
      this.recordPoints = __spreadArray(__spreadArray([], __read(recordPoints), false), [lastPoints], false);
    };
    MultipleMaskBase2.prototype.recordPointClear = function() {
      this.recordPoints = [];
    };
    MultipleMaskBase2.prototype.updateShapesCapture = function(isCapture) {
      this.maskShapes.forEach(function(maskShape) {
        return maskShape.set("capture", isCapture);
      });
    };
    MultipleMaskBase2.prototype.getCurMaskShapeIndex = function() {
      var currentPoint = this.getCurrentPoint();
      return this.maskShapes.findIndex(function(maskShape) {
        var _a6 = maskShape.attrs, width = _a6.width, height = _a6.height, r = _a6.r;
        var isEmpty3 = width === 0 || height === 0 || r === 0;
        return !isEmpty3 && maskShape.isHit(currentPoint.x, currentPoint.y);
      });
    };
    return MultipleMaskBase2;
  }(base_default12)
);
var base_default18 = MultipleMaskBase;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/rect.js
var RectMultiMask = (
  /** @class */
  function(_super) {
    __extends(RectMultiMask2, _super);
    function RectMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMultiMask2.prototype.getRegion = function(points2) {
      return getRegion(points2);
    };
    RectMultiMask2.prototype.getMaskAttrs = function(points2) {
      var _a6 = this.getRegion(points2), start = _a6.start, end = _a6.end;
      return getMaskAttrs2(start, end);
    };
    return RectMultiMask2;
  }(base_default18)
);
var rect_default6 = RectMultiMask;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/dim-rect.js
var DimRectMultiMask = (
  /** @class */
  function(_super) {
    __extends(DimRectMultiMask2, _super);
    function DimRectMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRectMultiMask2.prototype.getRegion = function(points2) {
      var coord2 = this.context.view.getCoordinate();
      return getRegion2(points2, this.dim, this.inPlot, coord2);
    };
    return DimRectMultiMask2;
  }(rect_default6)
);
var dim_rect_default2 = DimRectMultiMask;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/circle.js
var CircleMultiMask = (
  /** @class */
  function(_super) {
    __extends(CircleMultiMask2, _super);
    function CircleMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      _this.getMaskAttrs = getMaskAttrs;
      return _this;
    }
    return CircleMultiMask2;
  }(base_default18)
);
var circle_default9 = CircleMultiMask;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/path.js
var PathMultiMask = (
  /** @class */
  function(_super) {
    __extends(PathMultiMask2, _super);
    function PathMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.getMaskPath = getMaskPath2;
      _this.getMaskAttrs = getMaskAttrs3;
      return _this;
    }
    PathMultiMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMultiMask2;
  }(base_default18)
);
var path_default7 = PathMultiMask;

// node_modules/@antv/g2/esm/interaction/action/mask/multiple/smooth-path.js
var SmoothPathMultiMask = (
  /** @class */
  function(_super) {
    __extends(SmoothPathMultiMask2, _super);
    function SmoothPathMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.getMaskPath = getMaskPath3;
      _this.getMaskAttrs = getMaskAttrs4;
      return _this;
    }
    return SmoothPathMultiMask2;
  }(path_default7)
);
var smooth_path_default2 = SmoothPathMultiMask;

// node_modules/@antv/g2/esm/interaction/action/cursor.js
var CursorAction = (
  /** @class */
  function(_super) {
    __extends(CursorAction2, _super);
    function CursorAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CursorAction2.prototype.setCursor = function(cursor) {
      var view = this.context.view;
      view.getCanvas().setCursor(cursor);
    };
    CursorAction2.prototype.default = function() {
      this.setCursor("default");
    };
    CursorAction2.prototype.pointer = function() {
      this.setCursor("pointer");
    };
    CursorAction2.prototype.move = function() {
      this.setCursor("move");
    };
    CursorAction2.prototype.crosshair = function() {
      this.setCursor("crosshair");
    };
    CursorAction2.prototype.wait = function() {
      this.setCursor("wait");
    };
    CursorAction2.prototype.help = function() {
      this.setCursor("help");
    };
    CursorAction2.prototype.text = function() {
      this.setCursor("text");
    };
    CursorAction2.prototype.eResize = function() {
      this.setCursor("e-resize");
    };
    CursorAction2.prototype.wResize = function() {
      this.setCursor("w-resize");
    };
    CursorAction2.prototype.nResize = function() {
      this.setCursor("n-resize");
    };
    CursorAction2.prototype.sResize = function() {
      this.setCursor("s-resize");
    };
    CursorAction2.prototype.neResize = function() {
      this.setCursor("ne-resize");
    };
    CursorAction2.prototype.nwResize = function() {
      this.setCursor("nw-resize");
    };
    CursorAction2.prototype.seResize = function() {
      this.setCursor("se-resize");
    };
    CursorAction2.prototype.swResize = function() {
      this.setCursor("sw-resize");
    };
    CursorAction2.prototype.nsResize = function() {
      this.setCursor("ns-resize");
    };
    CursorAction2.prototype.ewResize = function() {
      this.setCursor("ew-resize");
    };
    CursorAction2.prototype.zoomIn = function() {
      this.setCursor("zoom-in");
    };
    CursorAction2.prototype.zoomOut = function() {
      this.setCursor("zoom-out");
    };
    return CursorAction2;
  }(base_default12)
);
var cursor_default = CursorAction;

// node_modules/@antv/g2/esm/interaction/action/data/filter.js
var DataFilter = (
  /** @class */
  function(_super) {
    __extends(DataFilter2, _super);
    function DataFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFilter2.prototype.filterView = function(view, field6, filter3) {
      var _this = this;
      if (view.getScaleByField(field6)) {
        view.filter(field6, filter3);
      }
      if (view.views && view.views.length) {
        each_default(view.views, function(subView) {
          _this.filterView(subView, field6, filter3);
        });
      }
    };
    DataFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component2 = delegateObject.component;
        var field6 = component2.get("field");
        if (isList(delegateObject)) {
          if (field6) {
            var unCheckedItems = component2.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field6);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            if (names_1.length) {
              this.filterView(view, field6, function(value2) {
                var text = scale_1.getText(value2);
                return !names_1.includes(text);
              });
            } else {
              this.filterView(view, field6, null);
            }
            view.render(true);
          }
        } else if (isSlider(delegateObject)) {
          var range2 = component2.getValue();
          var _a6 = __read(range2, 2), min_1 = _a6[0], max_1 = _a6[1];
          this.filterView(view, field6, function(value2) {
            return value2 >= min_1 && value2 <= max_1;
          });
          view.render(true);
        }
      }
    };
    return DataFilter2;
  }(base_default12)
);
var filter_default2 = DataFilter;

// node_modules/@antv/g2/esm/interaction/action/data/range-filter.js
function getFilter(scale8, dim, point1, point2) {
  var min5 = Math.min(point1[dim], point2[dim]);
  var max5 = Math.max(point1[dim], point2[dim]);
  var _a6 = __read(scale8.range, 2), rangeMin = _a6[0], rangeMax = _a6[1];
  if (min5 < rangeMin) {
    min5 = rangeMin;
  }
  if (max5 > rangeMax) {
    max5 = rangeMax;
  }
  if (min5 === rangeMax && max5 === rangeMax) {
    return null;
  }
  var minValue = scale8.invert(min5);
  var maxValue = scale8.invert(max5);
  if (scale8.isCategory) {
    var minIndex = scale8.values.indexOf(minValue);
    var maxIndex = scale8.values.indexOf(maxValue);
    var arr_1 = scale8.values.slice(minIndex, maxIndex + 1);
    return function(value2) {
      return arr_1.includes(value2);
    };
  } else {
    return function(value2) {
      return value2 >= minValue && value2 <= maxValue;
    };
  }
}
var EVENTS3;
(function(EVENTS4) {
  EVENTS4["FILTER"] = "brush-filter-processing";
  EVENTS4["RESET"] = "brush-filter-reset";
  EVENTS4["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS4["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS4["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS4["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS3 || (EVENTS3 = {}));
var RangeFilter = (
  /** @class */
  function(_super) {
    __extends(RangeFilter2, _super);
    function RangeFilter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = ["x", "y"];
      _this.startPoint = null;
      _this.isStarted = false;
      return _this;
    }
    RangeFilter2.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    RangeFilter2.prototype.start = function() {
      var context = this.context;
      this.isStarted = true;
      this.startPoint = context.getCurrentPoint();
    };
    RangeFilter2.prototype.filter = function() {
      var startPoint;
      var currentPoint;
      if (isMask(this.context)) {
        var maskShape = this.context.event.target;
        var bbox = maskShape.getCanvasBBox();
        startPoint = { x: bbox.x, y: bbox.y };
        currentPoint = { x: bbox.maxX, y: bbox.maxY };
      } else {
        if (!this.isStarted) {
          return;
        }
        startPoint = this.startPoint;
        currentPoint = this.context.getCurrentPoint();
      }
      if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
        return;
      }
      var _a6 = this.context, view = _a6.view, event = _a6.event;
      var payload = { view, event, dims: this.dims };
      view.emit(EVENTS3.BEFORE_FILTER, event_default.fromData(view, EVENTS3.BEFORE_FILTER, payload));
      var coord2 = view.getCoordinate();
      var normalCurrent = coord2.invert(currentPoint);
      var normalStart = coord2.invert(startPoint);
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        var filter3 = getFilter(xScale, "x", normalCurrent, normalStart);
        this.filterView(view, xScale.field, filter3);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        var filter3 = getFilter(yScale, "y", normalCurrent, normalStart);
        this.filterView(view, yScale.field, filter3);
      }
      this.reRender(view, { source: EVENTS3.FILTER });
      view.emit(EVENTS3.AFTER_FILTER, event_default.fromData(view, EVENTS3.AFTER_FILTER, payload));
    };
    RangeFilter2.prototype.end = function() {
      this.isStarted = false;
    };
    RangeFilter2.prototype.reset = function() {
      var view = this.context.view;
      view.emit(EVENTS3.BEFORE_RESET, event_default.fromData(view, EVENTS3.BEFORE_RESET, {}));
      this.isStarted = false;
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        this.filterView(view, xScale.field, null);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        this.filterView(view, yScale.field, null);
      }
      this.reRender(view, { source: EVENTS3.RESET });
      view.emit(EVENTS3.AFTER_RESET, event_default.fromData(view, EVENTS3.AFTER_RESET, {}));
    };
    RangeFilter2.prototype.filterView = function(view, field6, filter3) {
      view.filter(field6, filter3);
    };
    RangeFilter2.prototype.reRender = function(view, payload) {
      view.render(true, payload);
    };
    return RangeFilter2;
  }(base_default12)
);
var range_filter_default = RangeFilter;

// node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js
var SiblingFilter = (
  /** @class */
  function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingFilter3.prototype.filterView = function(view, field6, filter3) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.filter(field6, filter3);
      });
    };
    SiblingFilter3.prototype.reRender = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.render(true);
      });
    };
    return SiblingFilter3;
  }(range_filter_default)
);
var sibling_filter_default = SiblingFilter;

// node_modules/@antv/g2/esm/interaction/action/element/filter.js
var ElementFilter = (
  /** @class */
  function(_super) {
    __extends(ElementFilter2, _super);
    function ElementFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      var view = this.context.view;
      var elements = getElements(view);
      if (isMask(this.context)) {
        var maskElements_1 = getMaskedElements(this.context, 10);
        if (maskElements_1) {
          each_default(elements, function(el) {
            if (maskElements_1.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      } else if (delegateObject) {
        var component2 = delegateObject.component;
        var field_1 = component2.get("field");
        if (isList(delegateObject)) {
          if (field_1) {
            var unCheckedItems = component2.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field_1);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            each_default(elements, function(el) {
              var value2 = getElementValue(el, field_1);
              var text = scale_1.getText(value2);
              if (names_1.indexOf(text) >= 0) {
                el.hide();
              } else {
                el.show();
              }
            });
          }
        } else if (isSlider(delegateObject)) {
          var range2 = component2.getValue();
          var _a6 = __read(range2, 2), min_1 = _a6[0], max_1 = _a6[1];
          each_default(elements, function(el) {
            var value2 = getElementValue(el, field_1);
            if (value2 >= min_1 && value2 <= max_1) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      }
    };
    ElementFilter2.prototype.clear = function() {
      var elements = getElements(this.context.view);
      each_default(elements, function(el) {
        el.show();
      });
    };
    ElementFilter2.prototype.reset = function() {
      this.clear();
    };
    return ElementFilter2;
  }(base_default12)
);
var filter_default3 = ElementFilter;

// node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js
var SiblingFilter2 = (
  /** @class */
  function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.byRecord = false;
      return _this;
    }
    SiblingFilter3.prototype.filter = function() {
      if (isMask(this.context)) {
        if (this.byRecord) {
          this.filterByRecord();
        } else {
          this.filterByBBox();
        }
      }
    };
    SiblingFilter3.prototype.filterByRecord = function() {
      var view = this.context.view;
      var maskElements = getMaskedElements(this.context, 10);
      if (!maskElements) {
        return;
      }
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      var records = maskElements.map(function(el) {
        return el.getModel().data;
      });
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          var record = el.getModel().data;
          if (isInRecords(records, record, xFiled, yField)) {
            el.show();
          } else {
            el.hide();
          }
        });
      });
    };
    SiblingFilter3.prototype.filterByBBox = function() {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
        var elements = getElements(sibling);
        if (maskElements) {
          each_default(elements, function(el) {
            if (maskElements.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      });
    };
    SiblingFilter3.prototype.reset = function() {
      var siblings = getSilbings(this.context.view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          el.show();
        });
      });
    };
    return SiblingFilter3;
  }(base_default12)
);
var sibling_filter_default2 = SiblingFilter2;

// node_modules/@antv/g2/esm/interaction/action/view/button.js
var PADDING_RIGHT = 10;
var PADDING_TOP = 5;
var ButtonAction = (
  /** @class */
  function(_super) {
    __extends(ButtonAction3, _super);
    function ButtonAction3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = {
        name: "button",
        text: "button",
        textStyle: {
          x: 0,
          y: 0,
          fontSize: 12,
          fill: "#333333",
          cursor: "pointer"
        },
        padding: [8, 10],
        style: {
          fill: "#f7f7f7",
          stroke: "#cccccc",
          cursor: "pointer"
        },
        activeStyle: {
          fill: "#e6e6e6"
        }
      };
      return _this;
    }
    ButtonAction3.prototype.getButtonCfg = function() {
      return deep_mix_default(this.buttonCfg, this.cfg);
    };
    ButtonAction3.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign({ text: config.text }, config.textStyle)
      });
      var textBBox = textShape.getBBox();
      var padding3 = parsePadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign({ x: textBBox.x - padding3[3], y: textBBox.y - padding3[0], width: textBBox.width + padding3[1] + padding3[3], height: textBBox.height + padding3[0] + padding3[2] }, config.style)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        buttonShape.attr(config.activeStyle);
      });
      group2.on("mouseleave", function() {
        buttonShape.attr(config.style);
      });
      this.buttonGroup = group2;
    };
    ButtonAction3.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord2 = view.getCoordinate();
      var point2 = coord2.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = ext_exports.transform(null, [
        ["t", point2.x - bbox.width - PADDING_RIGHT, point2.y + bbox.height + PADDING_TOP]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction3.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction3.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction3.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction3;
  }(base_default12)
);
var button_default = ButtonAction;

// node_modules/@antv/g2/esm/interaction/action/view/drag.js
var DISTANCE = 4;
var Drag = (
  /** @class */
  function(_super) {
    __extends(Drag2, _super);
    function Drag2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.dragStart = false;
      return _this;
    }
    Drag2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
    };
    Drag2.prototype.drag = function() {
      if (!this.startPoint) {
        return;
      }
      var current = this.context.getCurrentPoint();
      var view = this.context.view;
      var event = this.context.event;
      if (!this.dragStart) {
        if (distance6(current, this.startPoint) > DISTANCE) {
          view.emit("dragstart", {
            target: event.target,
            x: event.x,
            y: event.y
          });
          this.dragStart = true;
        }
      } else {
        view.emit("drag", {
          target: event.target,
          x: event.x,
          y: event.y
        });
      }
    };
    Drag2.prototype.end = function() {
      if (this.dragStart) {
        var view = this.context.view;
        var event_1 = this.context.event;
        view.emit("dragend", {
          target: event_1.target,
          x: event_1.x,
          y: event_1.y
        });
      }
      this.starting = false;
      this.dragStart = false;
    };
    return Drag2;
  }(base_default12)
);
var drag_default = Drag;

// node_modules/@antv/g2/esm/interaction/action/view/move.js
var MIN_DISTANCE = 5;
var Move = (
  /** @class */
  function(_super) {
    __extends(Move2, _super);
    function Move2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.isMoving = false;
      _this.startPoint = null;
      _this.startMatrix = null;
      return _this;
    }
    Move2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
      this.startMatrix = this.context.view.middleGroup.getMatrix();
    };
    Move2.prototype.move = function() {
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var currentPoint = this.context.getCurrentPoint();
      var d = distance6(startPoint, currentPoint);
      if (d > MIN_DISTANCE && !this.isMoving) {
        this.isMoving = true;
      }
      if (this.isMoving) {
        var view = this.context.view;
        var matrix = ext_exports.transform(this.startMatrix, [
          ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
        ]);
        view.backgroundGroup.setMatrix(matrix);
        view.foregroundGroup.setMatrix(matrix);
        view.middleGroup.setMatrix(matrix);
      }
    };
    Move2.prototype.end = function() {
      if (this.isMoving) {
        this.isMoving = false;
      }
      this.startMatrix = null;
      this.starting = false;
      this.startPoint = null;
    };
    Move2.prototype.reset = function() {
      this.starting = false;
      this.startPoint = null;
      this.isMoving = false;
      var view = this.context.view;
      view.backgroundGroup.resetMatrix();
      view.foregroundGroup.resetMatrix();
      view.middleGroup.resetMatrix();
      this.isMoving = false;
    };
    return Move2;
  }(base_default12)
);
var move_default = Move;

// node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js
var DIM_X = "x";
var DIM_Y = "y";
var ScaleTranslate = (
  /** @class */
  function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = [DIM_X, DIM_Y];
      _this.cfgFields = ["dims"];
      _this.cacheScaleDefs = {};
      return _this;
    }
    ScaleTranslate4.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    ScaleTranslate4.prototype.getScale = function(dim) {
      var view = this.context.view;
      if (dim === "x") {
        return view.getXScale();
      } else {
        return view.getYScales()[0];
      }
    };
    ScaleTranslate4.prototype.resetDim = function(dim) {
      var view = this.context.view;
      if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
        var scale8 = this.getScale(dim);
        view.scale(scale8.field, this.cacheScaleDefs[dim]);
        this.cacheScaleDefs[dim] = null;
      }
    };
    ScaleTranslate4.prototype.reset = function() {
      this.resetDim(DIM_X);
      this.resetDim(DIM_Y);
      var view = this.context.view;
      view.render(true);
    };
    return ScaleTranslate4;
  }(base_default12)
);
var scale_transform_default = ScaleTranslate;

// node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js
var ScaleTranslate2 = (
  /** @class */
  function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.starting = false;
      _this.startCache = {};
      return _this;
    }
    ScaleTranslate4.prototype.start = function() {
      var _this = this;
      this.startPoint = this.context.getCurrentPoint();
      this.starting = true;
      var dims = this.dims;
      each_default(dims, function(dim) {
        var scale8 = _this.getScale(dim);
        var min5 = scale8.min, max5 = scale8.max, values3 = scale8.values;
        _this.startCache[dim] = { min: min5, max: max5, values: values3 };
      });
    };
    ScaleTranslate4.prototype.end = function() {
      this.startPoint = null;
      this.starting = false;
      this.startCache = {};
    };
    ScaleTranslate4.prototype.translate = function() {
      var _this = this;
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var coord2 = this.context.view.getCoordinate();
      var currentPoint = this.context.getCurrentPoint();
      var normalStart = coord2.invert(startPoint);
      var noramlCurrent = coord2.invert(currentPoint);
      var dx = noramlCurrent.x - normalStart.x;
      var dy = noramlCurrent.y - normalStart.y;
      var view = this.context.view;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
      });
      view.render(true);
    };
    ScaleTranslate4.prototype.translateDim = function(dim, normalPoint) {
      if (this.hasDim(dim)) {
        var scale8 = this.getScale(dim);
        if (scale8.isLinear) {
          this.translateLinear(dim, scale8, normalPoint);
        }
      }
    };
    ScaleTranslate4.prototype.translateLinear = function(dim, scale8, normalPoint) {
      var view = this.context.view;
      var _a6 = this.startCache[dim], min5 = _a6.min, max5 = _a6.max;
      var range2 = max5 - min5;
      var d = normalPoint[dim] * range2;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          // @ts-ignore
          nice: scale8.nice,
          min: min5,
          max: max5
        };
      }
      view.scale(scale8.field, {
        // @ts-ignore
        nice: false,
        min: min5 + d,
        max: max5 + d
      });
    };
    ScaleTranslate4.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.startPoint = null;
      this.starting = false;
    };
    return ScaleTranslate4;
  }(scale_transform_default)
);
var scale_translate_default = ScaleTranslate2;

// node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js
var ScaleTranslate3 = (
  /** @class */
  function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.zoomRatio = 0.05;
      return _this;
    }
    ScaleTranslate4.prototype.zoomIn = function() {
      this.zoom(this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoom = function(scale8) {
      var _this = this;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.zoomDim(dim, scale8);
      });
      this.context.view.render(true);
    };
    ScaleTranslate4.prototype.zoomOut = function() {
      this.zoom(-1 * this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoomDim = function(dim, dRatio) {
      if (this.hasDim(dim)) {
        var scale8 = this.getScale(dim);
        if (scale8.isLinear) {
          this.zoomLinear(dim, scale8, dRatio);
        }
      }
    };
    ScaleTranslate4.prototype.zoomLinear = function(dim, scale8, dRatio) {
      var view = this.context.view;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          // @ts-ignore
          nice: scale8.nice,
          min: scale8.min,
          max: scale8.max
        };
      }
      var scaleDef = this.cacheScaleDefs[dim];
      var range2 = scaleDef.max - scaleDef.min;
      var min5 = scale8.min, max5 = scale8.max;
      var d = dRatio * range2;
      var toMin = min5 - d;
      var toMax = max5 + d;
      var curRange = toMax - toMin;
      var scaled = curRange / range2;
      if (toMax > toMin && scaled < 100 && scaled > 0.01) {
        view.scale(scale8.field, {
          // @ts-ignore
          nice: false,
          min: min5 - d,
          max: max5 + d
        });
      }
    };
    return ScaleTranslate4;
  }(scale_transform_default)
);
var scale_zoom_default = ScaleTranslate3;

// node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js
function isWheelDown(event) {
  var wheelEvent = event.gEvent.originalEvent;
  return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = (
  /** @class */
  function(_super) {
    __extends(MousewheelScroll2, _super);
    function MousewheelScroll2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MousewheelScroll2.prototype.scroll = function(arg) {
      var _a6 = this.context, view = _a6.view, event = _a6.event;
      if (!view.getOptions().scrollbar) {
        return;
      }
      var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
      var scrollbarController = view.getController("scrollbar");
      var xScale = view.getXScale();
      var data3 = view.getOptions().data;
      var dataSize = size(values_of_key_default(data3, xScale.field));
      var step = size(xScale.values);
      var currentRatio = scrollbarController.getValue();
      var currentStart = Math.floor((dataSize - step) * currentRatio);
      var nextStart = currentStart + (isWheelDown(event) ? wheelDelta : -wheelDelta);
      var correction = wheelDelta / (dataSize - step) / 1e4;
      var nextRatio = clamp_default(nextStart / (dataSize - step) + correction, 0, 1);
      scrollbarController.setValue(nextRatio);
    };
    return MousewheelScroll2;
  }(base_default12)
);
var mousewheel_scroll_default = MousewheelScroll;

// node_modules/@antv/g2/esm/interaction/action/component/axis/axis-description.js
var AXIS_DESCRIPTION_TOOLTIP = "aixs-description-tooltip";
var AxisDescription = (
  /** @class */
  function(_super) {
    __extends(AxisDescription2, _super);
    function AxisDescription2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisDescription2.prototype.show = function() {
      var context = this.context;
      var axis22 = getDelegationObject(context).axis;
      var _a6 = axis22.cfg.title, description = _a6.description, text = _a6.text, descriptionTooltipStyle = _a6.descriptionTooltipStyle;
      var _b = context.event, x = _b.x, y = _b.y;
      if (!this.tooltip) {
        this.renderTooltip();
      }
      this.tooltip.update({
        title: text || "",
        customContent: function() {
          return '\n          <div class="'.concat(css_const_exports2.CONTAINER_CLASS, '" style={').concat(descriptionTooltipStyle, '}>\n            <div class="').concat(css_const_exports2.TITLE_CLASS, '">\n              ').concat(description, "\n            </div>\n          </div>\n        ");
        },
        x,
        y
      });
      this.tooltip.show();
    };
    AxisDescription2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    AxisDescription2.prototype.hide = function() {
      this.tooltip && this.tooltip.hide();
    };
    AxisDescription2.prototype.renderTooltip = function() {
      var _a6;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var tooltip11 = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        containerId: AXIS_DESCRIPTION_TOOLTIP,
        domStyles: __assign({}, deep_mix_default({}, (_a6 = {}, // tooltip tip  50%
        _a6[css_const_exports2.CONTAINER_CLASS] = {
          "max-width": "50%",
          padding: "10px",
          "line-height": "15px",
          "font-size": "12px",
          color: "rgba(0, 0, 0, .65)"
        }, _a6[css_const_exports2.TITLE_CLASS] = {
          "word-break": "break-all",
          "margin-bottom": "3px"
        }, _a6)))
      });
      tooltip11.init();
      tooltip11.setCapture(false);
      this.tooltip = tooltip11;
    };
    return AxisDescription2;
  }(base_default12)
);
var axis_description_default = AxisDescription;

// node_modules/@antv/g2/esm/index.js
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", esm_exports2);
registerEngine("svg", esm_exports3);
registerGeometry("Polygon", polygon_default5);
registerGeometry("Interval", interval_default2);
registerGeometry("Schema", schema_default);
registerGeometry("Path", path_default5);
registerGeometry("Point", point_default);
registerGeometry("Line", line_default9);
registerGeometry("Area", area_default);
registerGeometry("Edge", edge_default);
registerGeometry("Heatmap", heatmap_default);
registerGeometry("Violin", violin_default);
registerGeometryLabel("base", base_default14);
registerGeometryLabel("interval", interval_default3);
registerGeometryLabel("pie", pie_default);
registerGeometryLabel("polar", polar_default2);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", rect_default4);
registerFacet("mirror", mirror_default);
registerFacet("list", list_default);
registerFacet("matrix", matrix_default);
registerFacet("circle", circle_default7);
registerFacet("tree", tree_default);
registerComponentController("axis", axis_default);
registerComponentController("legend", legend_default);
registerComponentController("tooltip", tooltip_default);
registerComponentController("annotation", annotation_default);
registerComponentController("slider", slider_default);
registerComponentController("scrollbar", scrollbar_default);
registerAction("tooltip", geometry_default);
registerAction("sibling-tooltip", sibling_default);
registerAction("ellipsis-text", ellipsis_text_default);
registerAction("element-active", active_default);
registerAction("element-single-active", single_active_default);
registerAction("element-range-active", range_active_default);
registerAction("element-highlight", highlight_default);
registerAction("element-highlight-by-x", highlight_by_x_default);
registerAction("element-highlight-by-color", highlight_by_color_default);
registerAction("element-single-highlight", single_highlight_default);
registerAction("element-range-highlight", range_highlight_default);
registerAction("element-sibling-highlight", range_highlight_default, {
  effectSiblings: true,
  effectByRecord: true
});
registerAction("element-selected", selected_default);
registerAction("element-single-selected", single_selected_default);
registerAction("element-range-selected", range_selected_default);
registerAction("element-link-by-color", link_by_color_default);
registerAction("active-region", active_region_default);
registerAction("list-active", list_active_default);
registerAction("list-selected", list_selected_default);
registerAction("list-highlight", list_highlight_default);
registerAction("list-unchecked", list_unchecked_default);
registerAction("list-checked", list_checked_default);
registerAction("list-focus", list_focus_default);
registerAction("list-radio", list_radio_default);
registerAction("legend-item-highlight", list_highlight_default, {
  componentNames: ["legend"]
});
registerAction("axis-label-highlight", list_highlight_default, {
  componentNames: ["axis"]
});
registerAction("axis-description", axis_description_default);
registerAction("rect-mask", rect_default5);
registerAction("x-rect-mask", dim_rect_default, { dim: "x" });
registerAction("y-rect-mask", dim_rect_default, { dim: "y" });
registerAction("circle-mask", circle_default8);
registerAction("path-mask", path_default6);
registerAction("smooth-path-mask", smooth_path_default);
registerAction("rect-multi-mask", rect_default6);
registerAction("x-rect-multi-mask", dim_rect_default2, { dim: "x" });
registerAction("y-rect-multi-mask", dim_rect_default2, { dim: "y" });
registerAction("circle-multi-mask", circle_default9);
registerAction("path-multi-mask", path_default7);
registerAction("smooth-path-multi-mask", smooth_path_default2);
registerAction("cursor", cursor_default);
registerAction("data-filter", filter_default2);
registerAction("brush", range_filter_default);
registerAction("brush-x", range_filter_default, { dims: ["x"] });
registerAction("brush-y", range_filter_default, { dims: ["y"] });
registerAction("sibling-filter", sibling_filter_default);
registerAction("sibling-x-filter", sibling_filter_default, { dims: "x" });
registerAction("sibling-y-filter", sibling_filter_default, { dims: "y" });
registerAction("element-filter", filter_default3);
registerAction("element-sibling-filter", sibling_filter_default2);
registerAction("element-sibling-filter-record", sibling_filter_default2, { byRecord: true });
registerAction("view-drag", drag_default);
registerAction("view-move", move_default);
registerAction("scale-translate", scale_translate_default);
registerAction("scale-zoom", scale_zoom_default);
registerAction("reset-button", button_default, {
  name: "reset-button",
  text: "reset"
});
registerAction("mousewheel-scroll", mousewheel_scroll_default);
function isPointInView(context) {
  return context.isInPlot();
}
registerInteraction("tooltip", {
  start: [
    { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
    { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
  ],
  end: [
    { trigger: "plot:mouseleave", action: "tooltip:hide" },
    { trigger: "plot:leave", action: "tooltip:hide" },
    { trigger: "plot:touchend", action: "tooltip:hide" }
  ]
});
registerInteraction("ellipsis-text", {
  start: [
    {
      trigger: "legend-item-name:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "legend-item-name:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    }
  ],
  end: [
    { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseout", action: "ellipsis-text:hide" },
    { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
  ]
});
registerInteraction("element-active", {
  start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
});
registerInteraction("element-selected", {
  start: [{ trigger: "element:click", action: "element-selected:toggle" }]
});
registerInteraction("element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
});
registerInteraction("element-highlight-by-x", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
});
registerInteraction("element-highlight-by-color", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
});
registerInteraction("legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
});
registerInteraction("legend-highlight", {
  start: [
    { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("axis-label-highlight", {
  start: [
    { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-list-highlight", {
  start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
  end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-range-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      isEnable: function(context) {
        return !context.isInShape("mask");
      },
      action: ["rect-mask:start", "rect-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["rect-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    {
      trigger: "mask:drag",
      action: ["rect-mask:move"]
    },
    {
      trigger: "mask:change",
      action: ["element-range-highlight:highlight"]
    }
  ],
  end: [
    { trigger: "plot:mouseup", action: ["rect-mask:end"] },
    { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
    {
      trigger: "document:mouseup",
      isEnable: function(context) {
        return !context.isInPlot();
      },
      action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
});
registerInteraction("brush", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView,
      action: ["brush:start", "rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView,
      action: ["rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView,
      action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
    }
  ],
  rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
});
registerInteraction("brush-visible", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      action: ["rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
  ],
  end: [
    {
      trigger: "plot:mouseup",
      action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
    }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["element-filter:clear"]
    }
  ]
});
registerInteraction("brush-x", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView,
      action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView,
      action: ["x-rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView,
      action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
});
registerInteraction("element-path-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:start" },
    { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:show" }
  ],
  processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
  end: [{ trigger: "mouseup", action: "path-mask:end" }],
  rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
});
registerInteraction("brush-x-multi", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView,
      action: ["x-rect-multi-mask:start", "x-rect-multi-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["x-rect-multi-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: function(context) {
        return !isMultipleMask(context);
      },
      action: ["x-rect-multi-mask:resize"]
    },
    {
      trigger: "multi-mask:change",
      action: "element-range-highlight:highlight"
    },
    {
      trigger: "mask:drag",
      action: ["x-rect-multi-mask:move"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      action: ["x-rect-multi-mask:end"]
    },
    { trigger: "mask:dragend", action: ["x-rect-multi-mask:moveEnd"] }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["x-rect-multi-mask:clear", "cursor:crosshair"]
    },
    {
      trigger: "multi-mask:clearAll",
      action: ["element-range-highlight:clear"]
    },
    {
      trigger: "multi-mask:clearSingle",
      action: ["element-range-highlight:highlight"]
    }
  ]
});
registerInteraction("element-single-selected", {
  start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
});
registerInteraction("legend-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: ["cursor:pointer", "list-radio:show"] },
    { trigger: "legend-item:mouseleave", action: ["cursor:default", "list-radio:hide"] }
  ],
  start: [
    {
      trigger: "legend-item:click",
      isEnable: function(context) {
        return !context.isInShape("legend-item-radio");
      },
      action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "data-filter:filter", "list-radio:show"]
    },
    //  :  radio === truthy  legend-item-radio 
    {
      trigger: "legend-item-radio:mouseenter",
      action: ["list-radio:showTip"]
    },
    {
      trigger: "legend-item-radio:mouseleave",
      action: ["list-radio:hideTip"]
    },
    {
      trigger: "legend-item-radio:click",
      action: ["list-focus:toggle", "data-filter:filter", "list-radio:show"]
    }
  ]
});
registerInteraction("continuous-filter", {
  start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
});
registerInteraction("continuous-visible-filter", {
  start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
});
registerInteraction("legend-visible-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "element-filter:filter"] }]
});
registerInteraction("active-region", {
  start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
  end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
});
registerInteraction("axis-description", {
  start: [{ trigger: "axis-description:mousemove", action: "axis-description:show" }],
  end: [{ trigger: "axis-description:mouseleave", action: "axis-description:hide" }]
});
function isWheelDown2(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", {
  start: [
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return isWheelDown2(context.event);
      },
      action: "scale-zoom:zoomOut",
      throttle: { wait: 100, leading: true, trailing: false }
    },
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return !isWheelDown2(context.event);
      },
      action: "scale-zoom:zoomIn",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ]
});
registerInteraction("sibling-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
});
registerInteraction("plot-mousewheel-scroll", {
  start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
});

// node_modules/@antv/g2plot/esm/constant.js
var AXIS_META_CONFIG_KEYS = [
  "type",
  "alias",
  "tickCount",
  "tickInterval",
  "min",
  "max",
  "nice",
  "minLimit",
  "maxLimit",
  // 
  "range",
  "tickMethod",
  // type: 'log' 
  "base",
  // type: 'exp' 
  "exponent",
  // time 
  "mask",
  // 
  "sync"
];

// node_modules/@antv/g2plot/esm/utils/invariant.js
var LEVEL;
(function(LEVEL2) {
  LEVEL2["ERROR"] = "error";
  LEVEL2["WARN"] = "warn";
  LEVEL2["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = "AntV/G2Plot";
function getMessage(format2) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return "".concat(BRAND, ": ").concat(format2.replace(/%s/g, function() {
    return "".concat(args[argIndex++]);
  }));
}
function log2(level, condition, format2) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, __spreadArray([format2], args, false)));
  }
}

// node_modules/@antv/g2plot/esm/utils/pick.js
function pick(obj, keys3) {
  var r = {};
  if (obj !== null && typeof obj === "object") {
    keys3.forEach(function(key) {
      var v = obj[key];
      if (v !== void 0) {
        r[key] = v;
      }
    });
  }
  return r;
}

// node_modules/@antv/g2plot/esm/utils/data.js
function adjustYMetaByZero(data3, field6) {
  if (!data3)
    return {};
  var numberData = data3.filter(function(datum) {
    var v = get_default(datum, [field6]);
    return is_number_default(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function(datum) {
    return get_default(datum, [field6]) >= 0;
  });
  var ltZero = numberData.every(function(datum) {
    return get_default(datum, [field6]) <= 0;
  });
  if (gtZero) {
    return { min: 0 };
  }
  if (ltZero) {
    return { max: 0 };
  }
  return {};
}
function transformDataToNodeLinkData(data3, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data3)) {
    return {
      nodes: [],
      links: []
    };
  }
  var links = [];
  var nodesMap = {};
  var nodesIndex = -1;
  data3.forEach(function(datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField];
    var rawData = pick(datum, rawFields);
    if (!nodesMap[source]) {
      nodesMap[source] = __assign({ id: ++nodesIndex, name: source }, rawData);
    }
    if (!nodesMap[target]) {
      nodesMap[target] = __assign({ id: ++nodesIndex, name: target }, rawData);
    }
    links.push(__assign({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      // sourceName: source,
      // targetName: target,
      value: weight
    }, rawData));
  });
  return {
    //  id 
    nodes: Object.values(nodesMap).sort(function(a, b) {
      return a.id - b.id;
    }),
    links
  };
}
function processIllegalData(data3, field6) {
  var processData2 = filter_default(data3, function(d) {
    var v = d[field6];
    return v === null || typeof v === "number" && !isNaN(v);
  });
  log2(LEVEL.WARN, processData2.length === data3.length, "illegal data existed in chart data.");
  return processData2;
}

// node_modules/@antv/g2plot/esm/utils/deep-assign.js
var MAX_MIX_LEVEL2 = 5;
var toString3 = {}.toString;
var isType2 = function(value2, type) {
  return toString3.call(value2) === "[object " + type + "]";
};
var isArray = function(value2) {
  return isType2(value2, "Array");
};
var isObjectLike2 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject2 = function(value2) {
  if (!isObjectLike2(value2) || !isType2(value2, "Object")) {
    return false;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var deep = function(dist3, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL2;
  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value2 = src[key];
      if (!value2) {
        dist3[key] = value2;
      } else {
        if (isPlainObject2(value2)) {
          if (!isPlainObject2(dist3[key])) {
            dist3[key] = {};
          }
          if (level < maxLevel) {
            deep(dist3[key], value2, level + 1, maxLevel);
          } else {
            dist3[key] = src[key];
          }
        } else if (isArray(value2)) {
          dist3[key] = [];
          dist3[key] = dist3[key].concat(value2);
        } else {
          dist3[key] = value2;
        }
      }
    }
  }
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};

// node_modules/@antv/g2plot/esm/utils/dom.js
function getContainerSize(ele) {
  if (!ele) {
    return { width: 0, height: 0 };
  }
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}

// node_modules/@antv/g2plot/esm/utils/flow.js
function flow() {
  var flows = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }
  return function(param) {
    return flows.reduce(function(result2, f) {
      return f(result2);
    }, param);
  };
}

// node_modules/@antv/g2plot/esm/utils/geometry.js
function findGeometry(view, type) {
  return view.geometries.find(function(g) {
    return g.type === type;
  });
}
function getAllElements(view) {
  return reduce_default(view.geometries, function(r, geometry35) {
    return r.concat(geometry35.elements);
  }, []);
}
function getAllElementsRecursively(view) {
  if (get_default(view, ["views", "length"], 0) <= 0) {
    return getAllElements(view);
  }
  return reduce_default(view.views, function(ele, subView) {
    return ele.concat(getAllElementsRecursively(subView));
  }, getAllElements(view));
}
function getAllGeometriesRecursively(view) {
  if (get_default(view, ["views", "length"], 0) <= 0) {
    return view.geometries;
  }
  return reduce_default(view.views, function(ele, subView) {
    return ele.concat(subView.geometries);
  }, view.geometries);
}

// node_modules/@antv/g2plot/esm/utils/kebab-case.js
function kebabCase(word2) {
  if (!word2) {
    return word2;
  }
  var result2 = word2.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result2.map(function(s) {
    return s.toLowerCase();
  }).join("-");
}

// node_modules/@antv/g2plot/esm/utils/label.js
function transformLabel(labelOptions) {
  if (!is_type_default(labelOptions, "Object")) {
    return labelOptions;
  }
  var label17 = __assign({}, labelOptions);
  if (label17.formatter && !label17.content) {
    label17.content = label17.formatter;
  }
  return label17;
}

// node_modules/@antv/g2plot/esm/utils/context.js
var ctx3;
function getCanvasContext2() {
  if (!ctx3) {
    ctx3 = document.createElement("canvas").getContext("2d");
  }
  return ctx3;
}

// node_modules/@antv/g2plot/esm/utils/measure-text.js
var measureTextWidth2 = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a6 = font.fontFamily, fontFamily = _a6 === void 0 ? "sans-serif" : _a6, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx4 = getCanvasContext2();
  ctx4.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  var metrics = ctx4.measureText(is_string_default(text) ? text : "");
  return metrics.width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray([text], values_default(font), true).join("");
});

// node_modules/@antv/g2plot/esm/utils/number.js
function isRealNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
function isBetween3(value2, start, end) {
  var min5 = Math.min(start, end);
  var max5 = Math.max(start, end);
  return value2 >= min5 && value2 <= max5;
}

// node_modules/@antv/g2plot/esm/utils/padding.js
function normalPadding(padding3) {
  if (is_number_default(padding3)) {
    return [padding3, padding3, padding3, padding3];
  }
  if (is_array_default(padding3)) {
    var length_1 = padding3.length;
    if (length_1 === 1) {
      return [padding3[0], padding3[0], padding3[0], padding3[0]];
    }
    if (length_1 === 2) {
      return [padding3[0], padding3[1], padding3[0], padding3[1]];
    }
    if (length_1 === 3) {
      return [padding3[0], padding3[1], padding3[2], padding3[1]];
    }
    if (length_1 === 4) {
      return padding3;
    }
  }
  return [0, 0, 0, 0];
}
function getAdjustAppendPadding(padding3, position, append) {
  if (position === void 0) {
    position = "bottom";
  }
  if (append === void 0) {
    append = 25;
  }
  var currentAppendPadding = normalPadding(padding3);
  var PADDING2 = [
    position.startsWith("top") ? append : 0,
    position.startsWith("right") ? append : 0,
    position.startsWith("bottom") ? append : 0,
    position.startsWith("left") ? append : 0
  ];
  return [
    currentAppendPadding[0] + PADDING2[0],
    currentAppendPadding[1] + PADDING2[1],
    currentAppendPadding[2] + PADDING2[2],
    currentAppendPadding[3] + PADDING2[3]
  ];
}
function resolveAllPadding(paddings) {
  var normalPaddings = paddings.map(function(item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function(item, index) {
      normalPaddings.forEach(function(d, i) {
        item += normalPaddings[i][index];
      });
      return item;
    });
  }
  return finalPadding;
}

// node_modules/@antv/g2plot/esm/utils/path.js
function points2Path(points2, isInCircle) {
  var path = [];
  if (points2.length) {
    path.push(["M", points2[0].x, points2[0].y]);
    for (var i = 1, length_1 = points2.length; i < length_1; i += 1) {
      var item = points2[i];
      path.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path.push(["Z"]);
    }
  }
  return path;
}
var smoothBezier3 = function(points2, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min5;
  var max5;
  if (hasConstraint) {
    min5 = [Infinity, Infinity];
    max5 = [-Infinity, -Infinity];
    for (var i = 0, l = points2.length; i < l; i++) {
      var point2 = points2[i];
      min5 = vec2_exports.min([0, 0], min5, point2);
      max5 = vec2_exports.max([0, 0], max5, point2);
    }
    min5 = vec2_exports.min([0, 0], min5, constraint[0]);
    max5 = vec2_exports.max([0, 0], max5, constraint[1]);
  }
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var point2 = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len3 - 1];
      nextPoint = points2[(i + 1) % len3];
    } else {
      if (i === 0 || i === len3 - 1) {
        cps.push(point2);
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    var v = [0, 0];
    v = vec2_exports.sub(v, nextPoint, prevPoint);
    v = vec2_exports.scale(v, v, smooth);
    var d0 = vec2_exports.distance(point2, prevPoint);
    var d1 = vec2_exports.distance(point2, nextPoint);
    var sum2 = d0 + d1;
    if (sum2 !== 0) {
      d0 /= sum2;
      d1 /= sum2;
    }
    var v1 = vec2_exports.scale([0, 0], v, -d0);
    var v2 = vec2_exports.scale([0, 0], v, d1);
    var cp0 = vec2_exports.add([0, 0], point2, v1);
    var cp1 = vec2_exports.add([0, 0], point2, v2);
    if (hasConstraint) {
      cp0 = vec2_exports.max([0, 0], cp0, min5);
      cp0 = vec2_exports.min([0, 0], cp0, max5);
      cp1 = vec2_exports.max([0, 0], cp1, min5);
      cp1 = vec2_exports.min([0, 0], cp1, max5);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier2(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier3(pointList, 0.4, isLoop, constraint);
  var len3 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len3 - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len3];
    cp2 = controlPointList[len3 + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getSplinePath2(points2, isInCircle, constaint) {
  var data3 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return points2Path(points2, isInCircle);
  }
  for (var i = 0, len3 = points2.length; i < len3; i++) {
    var point2 = points2[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data3.push(point2.x);
      data3.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    // 
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier2(data3, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}

// node_modules/@antv/g2plot/esm/utils/statistic.js
function adapteStyle(style) {
  var styleObject = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  };
  var shapeStyleKeys = [
    "stroke",
    "lineWidth",
    "shadowColor",
    "strokeOpacity",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "fill"
  ];
  if (get_default(style, "fill")) {
    styleObject["color"] = style["fill"];
  }
  var _a6 = pick(style, shapeStyleKeys), shadowColor = _a6.shadowColor, _b = _a6.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a6.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a6.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject["text-shadow"] = "".concat([shadowColor, "".concat(shadowOffsetX, "px"), "".concat(shadowOffsetY, "px"), "".concat(shadowBlur, "px")].join(" "));
  var _e = pick(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
  styleObject["-webkit-text-stroke"] = "".concat(["".concat(lineWidth, "px"), stroke].join(" "));
  each_default(style, function(v, k) {
    if (["fontSize"].includes(k) && is_number_default(v)) {
      styleObject[kebabCase(k)] = "".concat(v, "px");
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[kebabCase(k)] = "".concat(v);
    }
  });
  return styleObject;
}
function setStatisticContainerStyle(container, style) {
  container.style["pointer-events"] = "none";
  each_default(style, function(v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
var renderStatistic = function(chart, options, datum) {
  var statistic4 = options.statistic, plotType = options.plotType;
  var titleOpt = statistic4.title, contentOpt = statistic4.content;
  [titleOpt, contentOpt].forEach(function(option, idx) {
    if (!option) {
      return;
    }
    var transform9 = "";
    if (idx === 0) {
      transform9 = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
    } else {
      transform9 = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
    }
    var style = is_function_default(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign(
      {
        position: ["50%", "50%"],
        html: function(container, view) {
          var coordinate11 = view.getCoordinate();
          var containerW = 0;
          if (plotType === "pie" || plotType === "ring-progress") {
            containerW = coordinate11.getRadius() * coordinate11.innerRadius * 2;
          } else if (plotType === "liquid") {
            var liquidShape = get_default(view.geometries, [0, "elements", 0, "shape"]);
            if (liquidShape) {
              var path = liquidShape.find(function(t) {
                return t.get("name") === "wrap";
              });
              var width = path.getCanvasBBox().width;
              containerW = width;
            }
          } else if (!containerW) {
            containerW = coordinate11.getWidth();
          }
          setStatisticContainerStyle(container, __assign({ width: "".concat(containerW, "px"), transform: transform9 }, adapteStyle(style)));
          var filteredData = view.getData();
          if (option.customHtml) {
            return option.customHtml(container, view, datum, filteredData);
          }
          var text = option.content;
          if (option.formatter) {
            text = option.formatter(datum, filteredData);
          }
          return text ? is_string_default(text) ? text : "".concat(text) : "<div></div>";
        },
        // @ts-ignore
        key: "".concat(idx === 0 ? "top" : "bottom", "-statistic")
      },
      pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
      /**  */
    ));
  });
};
var renderGaugeStatistic = function(chart, options, datum) {
  var statistic4 = options.statistic;
  var titleOpt = statistic4.title, contentOpt = statistic4.content;
  [titleOpt, contentOpt].forEach(function(option) {
    if (!option) {
      return;
    }
    var style = is_function_default(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign(
      { position: ["50%", "100%"], html: function(container, view) {
        var coordinate11 = view.getCoordinate();
        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate11.y.start - parseFloat(get_default(style, "fontSize", 0));
        var containerWidth = coordinate11.getRadius() * coordinate11.innerRadius * 2;
        setStatisticContainerStyle(container, __assign({ width: "".concat(containerWidth, "px"), transform: "translate(-50%, ".concat(offsetY, "px)") }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text = option.content;
        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        }
        return text ? is_string_default(text) ? text : "".concat(text) : "<div></div>";
      } },
      pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
      /**  */
    ));
  });
};

// node_modules/@antv/g2plot/esm/utils/template.js
function template(source, data3) {
  if (!data3) {
    return source;
  }
  return reduce_default(
    // @ts-ignore
    data3,
    function(r, v, k) {
      return r.replace(new RegExp("{\\s*".concat(k, "\\s*}"), "g"), v);
    },
    source
  );
}

// node_modules/@antv/g2plot/esm/utils/view.js
function findViewById(chart, id) {
  return chart.views.find(function(view) {
    return view.id === id;
  });
}
function getViews(view) {
  var parent2 = view.parent;
  return parent2 ? parent2.views : [];
}
function getSiblingViews(view) {
  return getViews(view).filter(function(sub4) {
    return sub4 !== view;
  });
}
function addViewAnimation(view, animation7, geometries) {
  if (geometries === void 0) {
    geometries = view.geometries;
  }
  if (typeof animation7 === "boolean") {
    view.animate(animation7);
  } else {
    view.animate(true);
  }
  each_default(geometries, function(g) {
    var animationCfg;
    if (is_function_default(animation7)) {
      animationCfg = animation7(g.type || g.shapeType, g) || true;
    } else {
      animationCfg = animation7;
    }
    g.animate(animationCfg);
  });
}

// node_modules/@antv/g2plot/esm/utils/pattern/util.js
function getPixelRatio2() {
  return typeof window === "object" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement("canvas");
  var pixelRatio = getPixelRatio2();
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  canvas.style.width = "".concat(width, "px");
  canvas.style.height = "".concat(height, "px");
  var ctx4 = canvas.getContext("2d");
  ctx4.scale(pixelRatio, pixelRatio);
  return canvas;
}
function drawBackground(context, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor, opacity = cfg.opacity;
  context.globalAlpha = opacity;
  context.fillStyle = backgroundColor;
  context.beginPath();
  context.fillRect(0, 0, width, height);
  context.closePath();
}
function getUnitPatternSize(size3, padding3, isStagger) {
  var unitSize = size3 + padding3;
  return isStagger ? unitSize * 2 : unitSize;
}
function getSymbolsPosition(unitSize, isStagger) {
  var symbolsPos = isStagger ? [
    [unitSize * (1 / 4), unitSize * (1 / 4)],
    [unitSize * (3 / 4), unitSize * (3 / 4)]
  ] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}

// node_modules/@antv/g2plot/esm/utils/pattern/dot.js
var defaultDotPatternCfg = {
  size: 6,
  padding: 2,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0,
  isStagger: true
};
function drawDot(context, cfg, x, y) {
  var size3 = cfg.size, fill2 = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
  context.beginPath();
  context.globalAlpha = fillOpacity;
  context.fillStyle = fill2;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.arc(x, y, size3 / 2, 0, 2 * Math.PI, false);
  context.fill();
  if (lineWidth) {
    context.stroke();
  }
  context.closePath();
}
function createDotPattern(cfg) {
  var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
  var size3 = dotCfg.size, padding3 = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
  var unitSize = getUnitPatternSize(size3, padding3, isStagger);
  var dots = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx4 = canvas.getContext("2d");
  drawBackground(ctx4, dotCfg, unitSize);
  for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
    var _a6 = dots_1[_i], x = _a6[0], y = _a6[1];
    drawDot(ctx4, dotCfg, x, y);
  }
  var pattern2 = ctx4.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio2();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}

// node_modules/@antv/g2plot/esm/utils/pattern/line.js
var defaultLinePatternCfg = {
  rotation: 45,
  spacing: 5,
  opacity: 1,
  backgroundColor: "transparent",
  strokeOpacity: 0.5,
  stroke: "#fff",
  lineWidth: 2
};
function drawLine(context, cfg, d) {
  var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
  var path = new Path2D(d);
  context.globalAlpha = strokeOpacity;
  context.lineCap = "square";
  context.strokeStyle = lineWidth ? stroke : "transparent";
  context.lineWidth = lineWidth;
  context.stroke(path);
}
function createLinePattern(cfg) {
  var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
  var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
  var width = spacing + lineWidth || 1;
  var height = spacing + lineWidth || 1;
  var d = "\n            M 0 0 L ".concat(width, " 0\n            M 0 ").concat(height, " L ").concat(width, " ").concat(height, "\n            ");
  var canvas = initCanvas(width, height);
  var ctx4 = canvas.getContext("2d");
  drawBackground(ctx4, lineCfg, width, height);
  drawLine(ctx4, lineCfg, d);
  var pattern2 = ctx4.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio2();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}

// node_modules/@antv/g2plot/esm/utils/pattern/square.js
var defaultSquarePatternCfg = {
  size: 6,
  padding: 1,
  isStagger: true,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0
};
function drawSquare(context, cfg, x, y) {
  var stroke = cfg.stroke, size3 = cfg.size, fill2 = cfg.fill, lineWidth = cfg.lineWidth, fillOpacity = cfg.fillOpacity;
  context.globalAlpha = fillOpacity;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.fillStyle = fill2;
  context.strokeRect(x - size3 / 2, y - size3 / 2, size3, size3);
  context.fillRect(x - size3 / 2, y - size3 / 2, size3, size3);
}
function createSquarePattern(cfg) {
  var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
  var size3 = squareCfg.size, padding3 = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
  var unitSize = getUnitPatternSize(size3, padding3, isStagger);
  var squares = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx4 = canvas.getContext("2d");
  drawBackground(ctx4, squareCfg, unitSize);
  for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
    var _a6 = squares_1[_i], x = _a6[0], y = _a6[1];
    drawSquare(ctx4, squareCfg, x, y);
  }
  var pattern2 = ctx4.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio2();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}

// node_modules/@antv/g2plot/esm/utils/pattern/index.js
function getCanvasPattern(options) {
  var type = options.type, cfg = options.cfg;
  var pattern2;
  switch (type) {
    case "dot":
      pattern2 = createDotPattern(cfg);
      break;
    case "line":
      pattern2 = createLinePattern(cfg);
      break;
    case "square":
      pattern2 = createSquarePattern(cfg);
      break;
    default:
      break;
  }
  return pattern2;
}

// node_modules/@antv/g2plot/esm/adaptor/pattern.js
function pattern(key) {
  var _this = this;
  return function(params) {
    var _a6;
    var options = params.options, chart = params.chart;
    var patternOption = options.pattern;
    if (!patternOption) {
      return params;
    }
    var style = function(datum) {
      var _a7, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color3 = defaultColor;
      var colorAttribute = (_b = (_a7 = chart.geometries) === null || _a7 === void 0 ? void 0 : _a7[0]) === null || _b === void 0 ? void 0 : _b.getAttribute("color");
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = get_default(datum, colorField);
        color3 = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern2 = patternOption;
      if (typeof patternOption === "function") {
        pattern2 = patternOption.call(_this, datum, color3);
      }
      if (pattern2 instanceof CanvasPattern === false) {
        pattern2 = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color3 } }, pattern2));
      }
      var styleOption = options[key];
      return __assign(__assign({}, typeof styleOption === "function" ? styleOption.call.apply(styleOption, __spreadArray([_this, datum], args, false)) : styleOption || {}), { fill: pattern2 || color3 });
    };
    return deepAssign({}, params, { options: (_a6 = {}, _a6[key] = style, _a6) });
  };
}

// node_modules/@antv/g2plot/esm/adaptor/common.js
function legend(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, colorField = options.colorField, seriesField = options.seriesField;
  if (legend18 === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend18);
  }
  return params;
}
function tooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11 !== void 0) {
    chart.tooltip(tooltip11);
  }
  return params;
}
function interaction(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions;
  each_default(interactions, function(i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function animation(params) {
  var chart = params.chart, options = params.options;
  var animation7 = options.animation;
  addViewAnimation(chart, animation7);
  return params;
}
function theme(params) {
  var chart = params.chart, options = params.options;
  var theme4 = options.theme;
  if (theme4) {
    chart.theme(theme4);
  }
  return params;
}
function state(params) {
  var chart = params.chart, options = params.options;
  var state2 = options.state;
  if (state2) {
    each_default(chart.geometries, function(geometry35) {
      geometry35.state(state2);
    });
  }
  return params;
}
function slider(params) {
  var chart = params.chart, options = params.options;
  var slider4 = options.slider;
  chart.option("slider", slider4);
  return params;
}
function scrollbar(params) {
  var chart = params.chart, options = params.options;
  var scrollbar2 = options.scrollbar;
  chart.option("scrollbar", scrollbar2);
  return params;
}
function scale5(axes, meta23) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var scales = {};
    each_default(axes, function(axis22, field6) {
      scales[field6] = pick(axis22, AXIS_META_CONFIG_KEYS);
    });
    scales = deepAssign({}, meta23, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
function annotation(annotationOptions) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var annotationController = chart.getController("annotation");
    each_default(__spreadArray(__spreadArray([], options.annotations || [], true), annotationOptions || [], true), function(annotationOption) {
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
function limitInPlot2(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis, limitInPlot5 = options.limitInPlot;
  var value2 = limitInPlot5;
  if (is_object_default(yAxis) && is_nil_default(limitInPlot5)) {
    if (Object.values(pick(yAxis, ["min", "max", "minLimit", "maxLimit"])).some(function(value3) {
      return !is_nil_default(value3);
    })) {
      value2 = true;
    } else {
      value2 = false;
    }
  }
  chart.limitInPlot = value2;
  return params;
}
function transformations(coordinateType) {
  if (coordinateType === void 0) {
    coordinateType = "rect";
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var coordinate11 = options.coordinate;
    var actions = Array.from(coordinate11 || []).map(function(cfg) {
      if (cfg.type === "reflectX")
        return ["reflect", "x"];
      if (cfg.type === "reflectY")
        return ["reflect", "y"];
      if (cfg.type === "transpose")
        return ["transpose"];
      return null;
    }).filter(function(d) {
      return !!d;
    });
    if (actions.length !== 0) {
      chart.coordinate({ type: coordinateType, actions });
    }
    return params;
  };
}

// node_modules/@antv/g2plot/esm/core/global.js
var GLOBAL = {
  /**  */
  locale: "en-US"
};
function setGlobal(datum) {
  each_default(datum, function(v, k) {
    return GLOBAL[k] = v;
  });
}

// node_modules/@antv/g2plot/esm/core/locale.js
var LocaleMap = {};
function registerLocale(locale, localeObj) {
  LocaleMap[locale] = localeObj;
}
function getLocale(locale) {
  return {
    get: function(key, obj) {
      return template(get_default(LocaleMap[locale], key) || get_default(LocaleMap[GLOBAL.locale], key) || get_default(LocaleMap["en-US"], key) || key, obj);
    }
  };
}

// node_modules/@antv/g2plot/esm/locales/en_US.js
var EN_US_LOCALE = {
  locale: "en-US",
  // General
  general: {
    increase: "Increase",
    decrease: "Decrease",
    root: "Root"
  },
  // Plot Components
  /** statistic text component */
  statistic: {
    total: "Total"
  },
  /** conversionTag component */
  conversionTag: {
    label: "Rate"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  // Plots
  waterfall: {
    total: "Total"
  }
};

// node_modules/@antv/g2plot/esm/locales/zh_CN.js
var ZH_CN_LOCALE = {
  locale: "zh-CN",
  // 
  general: {
    increase: "",
    decrease: "",
    root: ""
  },
  // 
  /**  */
  statistic: {
    total: ""
  },
  /**  */
  conversionTag: {
    label: ""
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  // 
  waterfall: {
    total: ""
  }
};

// node_modules/@antv/g2plot/esm/utils/tooltip.js
function getTooltipMapping(tooltip11, defaultFields) {
  if (tooltip11 === false) {
    return {
      fields: false
      //  tooltip
    };
  }
  var fields = get_default(tooltip11, "fields");
  var formatter = get_default(tooltip11, "formatter");
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields,
    formatter
  };
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/base.js
function getMappingField(o, field6) {
  var type = o.type, xField = o.xField, yField = o.yField, colorField = o.colorField, shapeField = o.shapeField, sizeField = o.sizeField, styleField = o.styleField;
  var rawFields = o.rawFields;
  var fields = [];
  rawFields = (is_function_default(rawFields) ? rawFields(type, field6) : rawFields) || [];
  if (field6 === "color") {
    fields = __spreadArray([colorField || xField], rawFields, true);
  } else if (field6 === "shape") {
    fields = __spreadArray([shapeField || xField], rawFields, true);
  } else if (field6 === "size") {
    fields = __spreadArray([sizeField || xField], rawFields, true);
  } else {
    fields = __spreadArray([xField, yField, colorField, shapeField, sizeField, styleField], rawFields, true);
    var idx = ["x", "y", "color", "shape", "size", "style"].indexOf(field6);
    var f = fields[idx];
    fields.splice(idx, 1);
    fields.unshift(f);
  }
  var mappingFields = uniq(fields.filter(function(f2) {
    return !!f2;
  }));
  var tileMappingField = type === "line" && [xField, yField].includes(mappingFields.join("*")) ? "" : mappingFields.join("*");
  return {
    mappingFields,
    tileMappingField
  };
}
function getMappingFunction(mappingFields, func) {
  if (!func)
    return void 0;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function(f, idx) {
      params[f] = args[idx];
    });
    delete params["undefined"];
    return func(params);
  };
}
function geometry(params) {
  var chart = params.chart, options = params.options;
  var type = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label17 = options.label, state2 = options.state, customInfo = options.customInfo;
  if (!mapping) {
    return params;
  }
  var color3 = mapping.color, shape = mapping.shape, size3 = mapping.size, style = mapping.style, tooltip11 = mapping.tooltip;
  var geometry35 = chart[type](args).position("".concat(xField, "*").concat(yField));
  if (is_string_default(color3)) {
    colorField ? geometry35.color(colorField, color3) : geometry35.color(color3);
  } else if (is_function_default(color3)) {
    var _a6 = getMappingField(options, "color"), mappingFields = _a6.mappingFields, tileMappingField = _a6.tileMappingField;
    geometry35.color(tileMappingField, getMappingFunction(mappingFields, color3));
  } else {
    colorField && geometry35.color(colorField, color3);
  }
  if (is_string_default(shape)) {
    shapeField ? geometry35.shape(shapeField, [shape]) : geometry35.shape(shape);
  } else if (is_function_default(shape)) {
    var _b = getMappingField(options, "shape"), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
    geometry35.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry35.shape(shapeField, shape);
  }
  if (is_number_default(size3)) {
    sizeField ? geometry35.size(sizeField, size3) : geometry35.size(size3);
  } else if (is_function_default(size3)) {
    var _c = getMappingField(options, "size"), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
    geometry35.size(tileMappingField, getMappingFunction(mappingFields, size3));
  } else {
    sizeField && geometry35.size(sizeField, size3);
  }
  if (is_function_default(style)) {
    var _d = getMappingField(options, "style"), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
    geometry35.style(tileMappingField, getMappingFunction(mappingFields, style));
  } else if (is_object_default(style)) {
    geometry35.style(style);
  }
  if (tooltipFields === false) {
    geometry35.tooltip(false);
  } else if (!is_empty_default(tooltipFields)) {
    geometry35.tooltip(tooltipFields.join("*"), getMappingFunction(tooltipFields, tooltip11));
  }
  if (label17 === false) {
    geometry35.label(false);
  } else if (label17) {
    var callback = label17.callback, fields = label17.fields, cfg = __rest(label17, ["callback", "fields"]);
    geometry35.label({
      fields: fields || [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  if (state2) {
    geometry35.state(state2);
  }
  if (customInfo) {
    geometry35.customInfo(customInfo);
  }
  [xField, yField].filter(function(f) {
    return f !== colorField;
  }).forEach(function(f) {
    chart.legend(f, false);
  });
  return __assign(__assign({}, params), {
    // geometry adaptor  geometry  adaptor type 
    ext: { geometry: geometry35 }
  });
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/area.js
function area(params) {
  var options = params.options;
  var area2 = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  return area2 ? geometry(deepAssign({}, params, {
    options: {
      type: "area",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deep_mix_default({
        shape: smooth ? "smooth" : "area",
        tooltip: formatter
      }, area2),
      args: { useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/edge.js
function edge(params) {
  var options = params.options;
  var edge2 = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  return edge2 ? geometry(deepAssign({}, params, {
    options: {
      type: "edge",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, edge2),
      args: { useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/interval.js
function otherAdaptor(params) {
  var chart = params.chart, options = params.options, ext = params.ext;
  var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme4 = options.theme;
  var adjust3 = [];
  if (seriesField) {
    if (isGroup) {
      adjust3.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        marginRatio
      });
    }
    if (isStack) {
      adjust3.push({
        type: "stack",
        marginRatio
      });
    }
  }
  if (adjust3.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g.adjust(adjust3);
  }
  if (!is_nil_default(widthRatio)) {
    chart.theme(deepAssign({}, is_object_default(theme4) ? theme4 : getTheme(theme4), {
      // columWidthRatio  theme 
      columnWidthRatio: widthRatio
    }));
  }
  return params;
}
function interval2(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, interval3 = options.interval, seriesField = options.seriesField, tooltip11 = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  var ext = (interval3 ? geometry(deepAssign({}, params, {
    options: {
      type: "interval",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, interval3),
      args: {
        dodgePadding,
        intervalPadding,
        minColumnWidth,
        maxColumnWidth,
        background: columnBackground,
        useDeferredLabel
      }
    }
  })) : params).ext;
  return otherAdaptor(__assign(__assign({}, params), { ext }));
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/line.js
function line(params) {
  var options = params.options;
  var line2 = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  return line2 ? geometry(deepAssign({}, params, {
    options: {
      type: "line",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deep_mix_default({
        shape: stepType || (smooth ? "smooth" : "line"),
        tooltip: formatter
      }, line2),
      args: { connectNulls, useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/point.js
function point(params) {
  var options = params.options;
  var point2 = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField, sizeField, shapeField]), fields = _a6.fields, formatter = _a6.formatter;
  return point2 ? geometry(deepAssign({}, params, {
    options: {
      type: "point",
      colorField: seriesField,
      shapeField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, point2),
      args: { useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/polygon.js
function polygon(params) {
  var options = params.options;
  var polygon2 = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  return polygon2 ? geometry(deepAssign({}, params, {
    options: {
      type: "polygon",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, polygon2),
      args: { useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/schema.js
function schema(params) {
  var options = params.options;
  var schema2 = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip11 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField]), fields = _a6.fields, formatter = _a6.formatter;
  return schema2 ? geometry(deepAssign({}, params, {
    options: {
      type: "schema",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, schema2),
      args: { useDeferredLabel }
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/adaptor/geometries/violin.js
function violin(params) {
  var options = params.options;
  var violin2 = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip11 = options.tooltip;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, seriesField, sizeField]), fields = _a6.fields, formatter = _a6.formatter;
  return violin2 ? geometry(deepAssign({}, params, {
    options: {
      type: "violin",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign({ tooltip: formatter }, violin2)
    }
  })) : params;
}

// node_modules/@antv/g2plot/esm/core/plot.js
var import_size_sensor = __toESM(require_lib());
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var PLOT_CONTAINER_OPTIONS = [
  "padding",
  "appendPadding",
  "renderer",
  "pixelRatio",
  "syncViewPadding",
  "supportCSSTransform",
  "limitInPlot"
];
var Plot = (
  /** @class */
  function(_super) {
    __extends(Plot2, _super);
    function Plot2(container, options) {
      var _this = _super.call(this) || this;
      _this.container = typeof container === "string" ? document.getElementById(container) : container;
      _this.options = deepAssign({}, _this.getDefaultOptions(), options);
      _this.createG2();
      _this.bindEvents();
      return _this;
    }
    Plot2.getDefaultOptions = function() {
      return {
        renderer: "canvas",
        xAxis: {
          nice: true,
          label: {
            autoRotate: false,
            autoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        },
        yAxis: {
          nice: true,
          label: {
            autoHide: true,
            autoRotate: false
          }
        },
        animation: true
      };
    };
    Plot2.prototype.createG2 = function() {
      var _a6 = this.options, width = _a6.width, height = _a6.height, defaultInteractions = _a6.defaultInteractions;
      this.chart = new chart_default(__assign(__assign(__assign(__assign({ container: this.container, autoFit: false }, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions }));
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "G2Plot");
    };
    Plot2.prototype.getChartSize = function(width, height) {
      var chartSize = getContainerSize(this.container);
      return { width: width || chartSize.width || 400, height: height || chartSize.height || 400 };
    };
    Plot2.prototype.bindEvents = function() {
      var _this = this;
      if (this.chart) {
        this.chart.on("*", function(e) {
          if (e === null || e === void 0 ? void 0 : e.type) {
            _this.emit(e.type, e);
          }
        });
      }
    };
    Plot2.prototype.getDefaultOptions = function() {
      return Plot2.getDefaultOptions();
    };
    Plot2.prototype.render = function() {
      this.chart.clear();
      this.chart.options = {
        data: [],
        animate: true
      };
      this.chart.views = [];
      this.execAdaptor();
      this.chart.render();
      this.bindSizeSensor();
    };
    Plot2.prototype.update = function(options) {
      this.updateOption(options);
      this.render();
    };
    Plot2.prototype.updateOption = function(options) {
      this.options = deepAssign({}, this.options, options);
    };
    Plot2.prototype.setState = function(type, condition, status) {
      if (status === void 0) {
        status = true;
      }
      var elements = getAllElementsRecursively(this.chart);
      each_default(elements, function(ele) {
        if (condition(ele.getData())) {
          ele.setState(type, status);
        }
      });
    };
    Plot2.prototype.getStates = function() {
      var elements = getAllElementsRecursively(this.chart);
      var stateObjects = [];
      each_default(elements, function(element) {
        var data3 = element.getData();
        var states = element.getStates();
        each_default(states, function(state2) {
          stateObjects.push({ data: data3, state: state2, geometry: element.geometry, element });
        });
      });
      return stateObjects;
    };
    Plot2.prototype.changeData = function(data3) {
      this.update({ data: data3 });
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.addAnnotations = function(annotations, view) {
      view = view ? view : this.chart;
      var incoming = __spreadArray([], annotations, true);
      var controller = view.getController("annotation");
      var current = controller.getComponents().map(function(co) {
        return co.extra;
      });
      controller.clear(true);
      var _loop_1 = function(i2) {
        var annotation4 = current[i2];
        var findIndex3 = incoming.findIndex(function(item) {
          return item.id && item.id === annotation4.id;
        });
        if (findIndex3 !== -1) {
          annotation4 = deepAssign({}, annotation4, incoming[findIndex3]);
          incoming.splice(findIndex3, 1);
        }
        controller.annotation(annotation4);
      };
      for (var i = 0; i < current.length; i++) {
        _loop_1(i);
      }
      incoming.forEach(function(annotation4) {
        return controller.annotation(annotation4);
      });
      view.render(true);
    };
    Plot2.prototype.removeAnnotations = function(annotations) {
      var controller = this.chart.getController("annotation");
      var current = controller.getComponents().map(function(co) {
        return co.extra;
      });
      controller.clear(true);
      var _loop_2 = function(i2) {
        var annotation4 = current[i2];
        if (!annotations.find(function(item) {
          return item.id && item.id === annotation4.id;
        })) {
          controller.annotation(annotation4);
        }
      };
      for (var i = 0; i < current.length; i++) {
        _loop_2(i);
      }
      this.chart.render(true);
    };
    Plot2.prototype.destroy = function() {
      this.unbindSizeSensor();
      this.chart.destroy();
      this.off();
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor36 = this.getSchemaAdaptor();
      var _a6 = this.options, padding3 = _a6.padding, appendPadding = _a6.appendPadding;
      this.chart.padding = padding3;
      this.chart.appendPadding = appendPadding;
      adaptor36({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this = this;
      if (this.unbind) {
        return;
      }
      var _a6 = this.options.autoFit, autoFit = _a6 === void 0 ? true : _a6;
      if (autoFit) {
        this.unbind = (0, import_size_sensor.bind)(this.container, function() {
          var _a7 = getContainerSize(_this.container), width = _a7.width, height = _a7.height;
          if (width !== _this.chart.width || height !== _this.chart.height) {
            _this.triggerResize();
          }
        });
      }
    };
    Plot2.prototype.unbindSizeSensor = function() {
      if (this.unbind) {
        this.unbind();
        this.unbind = void 0;
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@antv/g2plot/esm/utils/transform/percent.js
function percent(data3, measure, groupField, as) {
  var sumMap = reduce_default(data3, function(map5, datum) {
    var groupValue = datum[groupField];
    var sum2 = map5.has(groupValue) ? map5.get(groupValue) : 0;
    var v = datum[measure];
    sum2 = isRealNumber(v) ? sum2 + v : sum2;
    map5.set(groupValue, sum2);
    return map5;
  }, /* @__PURE__ */ new Map());
  return map_default(data3, function(datum) {
    var _a6;
    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
    return __assign(__assign({}, datum), (_a6 = {}, _a6[as] = percentage, _a6));
  });
}
function getDeepPercent(data3, measure, fields, percent2) {
  var sumMap = reduce_default(data3, function(map5, datum) {
    var groupValue = reduce_default(fields, function(value2, field6) {
      return "".concat(value2).concat(datum[field6]);
    }, "");
    var sum2 = map5.has(groupValue) ? map5.get(groupValue) : 0;
    var v = datum[measure];
    sum2 = isRealNumber(v) ? sum2 + v : sum2;
    map5.set(groupValue, sum2);
    return map5;
  }, /* @__PURE__ */ new Map());
  return map_default(data3, function(datum) {
    var _a6;
    var v = datum[measure];
    var groupValue = reduce_default(fields, function(value2, field6) {
      return "".concat(value2).concat(datum[field6]);
    }, "");
    var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
    return __assign(__assign({}, datum), (_a6 = {}, _a6[percent2] = percentage, _a6));
  });
}
function getDataWhetherPercentage(data3, yField, groupField, asField, isPercent) {
  return !isPercent ? data3 : percent(data3, yField, groupField, asField);
}

// node_modules/@antv/g2plot/esm/plots/line/adaptor.js
function geometry2(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, color3 = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var areaState = areaMapping === null || areaMapping === void 0 ? void 0 : areaMapping.state;
  chart.data(data3);
  var primary = deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color3,
        style: lineStyle,
        shape: lineShape
      },
      //  tooltip 
      // 
      point: pointMapping && __assign({ color: color3, shape: "circle" }, pointMapping),
      // 
      area: areaMapping && __assign({ color: color3 }, areaMapping),
      // label  geometry adaptor label adaptor 
      label: void 0
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  var areaParams = deepAssign({}, primary, { options: { tooltip: false, state: areaState } });
  line(primary);
  point(second);
  area(areaParams);
  return params;
}
function meta(params) {
  var _a6, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data3 = options.data;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = adjustYMetaByZero(data3, yField), _b)))(params);
}
function coordinate(params) {
  var chart = params.chart, options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p = reflect;
    if (!is_array_default(p)) {
      p = [p];
    }
    var actions = p.map(function(d) {
      return ["reflect", d];
    });
    chart.coordinate({ type: "rect", actions });
  }
  return params;
}
function axis(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend2(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, seriesField = options.seriesField;
  if (legend18 && seriesField) {
    chart.legend(seriesField, legend18);
  } else if (legend18 === false) {
    chart.legend(false);
  }
  return params;
}
function label(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField;
  var lineGeometry = findGeometry(chart, "line");
  if (!label17) {
    lineGeometry.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    each_default(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor(params) {
  return flow(geometry2, meta, adjust, theme, coordinate, axis, legend2, tooltip, label, slider, scrollbar, interaction, animation, annotation(), limitInPlot2)(params);
}

// node_modules/@antv/g2plot/esm/plots/area/adaptor.js
function geometry3(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, areaStyle = options.areaStyle, areaShape = options.areaShape, color3 = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip11 = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var chartData = getDataWhetherPercentage(data3, yField, xField, yField, isPercent);
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
    return {
      name: datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip11) : tooltip11;
  var primary = deepAssign({}, params, {
    options: {
      area: {
        color: color3,
        style: areaStyle,
        shape: areaShape
      },
      point: pointMapping && __assign({ color: color3 }, pointMapping),
      tooltip: tooltipOptions,
      // label  geometry adaptor label adaptor 
      label: void 0,
      args: {
        startOnZero
      }
    }
  });
  var lineParams = {
    chart,
    options: deepAssign({ line: { size: 2 } }, omit_default(options, ["state"]), {
      //  tooltip 
      // 
      line: lineMapping && __assign({ color: color3 }, lineMapping),
      sizeField: seriesField,
      state: lineMapping === null || lineMapping === void 0 ? void 0 : lineMapping.state,
      tooltip: false,
      // label  geometry adaptor label adaptor 
      label: void 0,
      args: {
        startOnZero
      }
    })
  };
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(lineParams);
  point(pointParams);
  return params;
}
function label2(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField;
  var areaGeometry = findGeometry(chart, "area");
  if (!label17) {
    areaGeometry.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust2(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
  if ((isPercent || isStack) && seriesField) {
    each_default(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor2(params) {
  return flow(theme, pattern("areaStyle"), transformations("rect"), geometry3, meta, adjust2, axis, legend2, tooltip, label2, slider, annotation(), interaction, animation, limitInPlot2)(params);
}

// node_modules/@antv/g2plot/esm/plots/area/constants.js
var DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  isStack: true,
  // 
  line: {},
  legend: {
    position: "top-left",
    radio: {}
  }
});

// node_modules/@antv/g2plot/esm/plots/area/index.js
var Area2 = (
  /** @class */
  function(_super) {
    __extends(Area3, _super);
    function Area3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "area";
      return _this;
    }
    Area3.getDefaultOptions = function() {
      return DEFAULT_OPTIONS;
    };
    Area3.prototype.getDefaultOptions = function() {
      return Area3.getDefaultOptions();
    };
    Area3.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this.options, isPercent = _a6.isPercent, xField = _a6.xField, yField = _a6.yField;
      var _b = this, chart = _b.chart, options = _b.options;
      meta({ chart, options });
      this.chart.changeData(getDataWhetherPercentage(data3, yField, xField, yField, isPercent));
    };
    Area3.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area3;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/interactions/actions/reset-button.js
var PADDING_RIGHT2 = 10;
var PADDING_TOP2 = 5;
var BUTTON_ACTION_CONFIG = {
  padding: [8, 10],
  text: "reset",
  textStyle: {
    default: {
      x: 0,
      y: 0,
      fontSize: 12,
      fill: "#333333",
      cursor: "pointer"
    }
  },
  buttonStyle: {
    default: {
      fill: "#f7f7f7",
      stroke: "#cccccc",
      cursor: "pointer"
    },
    active: {
      fill: "#e6e6e6"
    }
  }
};
var ButtonAction2 = (
  /** @class */
  function(_super) {
    __extends(ButtonAction3, _super);
    function ButtonAction3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = __assign({ name: "button" }, BUTTON_ACTION_CONFIG);
      return _this;
    }
    ButtonAction3.prototype.getButtonCfg = function() {
      var view = this.context.view;
      var buttonCfg = get_default(view, ["interactions", "filter-action", "cfg", "buttonConfig"]);
      return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
    };
    ButtonAction3.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = this.drawText(group2);
      this.drawBackground(group2, textShape.getBBox());
      this.buttonGroup = group2;
    };
    ButtonAction3.prototype.drawText = function(group2) {
      var _a6;
      var config = this.getButtonCfg();
      return group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign({ text: config.text }, (_a6 = config.textStyle) === null || _a6 === void 0 ? void 0 : _a6.default)
      });
    };
    ButtonAction3.prototype.drawBackground = function(group2, bbox) {
      var _a6;
      var config = this.getButtonCfg();
      var padding3 = normalPadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign({ x: bbox.x - padding3[3], y: bbox.y - padding3[0], width: bbox.width + padding3[1] + padding3[3], height: bbox.height + padding3[0] + padding3[2] }, (_a6 = config.buttonStyle) === null || _a6 === void 0 ? void 0 : _a6.default)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        var _a7;
        buttonShape.attr((_a7 = config.buttonStyle) === null || _a7 === void 0 ? void 0 : _a7.active);
      });
      group2.on("mouseleave", function() {
        var _a7;
        buttonShape.attr((_a7 = config.buttonStyle) === null || _a7 === void 0 ? void 0 : _a7.default);
      });
      return buttonShape;
    };
    ButtonAction3.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord2 = view.getCoordinate();
      var point2 = coord2.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = Util.transform(null, [
        ["t", point2.x - bbox.width - PADDING_RIGHT2, point2.y + bbox.height + PADDING_TOP2]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction3.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction3.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction3.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction3;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/interactions/brush.js
registerAction("brush-reset-button", ButtonAction2, {
  name: "brush-reset-button"
});
registerInteraction("filter-action", {});
function isPointInView2(context) {
  return context.isInPlot();
}
function getInteractionCfg(interactionType, brushType, options) {
  var _a6 = options || {}, mask = _a6.mask, isStartEnable = _a6.isStartEnable;
  var maskType = brushType || "rect";
  switch (interactionType) {
    case "brush":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView2,
            action: ["brush:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView2,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView2,
            action: [
              "brush:filter",
              "brush:end",
              "".concat(maskType, "-mask:end"),
              "".concat(maskType, "-mask:hide"),
              "brush-reset-button:show"
            ]
          }
        ],
        rollback: [
          {
            trigger: "brush-reset-button:click",
            action: ["brush:reset", "brush-reset-button:hide", "cursor:crosshair"]
          }
        ]
      };
    case "brush-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mousemove", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          {
            trigger: "plot:mousemove",
            action: "cursor:default",
            isEnable: function(context) {
              return isStartEnable ? !isStartEnable(context) : false;
            }
          },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    case "brush-x":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView2,
            action: ["brush-x:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView2,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView2,
            action: ["brush-x:filter", "brush-x:end", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
      };
    case "brush-x-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    case "brush-y":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView2,
            action: ["brush-y:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView2,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView2,
            action: ["brush-y:filter", "brush-y:end", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-y:reset"] }]
      };
    case "brush-y-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    default:
      return {};
  }
}
registerInteraction("brush", getInteractionCfg("brush"));
registerInteraction("brush-highlight", getInteractionCfg("brush-highlight"));
registerInteraction("brush-x", getInteractionCfg("brush-x", "x-rect"));
registerInteraction("brush-y", getInteractionCfg("brush-y", "y-rect"));
registerInteraction("brush-x-highlight", getInteractionCfg("brush-x-highlight", "x-rect"));
registerInteraction("brush-y-highlight", getInteractionCfg("brush-y-highlight", "y-rect"));

// node_modules/@antv/g2plot/esm/adaptor/brush.js
var BRUSH_TYPES = ["brush", "brush-x", "brush-y", "brush-highlight", "brush-x-highlight", "brush-y-highlight"];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  var interactions = filter_default(options.interactions || [], function(i) {
    return BRUSH_TYPES.indexOf(i.type) === -1;
  });
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function(type) {
      var enable = false;
      switch (brush.type) {
        case "x-rect":
          enable = type === (brush.action === "highlight" ? "brush-x-highlight" : "brush-x");
          break;
        case "y-rect":
          enable = type === (brush.action === "highlight" ? "brush-y-highlight" : "brush-y");
          break;
        default:
          enable = type === (brush.action === "highlight" ? "brush-highlight" : "brush");
          break;
      }
      var obj = { type, enable };
      if (brush) {
        obj.cfg = getInteractionCfg(type, brush.type, brush);
      }
      interactions.push(obj);
    });
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== "highlight") {
      interactions.push({
        type: "filter-action",
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return deepAssign({}, params, { options: { interactions } });
}

// node_modules/@antv/g2plot/esm/adaptor/connected-area.js
var INTERACTION_MAP = {
  hover: "__interval-connected-area-hover__",
  click: "__interval-connected-area-click__"
};
var getStartStages = function(trigger, style) {
  if (trigger === "hover") {
    return [
      {
        trigger: "interval:mouseenter",
        action: ["element-highlight-by-color:highlight", "element-link-by-color:link"],
        arg: [null, { style }]
      }
    ];
  }
  return [
    {
      trigger: "interval:click",
      action: [
        "element-highlight-by-color:clear",
        "element-highlight-by-color:highlight",
        "element-link-by-color:clear",
        "element-link-by-color:unlink",
        "element-link-by-color:link"
      ],
      arg: [null, null, null, null, { style }]
    }
  ];
};
registerInteraction(INTERACTION_MAP.hover, {
  start: getStartStages(INTERACTION_MAP.hover),
  end: [
    {
      trigger: "interval:mouseleave",
      action: ["element-highlight-by-color:reset", "element-link-by-color:unlink"]
    }
  ]
});
registerInteraction(INTERACTION_MAP.click, {
  start: getStartStages(INTERACTION_MAP.click),
  end: [
    {
      trigger: "document:mousedown",
      action: ["element-highlight-by-color:clear", "element-link-by-color:clear"]
    }
  ]
});
function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var connectedArea2 = options.connectedArea;
    var clear = function() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };
    if (!disable && connectedArea2) {
      var trigger = connectedArea2.trigger || "hover";
      clear();
      chart.interaction(INTERACTION_MAP[trigger], {
        start: getStartStages(trigger, connectedArea2.style)
      });
    } else {
      clear();
    }
    return params;
  };
}

// node_modules/@antv/g2plot/esm/utils/conversion.js
function conversionTagFormatter(prev, next) {
  if (!is_number_default(prev) || !is_number_default(next)) {
    return "-";
  }
  if (prev === 0 && next === 0) {
    return "-";
  }
  if (prev === next) {
    return "100%";
  }
  if (prev === 0) {
    return "";
  }
  return "".concat((100 * next / prev).toFixed(2), "%");
}

// node_modules/@antv/g2plot/esm/adaptor/conversion-tag.js
function getConversionTagOptionsWithDefaults(options, horizontal) {
  return deepAssign({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: "rgba(0, 0, 0, 0.05)"
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.85)",
        textAlign: "center",
        textBaseline: "middle"
      },
      formatter: conversionTagFormatter
    }
  }, options);
}
function parsePoints(coordinate11, element) {
  return map_default(element.getModel().points, function(point2) {
    return coordinate11.convertPoint(point2);
  });
}
function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view, geometry35 = config.geometry, group2 = config.group, options = config.options, horizontal = config.horizontal;
  var offset = options.offset, size3 = options.size, arrow = options.arrow;
  var coordinate11 = view.getCoordinate();
  var pointPrev = parsePoints(coordinate11, elemPrev)[3];
  var pointNext = parsePoints(coordinate11, elemNext)[0];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;
  if (typeof arrow === "boolean") {
    return;
  }
  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points2;
  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size3],
        [pointNext.x - spacing, pointNext.y - offset - size3 / 2]
      ];
    } else {
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size3],
        [pointNext.x - spacing - headSize, pointNext.y - offset - size3],
        [pointNext.x - spacing, pointNext.y - offset - size3 / 2],
        [pointNext.x - spacing - headSize, pointNext.y - offset]
      ];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points2 = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size3, pointPrev.y + spacing],
        [pointNext.x + offset + size3 / 2, pointNext.y - spacing]
      ];
    } else {
      points2 = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size3, pointPrev.y + spacing],
        [pointNext.x + offset + size3, pointNext.y - spacing - headSize],
        [pointNext.x + offset + size3 / 2, pointNext.y - spacing],
        [pointNext.x + offset, pointNext.y - spacing - headSize]
      ];
    }
  }
  group2.addShape("polygon", {
    id: "".concat(view.id, "-conversion-tag-arrow-").concat(geometry35.getElementId(elemPrev.getModel().mappingData)),
    name: "conversion-tag-arrow",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign(__assign({}, arrow.style || {}), { points: points2 })
  });
}
function renderTextTag(config, elemPrev, elemNext) {
  var _a6, _b, _c;
  var view = config.view, geometry35 = config.geometry, group2 = config.group, options = config.options, field6 = config.field, horizontal = config.horizontal;
  var offset = options.offset, size3 = options.size;
  if (typeof options.text === "boolean") {
    return;
  }
  var coordinate11 = view.getCoordinate();
  var text = ((_a6 = options.text) === null || _a6 === void 0 ? void 0 : _a6.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field6], elemNext.getData()[field6]));
  var pointPrev = parsePoints(coordinate11, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate11, elemNext)[horizontal ? 0 : 3];
  var textShape = group2.addShape("text", {
    id: "".concat(view.id, "-conversion-tag-text-").concat(geometry35.getElementId(elemPrev.getModel().mappingData)),
    name: "conversion-tag-text",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign(__assign({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), { text, x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size3 / 2, y: horizontal ? pointPrev.y - offset - size3 / 2 : (pointPrev.y + pointNext.y) / 2 })
  });
  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;
    if (textWidth > totalWidth) {
      var cWidth = textWidth / text.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = "".concat(text.slice(0, cEnd), "...");
      textShape.attr("text", textAdjusted);
    }
  }
}
function renderTag2(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
function conversionTag(field6, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }
  if (disabled === void 0) {
    disabled = false;
  }
  return function(params) {
    var options = params.options, chart = params.chart;
    var conversionTag5 = options.conversionTag, theme4 = options.theme;
    if (conversionTag5 && !disabled) {
      chart.theme(deepAssign({}, is_object_default(theme4) ? theme4 : getTheme(theme4), {
        columnWidthRatio: 1 / 3
      }));
      chart.annotation().shape({
        render: function(container, view) {
          var group2 = container.addGroup({
            id: "".concat(chart.id, "-conversion-tag-group"),
            name: "conversion-tag-group"
          });
          var interval3 = find_default(chart.geometries, function(geom) {
            return geom.type === "interval";
          });
          var config = {
            view,
            geometry: interval3,
            group: group2,
            field: field6,
            horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag5, horizontal)
          };
          var elements = interval3.elements;
          each_default(elements, function(elem, idx) {
            if (idx > 0) {
              renderTag2(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }
    return params;
  };
}

// node_modules/@antv/g2plot/esm/plots/column/adaptor.js
function defaultOptions(params) {
  var options = params.options;
  var legend18 = options.legend;
  var seriesField = options.seriesField, isStack = options.isStack;
  if (seriesField) {
    if (legend18 !== false) {
      legend18 = __assign({ position: isStack ? "right-top" : "top-left" }, legend18);
    }
  } else {
    legend18 = false;
  }
  params.options.legend = legend18;
  return params;
}
function geometry4(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, columnStyle = options.columnStyle, color3 = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip11 = options.tooltip, shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? getDeepPercent(data3, yField, [xField, groupField], yField) : getDataWhetherPercentage(data3, yField, xField, yField, isPercent);
  var chartData = [];
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function(item) {
      var stackedItem = chartData.find(function(v) {
        return v[xField] === item[xField] && v[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push(__assign({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
    var _a6;
    return {
      name: isGroup && isStack ? "".concat(datum[seriesField], " - ").concat(datum[groupField]) : (_a6 = datum[seriesField]) !== null && _a6 !== void 0 ? _a6 : datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip11) : tooltip11;
  var p = deepAssign({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape,
        style: columnStyle,
        color: color3
      }
    }
  });
  interval2(p);
  return p;
}
function meta2(params) {
  var _a6, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data3 = options.data, isPercent = options.isPercent;
  var percentYMeta = isPercent ? { max: 1, min: 0, minLimit: 0, maxLimit: 1 } : {};
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = __assign(__assign({}, adjustYMetaByZero(data3, yField)), percentYMeta), _b)))(params);
}
function axis2(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend3(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, seriesField = options.seriesField;
  if (legend18 && seriesField) {
    chart.legend(seriesField, legend18);
  } else if (legend18 === false) {
    chart.legend(false);
  }
  return params;
}
function label3(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField, isRange = options.isRange;
  var geometry35 = findGeometry(chart, "interval");
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: [yField],
      callback,
      cfg: __assign({
        //  label layout  layout  position  layout
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? void 0 : [
          { type: "interval-adjust-position" },
          { type: "interval-hide-overlap" },
          { type: "adjust-color" },
          { type: "limit-in-plot", cfg: { action: "hide" } }
        ]
      }, transformLabel(isRange ? __assign({ content: function(item) {
        var _a6;
        return (_a6 = item[yField]) === null || _a6 === void 0 ? void 0 : _a6.join("-");
      } }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data3 = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
  if (tooltip11 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip11;
    if (isGroup && isStack) {
      var customItems_1 = tooltipOptions.customItems;
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function(datum) {
        return { name: "".concat(datum[seriesField], " - ").concat(datum[groupField]), value: datum[yField] };
      };
      tooltipOptions = __assign(__assign({}, tooltipOptions), { customItems: function(originalItems) {
        var items = [];
        each_default(originalItems, function(item) {
          var datas = filter_default(data3, function(d) {
            return is_match_default(d, pick(item.data, [xField, seriesField]));
          });
          datas.forEach(function(datum) {
            items.push(__assign(__assign(__assign({}, item), { value: datum[yField], data: datum, mappingData: { _origin: datum } }), tooltipFormatter_1(datum)));
          });
        });
        return customItems_1 ? customItems_1(items) : items;
      } });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor3(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return flow(
    defaultOptions,
    // 
    theme,
    // theme  geometry 
    pattern("columnStyle"),
    state,
    transformations("rect"),
    geometry4,
    meta2,
    axis2,
    legend3,
    columnTooltip,
    slider,
    scrollbar,
    label3,
    brushInteraction,
    interaction,
    animation,
    annotation(),
    conversionTag(options.yField, !isBar, !!seriesField),
    // 
    connectedArea(!options.isStack),
    limitInPlot2
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/bar/adaptor.js
function defaultOptions2(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  var position = {
    left: "bottom",
    right: "top",
    top: "left",
    bottom: "right"
  };
  var verticalAxis = yAxis !== false ? __assign({ position: position[(yAxis === null || yAxis === void 0 ? void 0 : yAxis.position) || "left"] }, yAxis) : false;
  var horizontalAxis = xAxis !== false ? __assign({ position: position[(xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) || "bottom"] }, xAxis) : false;
  return __assign(__assign({}, params), { options: __assign(__assign({}, options), {
    xField: yField,
    yField: xField,
    //  xAxisyAxis  deepAssign
    xAxis: verticalAxis,
    yAxis: horizontalAxis
  }) });
}
function label4(params) {
  var options = params.options;
  var label17 = options.label;
  if (label17 && !label17.position) {
    label17.position = "left";
    if (!label17.layout) {
      label17.layout = [
        { type: "interval-adjust-position" },
        { type: "interval-hide-overlap" },
        { type: "adjust-color" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ];
    }
  }
  return deepAssign({}, params, { options: { label: label17 } });
}
function legend4(params) {
  var options = params.options;
  var seriesField = options.seriesField, isStack = options.isStack;
  var legend18 = options.legend;
  if (seriesField) {
    if (legend18 !== false) {
      legend18 = __assign({ position: isStack ? "top-left" : "right-top" }, legend18 || {});
    }
  } else {
    legend18 = false;
  }
  return deepAssign({}, params, { options: { legend: legend18 } });
}
function coordinate2(params) {
  var options = params.options;
  var coordinateOptions = [{ type: "transpose" }, { type: "reflectY" }].concat(options.coordinate || []);
  return deepAssign({}, params, { options: { coordinate: coordinateOptions } });
}
function geometry5(params) {
  var chart = params.chart, options = params.options;
  var barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth, barBackground = options.barBackground;
  return adaptor3({
    chart,
    options: __assign(__assign({}, options), {
      // rename attrs as column
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: barBackground
    })
  }, true);
}
function adaptor4(params) {
  return flow(defaultOptions2, label4, legend4, tooltip, coordinate2, geometry5)(params);
}

// node_modules/@antv/g2plot/esm/plots/bar/constants.js
var DEFAULT_OPTIONS2 = deepAssign({}, Plot.getDefaultOptions(), {
  barWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});

// node_modules/@antv/g2plot/esm/plots/bar/index.js
var Bar = (
  /** @class */
  function(_super) {
    __extends(Bar2, _super);
    function Bar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bar";
      return _this;
    }
    Bar2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS2;
    };
    Bar2.prototype.changeData = function(data3) {
      var _a6, _b;
      this.updateOption({ data: data3 });
      var _c = this, chart = _c.chart, options = _c.options;
      var isPercent = options.isPercent;
      var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
      _a6 = [yField, xField], xField = _a6[0], yField = _a6[1];
      _b = [yAxis, xAxis], xAxis = _b[0], yAxis = _b[1];
      var switchedFieldOptions = __assign(__assign({}, options), { xField, yField, yAxis, xAxis });
      meta2({ chart, options: switchedFieldOptions });
      chart.changeData(getDataWhetherPercentage(data3, xField, yField, xField, isPercent));
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/column/constants.js
var DEFAULT_OPTIONS3 = deepAssign({}, Plot.getDefaultOptions(), {
  columnWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});

// node_modules/@antv/g2plot/esm/plots/column/index.js
var Column = (
  /** @class */
  function(_super) {
    __extends(Column2, _super);
    function Column2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Column2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS3;
    };
    Column2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this.options, yField = _a6.yField, xField = _a6.xField, isPercent = _a6.isPercent;
      var _b = this, chart = _b.chart, options = _b.options;
      meta2({ chart, options });
      this.chart.changeData(getDataWhetherPercentage(data3, yField, xField, yField, isPercent));
    };
    Column2.prototype.getDefaultOptions = function() {
      return Column2.getDefaultOptions();
    };
    Column2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/funnel/constant.js
var _a3;
var FUNNEL_PERCENT = "$$percentage$$";
var FUNNEL_MAPPING_VALUE = "$$mappingValue$$";
var FUNNEL_CONVERSATION = "$$conversion$$";
var FUNNEL_TOTAL_PERCENT = "$$totalPercentage$$";
var PLOYGON_X = "$$x$$";
var PLOYGON_Y = "$$y$$";
var DEFAULT_OPTIONS4 = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a3 = {}, _a3[FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a3),
  label: {
    style: {
      fill: "#fff",
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.45)"
    }
  }
};

// node_modules/@antv/g2plot/esm/plots/funnel/geometries/common.js
var CONVERSION_TAG_NAME = "CONVERSION_TAG_NAME";
function transformData(data3, originData, options) {
  var formatData = [];
  var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var maxYFieldValue = get_default(max_by_default(originData, yField), [yField]);
  var max5 = is_number_default(maxSize) ? maxSize : 1;
  var min5 = is_number_default(minSize) ? minSize : 0;
  formatData = map_default(data3, function(row, index) {
    var percent2 = (row[yField] || 0) / maxYFieldValue;
    row[FUNNEL_PERCENT] = percent2;
    row[FUNNEL_MAPPING_VALUE] = (max5 - min5) * percent2 + min5;
    row[FUNNEL_CONVERSATION] = [get_default(data3, [index - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
function conversionTagComponent(getLineCoordinate) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var conversionTag5 = options.conversionTag, filteredData = options.filteredData;
    var data3 = filteredData || chart.getOptions().data;
    if (conversionTag5) {
      var formatter_1 = conversionTag5.formatter;
      data3.forEach(function(obj, index) {
        if (index <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE]))
          return;
        var lineOption = getLineCoordinate(obj, index, data3, {
          top: true,
          name: CONVERSION_TAG_NAME,
          text: {
            content: is_function_default(formatter_1) ? formatter_1(obj, data3) : formatter_1,
            offsetX: conversionTag5.offsetX,
            offsetY: conversionTag5.offsetY,
            position: "end",
            autoRotate: false,
            style: __assign({ textAlign: "start", textBaseline: "middle" }, conversionTag5.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}

// node_modules/@antv/g2plot/esm/plots/funnel/geometries/basic.js
function field(params) {
  var chart = params.chart, options = params.options;
  var _a6 = options.data, data3 = _a6 === void 0 ? [] : _a6, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var formatData = transformData(data3, data3, {
    yField,
    maxSize,
    minSize
  });
  chart.data(formatData);
  return params;
}
function geometry6(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color3 = options.color, tooltip11 = options.tooltip, label17 = options.label, _a6 = options.shape, shape = _a6 === void 0 ? "funnel" : _a6, funnelStyle = options.funnelStyle, state2 = options.state;
  var _b = getTooltipMapping(tooltip11, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
  geometry({
    chart,
    options: {
      type: "interval",
      xField,
      yField: FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      mapping: {
        shape,
        tooltip: formatter,
        color: color3,
        style: funnelStyle
      },
      label: label17,
      state: state2
    }
  });
  var geo = findGeometry(params.chart, "interval");
  geo.adjust("symmetric");
  return params;
}
function transpose2(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: !isTransposed ? [["transpose"], ["scale", 1, -1]] : []
  });
  return params;
}
function conversionTag2(params) {
  var options = params.options, chart = params.chart;
  var maxSize = options.maxSize;
  var dataArray = get_default(chart, ["geometries", "0", "dataArray"], []);
  var size3 = get_default(chart, ["options", "data", "length"]);
  var x = map_default(dataArray, function(item) {
    return get_default(item, ["0", "nextPoints", "0", "x"]) * size3 - 0.5;
  });
  var getLineCoordinate = function(datum, datumIndex, data3, initLineOption) {
    var percent2 = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
    return __assign(__assign({}, initLineOption), { start: [x[datumIndex - 1] || datumIndex - 0.5, percent2], end: [x[datumIndex - 1] || datumIndex - 0.5, percent2 + 0.05] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function basicFunnel(params) {
  return flow(field, geometry6, transpose2, conversionTag2)(params);
}

// node_modules/@antv/g2plot/esm/plots/funnel/geometries/compare.js
function field2(params) {
  var _a6;
  var chart = params.chart, options = params.options;
  var _b = options.data, data3 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data3);
  chart.scale((_a6 = {}, _a6[yField] = {
    sync: true
  }, _a6));
  return params;
}
function geometry7(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, xField = options.xField, yField = options.yField, color3 = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip11 = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label17 = options.label, funnelStyle = options.funnelStyle, state2 = options.state, showFacetTitle = options.showFacetTitle;
  chart.facet("mirror", {
    fields: [compareField],
    // 
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      var index = isTransposed ? facet.rowIndex : facet.columnIndex;
      if (!isTransposed) {
        view.coordinate({
          type: "rect",
          actions: [["transpose"], ["scale", index === 0 ? -1 : 1, -1]]
        });
      }
      var formatterData = transformData(facet.data, data3, {
        yField,
        maxSize,
        minSize
      });
      view.data(formatterData);
      var _a6 = getTooltipMapping(tooltip11, [xField, yField, compareField]), fields = _a6.fields, formatter = _a6.formatter;
      var defaultFacetLabel = isTransposed ? {
        offset: index === 0 ? 10 : -23,
        position: index === 0 ? "bottom" : "top"
      } : {
        offset: 10,
        position: "left",
        style: {
          textAlign: index === 0 ? "end" : "start"
        }
      };
      geometry({
        chart: view,
        options: {
          type: "interval",
          xField,
          yField: FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
          mapping: {
            // todo   shape
            shape: "funnel",
            tooltip: formatter,
            color: color3,
            style: funnelStyle
          },
          label: label17 === false ? false : deepAssign({}, defaultFacetLabel, label17),
          state: state2
        }
      });
    }
  });
  return params;
}
function compareConversionTag(params) {
  var chart = params.chart, index = params.index, options = params.options;
  var conversionTag5 = options.conversionTag, isTransposed = options.isTransposed;
  (is_number_default(index) ? [chart] : chart.views).forEach(function(view, viewIndex) {
    var dataArray = get_default(view, ["geometries", "0", "dataArray"], []);
    var size3 = get_default(view, ["options", "data", "length"]);
    var x = map_default(dataArray, function(item) {
      return get_default(item, ["0", "nextPoints", "0", "x"]) * size3 - 0.5;
    });
    var getLineCoordinate = function(datum, datumIndex, data3, initLineOption) {
      var ratio = (index || viewIndex) === 0 ? -1 : 1;
      return deepAssign({}, initLineOption, {
        start: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE]],
        end: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE] + 0.05],
        text: isTransposed ? {
          style: {
            textAlign: "start"
          }
        } : {
          offsetX: conversionTag5 !== false ? ratio * conversionTag5.offsetX : 0,
          style: {
            textAlign: (index || viewIndex) === 0 ? "end" : "start"
          }
        }
      });
    };
    conversionTagComponent(getLineCoordinate)(deepAssign({}, {
      chart: view,
      options
    }));
  });
}
function conversionTag3(params) {
  var chart = params.chart;
  chart.once("beforepaint", function() {
    return compareConversionTag(params);
  });
  return params;
}
function compareFunnel(params) {
  return flow(field2, geometry7, conversionTag3)(params);
}

// node_modules/@antv/g2plot/esm/plots/funnel/geometries/dynamic-height.js
function field3(params) {
  var chart = params.chart, options = params.options;
  var _a6 = options.data, data3 = _a6 === void 0 ? [] : _a6, yField = options.yField;
  var sum2 = reduce_default(data3, function(total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max5 = max_by_default(data3, yField)[yField];
  var formatData = map_default(data3, function(row, index) {
    var x = [];
    var y = [];
    row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum2;
    if (index) {
      var preItemX = data3[index - 1][PLOYGON_X];
      var preItemY = data3[index - 1][PLOYGON_Y];
      x[0] = preItemX[3];
      y[0] = preItemY[3];
      x[1] = preItemX[2];
      y[1] = preItemY[2];
    } else {
      x[0] = -0.5;
      y[0] = 1;
      x[1] = 0.5;
      y[1] = 1;
    }
    y[2] = y[1] - row[FUNNEL_TOTAL_PERCENT];
    x[2] = (y[2] + 1) / 4;
    y[3] = y[2];
    x[3] = -x[2];
    row[PLOYGON_X] = x;
    row[PLOYGON_Y] = y;
    row[FUNNEL_PERCENT] = (row[yField] || 0) / max5;
    row[FUNNEL_CONVERSATION] = [get_default(data3, [index - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
function geometry8(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color3 = options.color, tooltip11 = options.tooltip, label17 = options.label, funnelStyle = options.funnelStyle, state2 = options.state;
  var _a6 = getTooltipMapping(tooltip11, [xField, yField]), fields = _a6.fields, formatter = _a6.formatter;
  geometry({
    chart,
    options: {
      type: "polygon",
      xField: PLOYGON_X,
      yField: PLOYGON_Y,
      colorField: xField,
      tooltipFields: is_array_default(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      label: label17,
      state: state2,
      mapping: {
        tooltip: formatter,
        color: color3,
        style: funnelStyle
      }
    }
  });
  return params;
}
function transpose3(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: isTransposed ? [["transpose"], ["reflect", "x"]] : []
  });
  return params;
}
function conversionTag4(params) {
  var getLineCoordinate = function(datum, datumIndex, data3, initLineOption) {
    return __assign(__assign({}, initLineOption), { start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]], end: [datum[PLOYGON_X][1] + 0.05, datum[PLOYGON_Y][1]] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function dynamicHeightFunnel(params) {
  return flow(field3, geometry8, transpose3, conversionTag4)(params);
}

// node_modules/@antv/g2plot/esm/plots/funnel/geometries/facet.js
function field4(params) {
  var _a6;
  var chart = params.chart, options = params.options;
  var _b = options.data, data3 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data3);
  chart.scale((_a6 = {}, _a6[yField] = {
    sync: true
  }, _a6));
  return params;
}
function geometry9(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, isTransposed = options.isTransposed, showFacetTitle = options.showFacetTitle;
  chart.facet("rect", {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      basicFunnel(deepAssign({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
function facetFunnel(params) {
  return flow(field4, geometry9)(params);
}

// node_modules/@antv/g2plot/esm/plots/funnel/interactions/funnel-conversion-tag.js
var ConversionTagAction = (
  /** @class */
  function(_super) {
    __extends(ConversionTagAction2, _super);
    function ConversionTagAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rendering = false;
      return _this;
    }
    ConversionTagAction2.prototype.change = function(options) {
      var _this = this;
      if (!this.rendering) {
        var seriesField = options.seriesField, compareField = options.compareField;
        var conversionTag_1 = compareField ? compareConversionTag : conversionTag2;
        var view = this.context.view;
        var views = seriesField || compareField ? view.views : [view];
        map_default(views, function(v, index) {
          var annotationController = v.getController("annotation");
          var annotations = filter_default(get_default(annotationController, ["option"], []), function(_a6) {
            var name = _a6.name;
            return name !== CONVERSION_TAG_NAME;
          });
          annotationController.clear(true);
          each_default(annotations, function(annotation4) {
            if (typeof annotation4 === "object") {
              v.annotation()[annotation4.type](annotation4);
            }
          });
          var data3 = get_default(v, ["filteredData"], v.getOptions().data);
          conversionTag_1({
            chart: v,
            index,
            options: __assign(__assign({}, options), {
              // @ts-ignore
              filteredData: transformData(data3, data3, options)
            })
          });
          v.filterData(data3);
          _this.rendering = true;
          v.render(true);
        });
      }
      this.rendering = false;
    };
    return ConversionTagAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/funnel/interactions/index.js
var FUNNEL_CONVERSION_TAG = "funnel-conversion-tag";
var FUNNEL_LEGEND_FILTER = "funnel-afterrender";
var interactionStart = { trigger: "afterrender", action: "".concat(FUNNEL_CONVERSION_TAG, ":change") };
registerAction(FUNNEL_CONVERSION_TAG, ConversionTagAction);
registerInteraction(FUNNEL_LEGEND_FILTER, {
  start: [interactionStart]
});

// node_modules/@antv/g2plot/esm/plots/funnel/adaptor.js
function defaultOptions3(params) {
  var options = params.options;
  var compareField = options.compareField, xField = options.xField, yField = options.yField, locale = options.locale, funnelStyle = options.funnelStyle, data3 = options.data;
  var i18n = getLocale(locale);
  var defaultOption = {
    label: compareField ? {
      fields: [xField, yField, compareField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      formatter: function(datum) {
        return "".concat(datum[yField]);
      }
    } : {
      fields: [xField, yField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      offset: 0,
      position: "middle",
      formatter: function(datum) {
        return "".concat(datum[xField], " ").concat(datum[yField]);
      }
    },
    tooltip: {
      title: xField,
      formatter: function(datum) {
        return { name: datum[xField], value: datum[yField] };
      }
    },
    conversionTag: {
      // conversionTag 
      formatter: function(datum) {
        return "".concat(i18n.get(["conversionTag", "label"]), ": ").concat(conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]));
      }
    }
  };
  var style;
  if (compareField || funnelStyle) {
    style = function(datum) {
      return deepAssign(
        {},
        // 
        compareField && { lineWidth: 1, stroke: "#fff" },
        is_function_default(funnelStyle) ? funnelStyle(datum) : funnelStyle
      );
    };
  }
  return deepAssign({ options: defaultOption }, params, { options: { funnelStyle: style, data: clone_default(data3) } });
}
function geometry10(params) {
  var options = params.options;
  var compareField = options.compareField, dynamicHeight = options.dynamicHeight, seriesField = options.seriesField;
  if (seriesField) {
    return facetFunnel(params);
  }
  if (compareField) {
    return compareFunnel(params);
  }
  if (dynamicHeight) {
    return dynamicHeightFunnel(params);
  }
  return basicFunnel(params);
}
function meta3(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6)))(params);
}
function axis3(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend5(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend;
  if (legend18 === false) {
    chart.legend(false);
  } else {
    chart.legend(legend18);
  }
  return params;
}
function interaction2(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, dynamicHeight = options.dynamicHeight;
  each_default(interactions, function(i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  if (!dynamicHeight) {
    chart.interaction(FUNNEL_LEGEND_FILTER, {
      start: [__assign(__assign({}, interactionStart), { arg: options })]
    });
  } else {
    chart.removeInteraction(FUNNEL_LEGEND_FILTER);
  }
  return params;
}
function adaptor5(params) {
  return flow(defaultOptions3, geometry10, meta3, axis3, tooltip, interaction2, legend5, animation, theme, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/funnel/index.js
var Funnel = (
  /** @class */
  function(_super) {
    __extends(Funnel2, _super);
    function Funnel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "funnel";
      return _this;
    }
    Funnel2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS4;
    };
    Funnel2.prototype.getDefaultOptions = function() {
      return Funnel2.getDefaultOptions();
    };
    Funnel2.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    Funnel2.prototype.setState = function(type, condition, status) {
      if (status === void 0) {
        status = true;
      }
      var elements = getAllElementsRecursively(this.chart);
      each_default(elements, function(ele) {
        if (condition(ele.getData())) {
          ele.setState(type, status);
        }
      });
    };
    Funnel2.prototype.getStates = function() {
      var elements = getAllElementsRecursively(this.chart);
      var stateObjects = [];
      each_default(elements, function(element) {
        var data3 = element.getData();
        var states = element.getStates();
        each_default(states, function(state2) {
          stateObjects.push({ data: data3, state: state2, geometry: element.geometry, element });
        });
      });
      return stateObjects;
    };
    Funnel2.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
    Funnel2.PERCENT_FIELD = FUNNEL_PERCENT;
    Funnel2.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
    return Funnel2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/gauge/constants.js
var _a4;
var RANGE_VALUE = "range";
var RANGE_TYPE = "type";
var PERCENT = "percent";
var DEFAULT_COLOR = "#f0f0f0";
var INDICATEOR_VIEW_ID = "indicator-view";
var RANGE_VIEW_ID = "range-view";
var DEFAULT_OPTIONS5 = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: "center",
        textBaseline: "middle"
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: "round"
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: "#fff"
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a4 = {}, //  view  scale  v 
  _a4[RANGE_VALUE] = {
    sync: "v"
  }, _a4[PERCENT] = {
    sync: "v",
    tickCount: 5,
    tickInterval: 0.2
  }, _a4),
  animation: false
};

// node_modules/@antv/g2plot/esm/plots/gauge/utils.js
function processRangeData(range2, percent2) {
  return range2.map(function(r, idx) {
    var _a6;
    return _a6 = {}, _a6[RANGE_VALUE] = r - (range2[idx - 1] || 0), _a6[RANGE_TYPE] = "".concat(idx), _a6[PERCENT] = percent2, _a6;
  });
}
function getIndicatorData(percent2) {
  var _a6;
  return [(_a6 = {}, _a6[PERCENT] = clamp_default(percent2, 0, 1), _a6)];
}
function getRangeData(percent2, range2) {
  var ticks = get_default(range2, ["ticks"], []);
  var clampTicks = size(ticks) ? uniq(ticks) : [0, clamp_default(percent2, 0, 1), 1];
  if (!clampTicks[0]) {
    clampTicks.shift();
  }
  return processRangeData(clampTicks, percent2);
}

// node_modules/@antv/g2plot/esm/plots/gauge/adaptor.js
function geometry11(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, range2 = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis22 = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type = options.type, meter = options.meter;
  var color3 = range2.color, rangeWidth = range2.width;
  if (indicator) {
    var indicatorData = getIndicatorData(percent2);
    var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
    v1.data(indicatorData);
    v1.point().position("".concat(PERCENT, "*1")).shape(indicator.shape || "gauge-indicator").customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator
    });
    v1.coordinate("polar", {
      startAngle,
      endAngle,
      radius: innerRadius * radius
      //  innerRadius * radius =  radius
    });
    v1.axis(PERCENT, axis22);
    v1.scale(PERCENT, pick(axis22, AXIS_META_CONFIG_KEYS));
  }
  var rangeData = getRangeData(percent2, options.range);
  var v2 = chart.createView({ id: RANGE_VIEW_ID });
  v2.data(rangeData);
  var rangeColor = is_string_default(color3) ? [color3, DEFAULT_COLOR] : color3;
  var ext = interval2({
    chart: v2,
    options: {
      xField: "1",
      yField: RANGE_VALUE,
      seriesField: RANGE_TYPE,
      rawFields: [PERCENT],
      isStack: true,
      interval: {
        color: rangeColor,
        style: gaugeStyle,
        shape: type === "meter" ? "meter-gauge" : null
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      },
      minColumnWidth: rangeWidth,
      maxColumnWidth: rangeWidth
    }
  }).ext;
  var geometry35 = ext.geometry;
  geometry35.customInfo({ meter });
  v2.coordinate("polar", {
    innerRadius,
    radius,
    startAngle,
    endAngle
  }).transpose();
  return params;
}
function meta4(params) {
  var _a6;
  return flow(scale5((_a6 = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a6[PERCENT] = {}, _a6)))(params);
}
function statistic(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic4 = options.statistic, percent2 = options.percent;
  chart.getController("annotation").clear(true);
  if (statistic4) {
    var contentOption = statistic4.content;
    var transformContent = void 0;
    if (contentOption) {
      transformContent = deepAssign({}, {
        content: "".concat((percent2 * 100).toFixed(2), "%"),
        style: {
          opacity: 0.75,
          fontSize: "30px",
          lineHeight: 1,
          textAlign: "center",
          color: "rgba(44,53,66,0.85)"
        }
      }, contentOption);
    }
    renderGaugeStatistic(chart, { statistic: __assign(__assign({}, statistic4), { content: transformContent }) }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function tooltip2(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11) {
    chart.tooltip(deepAssign({
      showTitle: false,
      showMarkers: false,
      containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
      domStyles: {
        "g2-tooltip": {
          padding: "4px 8px",
          fontSize: "10px"
        }
      },
      customContent: function(x, data3) {
        var percent2 = get_default(data3, [0, "data", PERCENT], 0);
        return "".concat((percent2 * 100).toFixed(2), "%");
      }
    }, tooltip11));
  } else {
    chart.tooltip(false);
  }
  return params;
}
function other(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function adaptor6(params) {
  return flow(
    theme,
    // animation  createView  View 
    animation,
    geometry11,
    meta4,
    tooltip2,
    statistic,
    interaction,
    annotation(),
    other
    // ...  adaptor flow
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/gauge/shapes/indicator.js
registerShape("point", "gauge-indicator", {
  draw: function(cfg, container) {
    var _a6 = cfg.customInfo, indicator = _a6.indicator, defaultColor = _a6.defaultColor;
    var _b = indicator, pointer = _b.pointer, pin2 = _b.pin;
    var group2 = container.addGroup();
    var center2 = this.parsePoint({ x: 0, y: 0 });
    if (pointer) {
      group2.addShape("line", {
        name: "pointer",
        attrs: __assign({ x1: center2.x, y1: center2.y, x2: cfg.x, y2: cfg.y, stroke: defaultColor }, pointer.style)
      });
    }
    if (pin2) {
      group2.addShape("circle", {
        name: "pin",
        attrs: __assign({ x: center2.x, y: center2.y, stroke: defaultColor }, pin2.style)
      });
    }
    return group2;
  }
});

// node_modules/@antv/g2plot/esm/plots/gauge/shapes/meter-gauge.js
registerShape("interval", "meter-gauge", {
  draw: function(cfg, container) {
    var _a6 = cfg.customInfo.meter, meter = _a6 === void 0 ? {} : _a6;
    var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? 0.5 : _c;
    STEP = STEP < 1 ? 1 : STEP;
    STEP_RATIO = clamp_default(STEP_RATIO, 0, 1);
    var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
    var GAP2 = 0;
    if (STEP_RATIO > 0 && STEP_RATIO < 1) {
      var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;
      GAP2 = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
    }
    var INTERVAL = GAP2 / (1 - STEP_RATIO) * STEP_RATIO;
    var group2 = container.addGroup();
    var center2 = this.coordinate.getCenter();
    var radius = this.coordinate.getRadius();
    var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
    for (var startAngle = START_ANGLE; startAngle < END_ANGLE; ) {
      var endAngle = void 0;
      var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP2);
      if (r < INTERVAL) {
        endAngle = startAngle + (INTERVAL - r);
      } else {
        startAngle += INTERVAL + GAP2 - r;
        endAngle = startAngle + INTERVAL;
      }
      var path = Util.getSectorPath(center2.x, center2.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
      group2.addShape("path", {
        name: "meter-gauge",
        attrs: {
          path,
          fill: cfg.color,
          stroke: cfg.color,
          lineWidth: 0.5
        }
      });
      startAngle = endAngle + GAP2;
    }
    return group2;
  }
});

// node_modules/@antv/g2plot/esm/plots/gauge/index.js
var Gauge = (
  /** @class */
  function(_super) {
    __extends(Gauge2, _super);
    function Gauge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "gauge";
      return _this;
    }
    Gauge2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS5;
    };
    Gauge2.prototype.changeData = function(percent2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ percent: percent2 });
      var indicatorView = this.chart.views.find(function(v) {
        return v.id === INDICATEOR_VIEW_ID;
      });
      if (indicatorView) {
        indicatorView.data(getIndicatorData(percent2));
      }
      var rangeView = this.chart.views.find(function(v) {
        return v.id === RANGE_VIEW_ID;
      });
      if (rangeView) {
        rangeView.data(getRangeData(percent2, this.options.range));
      }
      statistic({ chart: this.chart, options: this.options }, true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    Gauge2.prototype.getDefaultOptions = function() {
      return Gauge2.getDefaultOptions();
    };
    Gauge2.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Gauge2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/utils/transform/histogram.js
function getBinKey(value2, binWidth, binNumber) {
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index = Math.floor(value2 / binWidth);
  return [binWidth * index, binWidth * (index + 1)];
}
function sturges(values3) {
  return Math.ceil(Math.log(values3.length) / Math.LN2) + 1;
}
function binHistogram(data3, binField, binWidth, binNumber, stackField) {
  var originData_copy = clone_default(data3);
  sort_by_default(originData_copy, binField);
  var values3 = values_of_key_default(originData_copy, binField);
  var range2 = get_range_default(values3);
  var rangeWidth = range2.max - range2.min;
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range2.max;
  }
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values3);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  var bins = {};
  var groups = group_by_default(originData_copy, stackField);
  if (is_empty_default(groups)) {
    each_default(originData_copy, function(data4) {
      var value2 = data4[binField];
      var bin = getBinKey(value2, _binWidth, binNumber);
      var binKey = "".concat(bin[0], "-").concat(bin[1]);
      if (!has_key_default(bins, binKey)) {
        bins[binKey] = { range: bin, count: 0 };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function(groupKey) {
      each_default(groups[groupKey], function(data4) {
        var value2 = data4[binField];
        var bin = getBinKey(value2, _binWidth, binNumber);
        var binKey = "".concat(bin[0], "-").concat(bin[1]);
        var groupKeyBinKey = "".concat(binKey, "-").concat(groupKey);
        if (!has_key_default(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = { range: bin, count: 0 };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  var plotData = [];
  each_default(bins, function(bin) {
    plotData.push(bin);
  });
  return plotData;
}

// node_modules/@antv/g2plot/esm/plots/histogram/constant.js
var HISTOGRAM_X_FIELD = "range";
var HISTOGRAM_Y_FIELD = "count";
var DEFAULT_OPTIONS6 = deepAssign({}, Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: "#FFFFFF"
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});

// node_modules/@antv/g2plot/esm/plots/histogram/adaptor.js
function geometry12(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color3 = options.color, stackField = options.stackField, legend18 = options.legend, columnStyle = options.columnStyle;
  var plotData = binHistogram(data3, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = deepAssign({}, params, {
    options: {
      xField: HISTOGRAM_X_FIELD,
      yField: HISTOGRAM_Y_FIELD,
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color3,
        style: columnStyle
      }
    }
  });
  interval2(p);
  if (legend18 && stackField) {
    chart.legend(stackField, legend18);
  } else {
    chart.legend(false);
  }
  return params;
}
function meta5(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  return flow(scale5((_a6 = {}, _a6[HISTOGRAM_X_FIELD] = xAxis, _a6[HISTOGRAM_Y_FIELD] = yAxis, _a6)))(params);
}
function axis4(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  if (xAxis === false) {
    chart.axis(HISTOGRAM_X_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_X_FIELD, xAxis);
  }
  if (yAxis === false) {
    chart.axis(HISTOGRAM_Y_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_Y_FIELD, yAxis);
  }
  return params;
}
function label5(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label;
  var geometry35 = findGeometry(chart, "interval");
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: [HISTOGRAM_Y_FIELD],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor7(params) {
  return flow(theme, pattern("columnStyle"), geometry12, meta5, axis4, state, label5, tooltip, interaction, animation)(params);
}

// node_modules/@antv/g2plot/esm/plots/histogram/index.js
var Histogram = (
  /** @class */
  function(_super) {
    __extends(Histogram2, _super);
    function Histogram2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "histogram";
      return _this;
    }
    Histogram2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS6;
    };
    Histogram2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this.options, binField = _a6.binField, binNumber = _a6.binNumber, binWidth = _a6.binWidth, stackField = _a6.stackField;
      this.chart.changeData(binHistogram(data3, binField, binWidth, binNumber, stackField));
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/line/constants.js
var DEFAULT_OPTIONS7 = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  legend: {
    position: "top-left",
    radio: {}
  },
  isStack: false
});

// node_modules/@antv/g2plot/esm/plots/line/interactions/marker-active.js
var MarkerActiveAction = (
  /** @class */
  function(_super) {
    __extends(MarkerActiveAction2, _super);
    function MarkerActiveAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MarkerActiveAction2.prototype.active = function() {
      var view = this.getView();
      var evt = this.context.event;
      if (evt.data) {
        var items_1 = evt.data.items;
        var points2 = view.geometries.filter(function(geom) {
          return geom.type === "point";
        });
        each_default(points2, function(point2) {
          each_default(point2.elements, function(element) {
            var active = find_index_default(items_1, function(item) {
              return item.data === element.data;
            }) !== -1;
            element.setState("active", active);
          });
        });
      }
    };
    MarkerActiveAction2.prototype.reset = function() {
      var view = this.getView();
      var points2 = view.geometries.filter(function(geom) {
        return geom.type === "point";
      });
      each_default(points2, function(point2) {
        each_default(point2.elements, function(element) {
          element.setState("active", false);
        });
      });
    };
    MarkerActiveAction2.prototype.getView = function() {
      return this.context.view;
    };
    return MarkerActiveAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/line/interactions/index.js
registerAction("marker-active", MarkerActiveAction);
registerInteraction("marker-active", {
  start: [
    {
      trigger: "tooltip:show",
      action: "marker-active:active"
    }
  ],
  end: [
    {
      trigger: "tooltip:hide",
      action: "marker-active:reset"
    }
  ]
});

// node_modules/@antv/g2plot/esm/plots/line/index.js
var Line6 = (
  /** @class */
  function(_super) {
    __extends(Line7, _super);
    function Line7() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      return _this;
    }
    Line7.getDefaultOptions = function() {
      return DEFAULT_OPTIONS7;
    };
    Line7.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this, chart = _a6.chart, options = _a6.options;
      meta({ chart, options });
      this.chart.changeData(data3);
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor;
    };
    return Line7;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/pie/contants.js
var DEFAULT_OPTIONS8 = deepAssign({}, Plot.getDefaultOptions(), {
  legend: {
    position: "right",
    radio: {}
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: { type: "limit-in-plot", cfg: { action: "ellipsis" } }
  },
  /** ,  */
  pieStyle: {
    stroke: "white",
    lineWidth: 1
  },
  /**  */
  statistic: {
    title: {
      style: { fontWeight: 300, color: "#4B535E", textAlign: "center", fontSize: "20px", lineHeight: 1 }
    },
    content: {
      style: {
        fontWeight: "bold",
        color: "rgba(44,53,66,0.85)",
        textAlign: "center",
        fontSize: "32px",
        lineHeight: 1
      }
    }
  },
  /**  text-annotation  */
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});

// node_modules/@antv/g2plot/esm/utils/matrix.js
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform5(actions, matrix) {
  var ulMatrix = matrix ? __spreadArray([], matrix, true) : __spreadArray([], ORIGIN_MATRIX, true);
  return Util.transform(ulMatrix, actions);
}

// node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/legend-active.js
var PieLegendAction = (
  /** @class */
  function(_super) {
    __extends(PieLegendAction2, _super);
    function PieLegendAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieLegendAction2.prototype.getActiveElements = function() {
      var delegateObject = Util.getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component2 = delegateObject.component, item_1 = delegateObject.item;
        var field_1 = component2.get("field");
        if (field_1) {
          var elements = view.geometries[0].elements;
          return elements.filter(function(ele) {
            return ele.getModel().data[field_1] === item_1.value;
          });
        }
      }
      return [];
    };
    PieLegendAction2.prototype.getActiveElementLabels = function() {
      var view = this.context.view;
      var elements = this.getActiveElements();
      var labels = view.geometries[0].labelsContainer.getChildren();
      return labels.filter(function(label17) {
        return elements.find(function(ele) {
          return is_equal_default(ele.getData(), label17.get("data"));
        });
      });
    };
    PieLegendAction2.prototype.transfrom = function(offset) {
      if (offset === void 0) {
        offset = 7.5;
      }
      var elements = this.getActiveElements();
      var elementLabels = this.getActiveElementLabels();
      elements.forEach(function(element, idx) {
        var labelShape = elementLabels[idx];
        var coordinate11 = element.geometry.coordinate;
        if (coordinate11.isPolar && coordinate11.isTransposed) {
          var _a6 = Util.getAngle(element.getModel(), coordinate11), startAngle = _a6.startAngle, endAngle = _a6.endAngle;
          var middleAngle = (startAngle + endAngle) / 2;
          var r = offset;
          var x = r * Math.cos(middleAngle);
          var y = r * Math.sin(middleAngle);
          element.shape.setMatrix(transform5([["t", x, y]]));
          labelShape.setMatrix(transform5([["t", x, y]]));
        }
      });
    };
    PieLegendAction2.prototype.active = function() {
      this.transfrom();
    };
    PieLegendAction2.prototype.reset = function() {
      this.transfrom(0);
    };
    return PieLegendAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/pie/interactions/util.js
function getCurrentElement2(context) {
  var event = context.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}

// node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/statistic-active.js
var StatisticAction = (
  /** @class */
  function(_super) {
    __extends(StatisticAction2, _super);
    function StatisticAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StatisticAction2.prototype.getAnnotations = function(_view) {
      var view = _view || this.context.view;
      return view.getController("annotation").option;
    };
    StatisticAction2.prototype.getInitialAnnotation = function() {
      return this.initialAnnotation;
    };
    StatisticAction2.prototype.init = function() {
      var _this = this;
      var view = this.context.view;
      view.removeInteraction("tooltip");
      view.on("afterchangesize", function() {
        var annotations = _this.getAnnotations(view);
        _this.initialAnnotation = annotations;
      });
    };
    StatisticAction2.prototype.change = function(arg) {
      var _a6 = this.context, view = _a6.view, event = _a6.event;
      if (!this.initialAnnotation) {
        this.initialAnnotation = this.getAnnotations();
      }
      var data3 = get_default(event, ["data", "data"]);
      if (event.type.match("legend-item")) {
        var delegateObject = Util.getDelegationObject(this.context);
        var colorField_1 = view.getGroupedFields()[0];
        if (delegateObject && colorField_1) {
          var item_1 = delegateObject.item;
          data3 = view.getData().find(function(d) {
            return d[colorField_1] === item_1.value;
          });
        }
      }
      if (data3) {
        var annotations = get_default(arg, "annotations", []);
        var statistic4 = get_default(arg, "statistic", {});
        view.getController("annotation").clear(true);
        each_default(annotations, function(annotation4) {
          if (typeof annotation4 === "object") {
            view.annotation()[annotation4.type](annotation4);
          }
        });
        renderStatistic(view, { statistic: statistic4, plotType: "pie" }, data3);
        view.render(true);
      }
      var ele = getCurrentElement2(this.context);
      if (ele) {
        ele.shape.toFront();
      }
    };
    StatisticAction2.prototype.reset = function() {
      var view = this.context.view;
      var annotationController = view.getController("annotation");
      annotationController.clear(true);
      var initialStatistic = this.getInitialAnnotation();
      each_default(initialStatistic, function(a) {
        view.annotation()[a.type](a);
      });
      view.render(true);
    };
    return StatisticAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/pie/interactions/index.js
var PIE_STATISTIC = "pie-statistic";
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction("pie-statistic-active", {
  start: [{ trigger: "element:mouseenter", action: "pie-statistic:change" }],
  end: [{ trigger: "element:mouseleave", action: "pie-statistic:reset" }]
});
registerAction("pie-legend", PieLegendAction);
registerInteraction("pie-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: "pie-legend:active" }],
  end: [{ trigger: "legend-item:mouseleave", action: "pie-legend:reset" }]
});

// node_modules/@antv/g2plot/esm/plots/pie/utils.js
function getTotalValue(data3, field6) {
  var total = null;
  each_default(data3, function(item) {
    if (typeof item[field6] === "number") {
      total += item[field6];
    }
  });
  return total;
}
function adaptOffset(type, offset) {
  var defaultOffset;
  switch (type) {
    case "inner":
      defaultOffset = "-30%";
      if (is_string_default(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }
      return offset < 0 ? offset : defaultOffset;
    case "outer":
      defaultOffset = 12;
      if (is_string_default(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }
      return offset > 0 ? offset : defaultOffset;
    default:
      return offset;
  }
}
function isAllZero(data3, angleField) {
  return every_default(processIllegalData(data3, angleField), function(d) {
    return d[angleField] === 0;
  });
}

// node_modules/@antv/g2plot/esm/plots/pie/adaptor.js
function geometry13(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, angleField = options.angleField, colorField = options.colorField, color3 = options.color, pieStyle = options.pieStyle, shape = options.shape;
  var processData2 = processIllegalData(data3, angleField);
  if (isAllZero(processData2, angleField)) {
    var percentageField_1 = "$$percentage$$";
    processData2 = processData2.map(function(d) {
      var _a6;
      return __assign(__assign({}, d), (_a6 = {}, _a6[percentageField_1] = 1 / processData2.length, _a6));
    });
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color3,
          shape,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval2(p);
  } else {
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color3,
          shape,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval2(p);
  }
  return params;
}
function meta6(params) {
  var _a6;
  var chart = params.chart, options = params.options;
  var meta23 = options.meta, colorField = options.colorField;
  var scales = deepAssign({}, meta23);
  chart.scale(scales, (_a6 = {}, _a6[colorField] = { type: "cat" }, _a6));
  return params;
}
function coordinate3(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "theta",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function label6(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, colorField = options.colorField, angleField = options.angleField;
  var geometry35 = chart.geometries[0];
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    var labelCfg = transformLabel(cfg);
    if (labelCfg.content) {
      var content_1 = labelCfg.content;
      labelCfg.content = function(data3, dataum, index) {
        var name = data3[colorField];
        var value2 = data3[angleField];
        var angleScale = chart.getScaleByField(angleField);
        var percent2 = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value2);
        return is_function_default(content_1) ? (
          // append percent (number) to data, users can get origin data from `dataum._origin`
          content_1(__assign(__assign({}, data3), { percent: percent2 }), dataum, index)
        ) : is_string_default(content_1) ? template(content_1, {
          value: value2,
          name,
          // percentage (string), default keep 2
          percentage: is_number_default(percent2) && !is_nil_default(value2) ? "".concat((percent2 * 100).toFixed(2), "%") : null
        }) : content_1;
      };
    }
    var LABEL_LAYOUT_TYPE_MAP = {
      inner: "",
      outer: "pie-outer",
      spider: "pie-spider"
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : "pie-outer";
    var labelLayoutCfg = labelCfg.layout ? !is_array_default(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
    geometry35.label({
      // fix: could not create scale, when field is undefinedattributes  fields  scale
      fields: colorField ? [angleField, colorField] : [angleField],
      callback,
      cfg: __assign(__assign({}, labelCfg), { offset: adaptOffset(labelCfg.type, labelCfg.offset), type: "pie" })
    });
  }
  return params;
}
function transformStatisticOptions(options) {
  var innerRadius = options.innerRadius, statistic4 = options.statistic, angleField = options.angleField, colorField = options.colorField, meta23 = options.meta, locale = options.locale;
  var i18n = getLocale(locale);
  if (innerRadius && statistic4) {
    var _a6 = deepAssign({}, DEFAULT_OPTIONS8.statistic, statistic4), titleOpt_1 = _a6.title, contentOpt_1 = _a6.content;
    if (titleOpt_1 !== false) {
      titleOpt_1 = deepAssign({}, {
        formatter: function(datum) {
          var text = datum ? datum[colorField] : !is_nil_default(titleOpt_1.content) ? titleOpt_1.content : i18n.get(["statistic", "total"]);
          var metaFormatter = get_default(meta23, [colorField, "formatter"]) || function(v) {
            return v;
          };
          return metaFormatter(text);
        }
      }, titleOpt_1);
    }
    if (contentOpt_1 !== false) {
      contentOpt_1 = deepAssign({}, {
        formatter: function(datum, data3) {
          var dataValue = datum ? datum[angleField] : getTotalValue(data3, angleField);
          var metaFormatter = get_default(meta23, [angleField, "formatter"]) || function(v) {
            return v;
          };
          if (datum) {
            return metaFormatter(dataValue);
          }
          return !is_nil_default(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
        }
      }, contentOpt_1);
    }
    return deepAssign({}, { statistic: { title: titleOpt_1, content: contentOpt_1 } }, options);
  }
  return options;
}
function pieAnnotation(params) {
  var chart = params.chart, options = params.options;
  var _a6 = transformStatisticOptions(options), innerRadius = _a6.innerRadius, statistic4 = _a6.statistic;
  chart.getController("annotation").clear(true);
  flow(annotation())(params);
  if (innerRadius && statistic4) {
    renderStatistic(chart, { statistic: statistic4, plotType: "pie" });
  }
  return params;
}
function tooltip3(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip, colorField = options.colorField, angleField = options.angleField, data3 = options.data;
  if (tooltip11 === false) {
    chart.tooltip(tooltip11);
  } else {
    chart.tooltip(deepAssign({}, tooltip11, { shared: false }));
    if (isAllZero(data3, angleField)) {
      var fields = get_default(tooltip11, "fields");
      var formatter = get_default(tooltip11, "formatter");
      if (is_empty_default(get_default(tooltip11, "fields"))) {
        fields = [colorField, angleField];
        formatter = formatter || function(datum) {
          return { name: datum[colorField], value: to_string_default(datum[angleField]) };
        };
      }
      chart.geometries[0].tooltip(fields.join("*"), getMappingFunction(fields, formatter));
    }
  }
  return params;
}
function interaction3(params) {
  var chart = params.chart, options = params.options;
  var _a6 = transformStatisticOptions(options), interactions = _a6.interactions, statistic4 = _a6.statistic, annotations = _a6.annotations;
  each_default(interactions, function(i) {
    var _a7, _b;
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else if (i.type === "pie-statistic-active") {
      var startStages_1 = [];
      if (!((_a7 = i.cfg) === null || _a7 === void 0 ? void 0 : _a7.start)) {
        startStages_1 = [
          {
            trigger: "element:mouseenter",
            action: "".concat(PIE_STATISTIC, ":change"),
            arg: { statistic: statistic4, annotations }
          }
        ];
      }
      each_default((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function(stage) {
        startStages_1.push(__assign(__assign({}, stage), { arg: { statistic: statistic4, annotations } }));
      });
      chart.interaction(i.type, deepAssign({}, i.cfg, { start: startStages_1 }));
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor8(params) {
  return flow(
    pattern("pieStyle"),
    geometry13,
    meta6,
    theme,
    coordinate3,
    legend,
    tooltip3,
    label6,
    state,
    /**   */
    pieAnnotation,
    interaction3,
    animation
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/pie/index.js
var Pie = (
  /** @class */
  function(_super) {
    __extends(Pie2, _super);
    function Pie2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pie";
      return _this;
    }
    Pie2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS8;
    };
    Pie2.prototype.changeData = function(data3) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      var prevOptions = this.options;
      var angleField = this.options.angleField;
      var prevData = processIllegalData(prevOptions.data, angleField);
      var curData = processIllegalData(data3, angleField);
      if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) {
        this.update({ data: data3 });
      } else {
        this.updateOption({ data: data3 });
        this.chart.data(curData);
        pieAnnotation({ chart: this.chart, options: this.options });
        this.chart.render(true);
      }
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/progress/constants.js
var DEFAULT_COLOR2 = ["#FAAD14", "#E8EDF3"];
var DEFAULT_OPTIONS9 = {
  percent: 0.2,
  color: DEFAULT_COLOR2,
  animation: {}
};

// node_modules/@antv/g2plot/esm/plots/progress/utils.js
function getProgressData(percent2) {
  var clampPercent = clamp_default(isRealNumber(percent2) ? percent2 : 0, 0, 1);
  return [
    {
      //  progressStyle 
      current: "".concat(clampPercent),
      type: "current",
      percent: clampPercent
    },
    {
      current: "".concat(clampPercent),
      type: "target",
      percent: 1
    }
  ];
}

// node_modules/@antv/g2plot/esm/plots/progress/adaptor.js
function geometry14(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, progressStyle = options.progressStyle, color3 = options.color, barWidthRatio = options.barWidthRatio;
  chart.data(getProgressData(percent2));
  var p = deepAssign({}, params, {
    options: {
      xField: "current",
      yField: "percent",
      seriesField: "type",
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: is_string_default(color3) ? [color3, DEFAULT_COLOR2[1]] : color3
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      }
    }
  });
  interval2(p);
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function coordinate4(params) {
  var chart = params.chart;
  chart.coordinate("rect").transpose();
  return params;
}
function adaptor9(params) {
  return flow(geometry14, scale5({}), coordinate4, animation, theme, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/progress/index.js
var Progress = (
  /** @class */
  function(_super) {
    __extends(Progress2, _super);
    function Progress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "process";
      return _this;
    }
    Progress2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS9;
    };
    Progress2.prototype.changeData = function(percent2) {
      this.updateOption({ percent: percent2 });
      this.chart.changeData(getProgressData(percent2));
    };
    Progress2.prototype.getDefaultOptions = function() {
      return Progress2.getDefaultOptions();
    };
    Progress2.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Progress2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/ring-progress/adaptor.js
function coordinate5(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius;
  chart.coordinate("theta", {
    innerRadius,
    radius
  });
  return params;
}
function statistic2(params, updated) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, statistic4 = options.statistic, percent2 = options.percent, meta23 = options.meta;
  chart.getController("annotation").clear(true);
  if (innerRadius && statistic4) {
    var metaFormatter = get_default(meta23, ["percent", "formatter"]) || function(v) {
      return "".concat((v * 100).toFixed(2), "%");
    };
    var contentOpt = statistic4.content;
    if (contentOpt) {
      contentOpt = deepAssign({}, contentOpt, {
        content: !is_nil_default(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
      });
    }
    renderStatistic(chart, { statistic: __assign(__assign({}, statistic4), { content: contentOpt }), plotType: "ring-progress" }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor10(params) {
  return flow(geometry14, scale5({}), coordinate5, statistic2, animation, theme, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/ring-progress/constants.js
var DEFAULT_OPTIONS10 = {
  percent: 0.2,
  innerRadius: 0.8,
  radius: 0.98,
  color: ["#FAAD14", "#E8EDF3"],
  statistic: {
    title: false,
    content: {
      style: {
        fontSize: "14px",
        fontWeight: 300,
        fill: "#4D4D4D",
        textAlign: "center",
        textBaseline: "middle"
      }
    }
  },
  animation: {}
};

// node_modules/@antv/g2plot/esm/plots/ring-progress/index.js
var RingProgress = (
  /** @class */
  function(_super) {
    __extends(RingProgress2, _super);
    function RingProgress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ring-process";
      return _this;
    }
    RingProgress2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS10;
    };
    RingProgress2.prototype.changeData = function(percent2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ percent: percent2 });
      this.chart.data(getProgressData(percent2));
      statistic2({ chart: this.chart, options: this.options }, true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    RingProgress2.prototype.getDefaultOptions = function() {
      return RingProgress2.getDefaultOptions();
    };
    RingProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return RingProgress2;
  }(Plot)
);

// node_modules/d3-regression/dist/d3-regression.esm.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function points(data3, x, y, sort) {
  data3 = data3.filter(function(d2, i2) {
    var u = x(d2, i2), v = y(d2, i2);
    return u != null && isFinite(u) && v != null && isFinite(v);
  });
  if (sort) {
    data3.sort(function(a, b) {
      return x(a) - x(b);
    });
  }
  var n = data3.length, X = new Float64Array(n), Y = new Float64Array(n);
  var ux = 0, uy = 0, xv, yv, d;
  for (var i = 0; i < n; ) {
    d = data3[i];
    X[i] = xv = +x(d, i, data3);
    Y[i] = yv = +y(d, i, data3);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (var _i = 0; _i < n; ++_i) {
    X[_i] -= ux;
    Y[_i] -= uy;
  }
  return [X, Y, ux, uy];
}
function visitPoints(data3, x, y, cb) {
  var iterations = 0;
  for (var i = 0, n = data3.length; i < n; i++) {
    var d = data3[i], dx = +x(d, i, data3), dy = +y(d, i, data3);
    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
      cb(dx, dy, iterations++);
    }
  }
}
function determination(data3, x, y, uY, predict) {
  var SSE = 0, SST = 0;
  visitPoints(data3, x, y, function(dx, dy) {
    var sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function angle3(line2) {
  return Math.atan2(line2[1][1] - line2[0][1], line2[1][0] - line2[0][0]) * 180 / Math.PI;
}
function midpoint(line2) {
  return [(line2[0][0] + line2[1][0]) / 2, (line2[0][1] + line2[1][1]) / 2];
}
function interpose(xmin, xmax, predict) {
  var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
  var precision = 1 * Math.pow(10, -l / 2 - 1), maxIter = 1e4;
  var points2 = [px(xmin), px(xmax)], iter = 0;
  while (find4(points2) && iter < maxIter) {
  }
  return points2;
  function px(x) {
    return [x, predict(x)];
  }
  function find4(points3) {
    iter++;
    var n = points3.length;
    var found = false;
    for (var i = 0; i < n - 1; i++) {
      var p0 = points3[i], p1 = points3[i + 1], m = midpoint([p0, p1]), mp = px(m[0]), a0 = angle3([p0, m]), a1 = angle3([p0, mp]), a = Math.abs(a0 - a1);
      if (a > precision) {
        points3.splice(i + 1, 0, mp);
        found = true;
      }
    }
    return found;
  }
}
function ols(uX, uY, uXY, uX2) {
  var delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function exponential2() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function exponential3(data3) {
    var n = 0, Y = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data3, x, y, function(dx, dy) {
      var ly = Math.log(dy), xy = dx * dy;
      ++n;
      Y += (dy - Y) / n;
      XY += (xy - XY) / n;
      X2Y += (dx * xy - X2Y) / n;
      YL += (dy * ly - YL) / n;
      XYL += (xy * ly - XYL) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
    a = Math.exp(a);
    var fn = function fn2(x2) {
      return a * Math.exp(b * x2);
    }, out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data3, x, y, Y, fn);
    return out;
  }
  exponential3.domain = function(arr) {
    return arguments.length ? (domain = arr, exponential3) : domain;
  };
  exponential3.x = function(fn) {
    return arguments.length ? (x = fn, exponential3) : x;
  };
  exponential3.y = function(fn) {
    return arguments.length ? (y = fn, exponential3) : y;
  };
  return exponential3;
}
function linear4() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function linear5(data3) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data3, x, y, function(dx, dy) {
      ++n;
      X += (dx - X) / n;
      Y += (dy - Y) / n;
      XY += (dx * dy - XY) / n;
      X2 += (dx * dx - X2) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn2(x2) {
      return slope * x2 + intercept;
    }, out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data3, x, y, Y, fn);
    return out;
  }
  linear5.domain = function(arr) {
    return arguments.length ? (domain = arr, linear5) : domain;
  };
  linear5.x = function(fn) {
    return arguments.length ? (x = fn, linear5) : x;
  };
  linear5.y = function(fn) {
    return arguments.length ? (y = fn, linear5) : y;
  };
  return linear5;
}
function median(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  var i = arr.length / 2;
  return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
}
var maxiters = 2;
var epsilon = 1e-12;
function loess() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, bandwidth = 0.3;
  function loess2(data3) {
    var _points = points(data3, x, y, true), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, bw = Math.max(2, ~~(bandwidth * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
    for (var iter = -1; ++iter <= maxiters; ) {
      var interval3 = [0, bw - 1];
      for (var i = 0; i < n; ++i) {
        var dx = xv[i], i0 = interval3[0], i1 = interval3[1], edge2 = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
        var W = 0, X = 0, Y = 0, XY = 0, X2 = 0, denom = 1 / Math.abs(xv[edge2] - dx || 1);
        for (var k = i0; k <= i1; ++k) {
          var xk = xv[k], yk = yv[k], w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w;
          W += w;
          X += xkw;
          Y += yk * w;
          XY += yk * xkw;
          X2 += xk * xkw;
        }
        var _ols = ols(X / W, Y / W, XY / W, X2 / W), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
        yhat[i] = a + b * dx;
        residuals[i] = Math.abs(yv[i] - yhat[i]);
        updateInterval(xv, i + 1, interval3);
      }
      if (iter === maxiters) {
        break;
      }
      var medianResidual = median(residuals);
      if (Math.abs(medianResidual) < epsilon)
        break;
      for (var _i = 0, arg, _w; _i < n; ++_i) {
        arg = residuals[_i] / (6 * medianResidual);
        robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
      }
    }
    return output(xv, yhat, ux, uy);
  }
  loess2.bandwidth = function(bw) {
    return arguments.length ? (bandwidth = bw, loess2) : bandwidth;
  };
  loess2.x = function(fn) {
    return arguments.length ? (x = fn, loess2) : x;
  };
  loess2.y = function(fn) {
    return arguments.length ? (y = fn, loess2) : y;
  };
  return loess2;
}
function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
}
function updateInterval(xv, i, interval3) {
  var val = xv[i], left2 = interval3[0], right2 = interval3[1] + 1;
  if (right2 >= xv.length)
    return;
  while (i > left2 && xv[right2] - val <= val - xv[left2]) {
    interval3[0] = ++left2;
    interval3[1] = right2;
    ++right2;
  }
}
function output(xv, yhat, ux, uy) {
  var n = xv.length, out = [];
  var i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
function logarithmic() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, base = Math.E, domain;
  function logarithmic2(data3) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb = Math.log(base);
    visitPoints(data3, x, y, function(dx, dy) {
      var lx = Math.log(dx) / lb;
      ++n;
      X += (lx - X) / n;
      Y += (dy - Y) / n;
      XY += (lx * dy - XY) / n;
      X2 += (lx * lx - X2) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn2(x2) {
      return slope * Math.log(x2) / lb + intercept;
    }, out = interpose(xmin, xmax, fn);
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data3, x, y, Y, fn);
    return out;
  }
  logarithmic2.domain = function(arr) {
    return arguments.length ? (domain = arr, logarithmic2) : domain;
  };
  logarithmic2.x = function(fn) {
    return arguments.length ? (x = fn, logarithmic2) : x;
  };
  logarithmic2.y = function(fn) {
    return arguments.length ? (y = fn, logarithmic2) : y;
  };
  logarithmic2.base = function(n) {
    return arguments.length ? (base = n, logarithmic2) : base;
  };
  return logarithmic2;
}
function quad() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function quadratic(data3) {
    var _points = points(data3, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length;
    var X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x2;
    for (i = 0; i < n; ) {
      dx = xv[i];
      dy = yv[i++];
      x2 = dx * dx;
      X2 += (x2 - X2) / i;
      X3 += (x2 * dx - X3) / i;
      X4 += (x2 * x2 - X4) / i;
      XY += (dx * dy - XY) / i;
      X2Y += (x2 * dy - X2Y) / i;
    }
    var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data3, x, y, function(dx2, dy2) {
      n0++;
      Y += (dy2 - Y) / n0;
      if (!domain) {
        if (dx2 < xmin)
          xmin = dx2;
        if (dx2 > xmax)
          xmax = dx2;
      }
    });
    var X2X2 = X4 - X2 * X2, d = X2 * X2X2 - X3 * X3, a = (X2Y * X2 - XY * X3) / d, b = (XY * X2X2 - X2Y * X3) / d, c = -a * X2, fn = function fn2(x3) {
      x3 = x3 - ux;
      return a * x3 * x3 + b * x3 + c + uy;
    };
    var out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b - 2 * a * ux;
    out.c = c - b * ux + a * ux * ux + uy;
    out.predict = fn;
    out.rSquared = determination(data3, x, y, Y, fn);
    return out;
  }
  quadratic.domain = function(arr) {
    return arguments.length ? (domain = arr, quadratic) : domain;
  };
  quadratic.x = function(fn) {
    return arguments.length ? (x = fn, quadratic) : x;
  };
  quadratic.y = function(fn) {
    return arguments.length ? (y = fn, quadratic) : y;
  };
  return quadratic;
}
function polynomial() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, order = 3, domain;
  function polynomial2(data3) {
    if (order === 1) {
      var o = linear4().x(x).y(y).domain(domain)(data3);
      o.coefficients = [o.b, o.a];
      delete o.a;
      delete o.b;
      return o;
    }
    if (order === 2) {
      var _o = quad().x(x).y(y).domain(domain)(data3);
      _o.coefficients = [_o.c, _o.b, _o.a];
      delete _o.a;
      delete _o.b;
      delete _o.c;
      return _o;
    }
    var _points = points(data3, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, lhs = [], rhs = [], k = order + 1;
    var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data3, x, y, function(dx, dy) {
      ++n0;
      Y += (dy - Y) / n0;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var i, j, l, v, c;
    for (i = 0; i < k; ++i) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i) * yv[l];
      }
      lhs.push(v);
      c = new Float64Array(k);
      for (j = 0; j < k; ++j) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i + j);
        }
        c[j] = v;
      }
      rhs.push(c);
    }
    rhs.push(lhs);
    var coef = gaussianElimination(rhs), fn = function fn2(x2) {
      x2 -= ux;
      var y2 = uy + coef[0] + coef[1] * x2 + coef[2] * x2 * x2;
      for (i = 3; i < k; ++i) {
        y2 += coef[i] * Math.pow(x2, i);
      }
      return y2;
    }, out = interpose(xmin, xmax, fn);
    out.coefficients = uncenter(k, coef, -ux, uy);
    out.predict = fn;
    out.rSquared = determination(data3, x, y, Y, fn);
    return out;
  }
  polynomial2.domain = function(arr) {
    return arguments.length ? (domain = arr, polynomial2) : domain;
  };
  polynomial2.x = function(fn) {
    return arguments.length ? (x = fn, polynomial2) : x;
  };
  polynomial2.y = function(fn) {
    return arguments.length ? (y = fn, polynomial2) : y;
  };
  polynomial2.order = function(n) {
    return arguments.length ? (order = n, polynomial2) : order;
  };
  return polynomial2;
}
function uncenter(k, a, x, y) {
  var z = Array(k);
  var i, j, v, c;
  for (i = 0; i < k; ++i) {
    z[i] = 0;
  }
  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x, j) * c;
    }
  }
  z[0] += y;
  return z;
}
function gaussianElimination(matrix) {
  var n = matrix.length - 1, coef = [];
  var i, j, k, r, t;
  for (i = 0; i < n; ++i) {
    r = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
function power() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function power2(data3) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data3, x, y, function(dx, dy) {
      var lx = Math.log(dx), ly = Math.log(dy);
      ++n;
      X += (lx - X) / n;
      Y += (ly - Y) / n;
      XY += (lx * ly - XY) / n;
      X2 += (lx * lx - X2) / n;
      YS += (dy - YS) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
    a = Math.exp(a);
    var fn = function fn2(x2) {
      return a * Math.pow(x2, b);
    }, out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data3, x, y, YS, fn);
    return out;
  }
  power2.domain = function(arr) {
    return arguments.length ? (domain = arr, power2) : domain;
  };
  power2.x = function(fn) {
    return arguments.length ? (x = fn, power2) : x;
  };
  power2.y = function(fn) {
    return arguments.length ? (y = fn, power2) : y;
  };
  return power2;
}

// node_modules/@antv/g2plot/esm/plots/scatter/util.js
var REGRESSION_MAP = {
  exp: exponential2,
  linear: linear4,
  loess,
  log: logarithmic,
  poly: polynomial,
  pow: power,
  quad
};
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  var textOffset = 10;
  var defaultConfig = {
    regionStyle: [
      {
        position: {
          start: [xBaseline, "max"],
          end: ["max", yBaseline]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", "max"],
          end: [xBaseline, yBaseline]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", yBaseline],
          end: [xBaseline, "min"]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: [xBaseline, yBaseline],
          end: ["max", "min"]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      }
    ],
    lineStyle: {
      stroke: "#9ba29a",
      lineWidth: 1
    },
    labelStyle: [
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "right",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "left",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "left",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "right",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      }
    ]
  };
  return defaultConfig;
}
var splinePath = function(data3, config) {
  var view = config.view, _a6 = config.options, xField = _a6.xField, yField = _a6.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data3.map(function(d) {
    return view.getCoordinate().convert({ x: xScaleView.scale(d[0]), y: yScaleView.scale(d[1]) });
  });
  return getSplinePath2(pathData, false);
};
var getPath4 = function(config) {
  var options = config.options;
  var xField = options.xField, yField = options.yField, data3 = options.data, regressionLine2 = options.regressionLine;
  var _a6 = regressionLine2.type, type = _a6 === void 0 ? "linear" : _a6, algorithm = regressionLine2.algorithm, customEquation = regressionLine2.equation;
  var pathData;
  var equation = null;
  if (algorithm) {
    pathData = is_array_default(algorithm) ? algorithm : algorithm(data3);
    equation = customEquation;
  } else {
    var reg = REGRESSION_MAP[type]().x(function(d) {
      return d[xField];
    }).y(function(d) {
      return d[yField];
    });
    pathData = reg(data3);
    equation = getRegressionEquation(type, pathData);
  }
  return [splinePath(pathData, config), equation];
};
var getMeta = function(options) {
  var _a6;
  var _b = options.meta, meta23 = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data3 = options.data;
  var xFieldValue = data3[0][xField];
  var yFieldValue = data3[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;
  function getMetaMinMax(field6, axis22) {
    var fieldMeta = get_default(meta23, [field6]);
    function getCustomValue(type) {
      return get_default(fieldMeta, type);
    }
    var range2 = {};
    if (axis22 === "x") {
      if (is_number_default(xFieldValue)) {
        if (!is_number_default(getCustomValue("min"))) {
          range2["min"] = xIsPositiveNumber ? 0 : xFieldValue * 2;
        }
        if (!is_number_default(getCustomValue("max"))) {
          range2["max"] = xIsPositiveNumber ? xFieldValue * 2 : 0;
        }
      }
      return range2;
    }
    if (is_number_default(yFieldValue)) {
      if (!is_number_default(getCustomValue("min"))) {
        range2["min"] = yIsPositiveNumber ? 0 : yFieldValue * 2;
      }
      if (!is_number_default(getCustomValue("max"))) {
        range2["max"] = yIsPositiveNumber ? yFieldValue * 2 : 0;
      }
    }
    return range2;
  }
  return __assign(__assign({}, meta23), (_a6 = {}, _a6[xField] = __assign(__assign({}, meta23[xField]), getMetaMinMax(xField, "x")), _a6[yField] = __assign(__assign({}, meta23[yField]), getMetaMinMax(yField, "y")), _a6));
};
function getRegressionEquation(type, res) {
  var _a6, _b, _c;
  var roundByPrecision = function(n, p) {
    if (p === void 0) {
      p = 4;
    }
    return Math.round(n * Math.pow(10, p)) / Math.pow(10, p);
  };
  var safeFormat = function(value2) {
    return Number.isFinite(value2) ? roundByPrecision(value2) : "?";
  };
  switch (type) {
    case "linear":
      return "y = ".concat(safeFormat(res.a), "x + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "exp":
      return "y = ".concat(safeFormat(res.a), "e^(").concat(safeFormat(res.b), "x), R^2 = ").concat(safeFormat(res.rSquared));
    case "log":
      return "y = ".concat(safeFormat(res.a), "ln(x) + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "quad":
      return "y = ".concat(safeFormat(res.a), "x^2 + ").concat(safeFormat(res.b), "x + ").concat(safeFormat(res.c), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "poly":
      var temp = "y = ".concat(safeFormat((_a6 = res.coefficients) === null || _a6 === void 0 ? void 0 : _a6[0]), " + ").concat(safeFormat((_b = res.coefficients) === null || _b === void 0 ? void 0 : _b[1]), "x + ").concat(safeFormat((_c = res.coefficients) === null || _c === void 0 ? void 0 : _c[2]), "x^2");
      for (var i = 3; i < res.coefficients.length; ++i) {
        temp += " + ".concat(safeFormat(res.coefficients[i]), "x^").concat(i);
      }
      return "".concat(temp, ", R^2 = ").concat(safeFormat(res.rSquared));
    case "pow":
      return "y = ".concat(safeFormat(res.a), "x^").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
  }
  return null;
}

// node_modules/@antv/g2plot/esm/plots/scatter/adaptor.js
function transformOptions(options) {
  var _a6 = options.data, data3 = _a6 === void 0 ? [] : _a6, xField = options.xField, yField = options.yField;
  if (data3.length) {
    var isOneX = true;
    var isOneY = true;
    var prev = data3[0];
    var curr = void 0;
    for (var i = 1; i < data3.length; i++) {
      curr = data3[i];
      if (prev[xField] !== curr[xField]) {
        isOneX = false;
      }
      if (prev[yField] !== curr[yField]) {
        isOneY = false;
      }
      if (!isOneX && !isOneY) {
        break;
      }
      prev = curr;
    }
    var keys3 = [];
    isOneX && keys3.push(xField);
    isOneY && keys3.push(yField);
    var meta_1 = pick(getMeta(options), keys3);
    return deepAssign({}, options, { meta: meta_1 });
  }
  return options;
}
function geometry15(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, type = options.type, color3 = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
  var size3 = options.size;
  var tooltip11 = options.tooltip;
  if (sizeField) {
    if (!size3) {
      size3 = [2, 8];
    }
    if (is_number_default(size3)) {
      size3 = [size3, size3];
    }
  }
  if (tooltip11 && !tooltip11.fields) {
    tooltip11 = __assign(__assign({}, tooltip11), { fields: [xField, yField, colorField, sizeField, shapeField] });
  }
  chart.data(data3);
  point(deepAssign({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color3,
        shape,
        size: size3,
        style: pointStyle
      },
      tooltip: tooltip11
    }
  }));
  var geometry35 = findGeometry(chart, "point");
  if (type) {
    geometry35.adjust(type);
  }
  return params;
}
function meta7(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var newOptions = transformOptions(options);
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6)))(deepAssign({}, params, { options: newOptions }));
}
function axis5(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function legend6(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
  var showLegend = legend18 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend18 : false);
  }
  if (shapeField) {
    if (shapeLegend) {
      chart.legend(shapeField, shapeLegend);
    } else {
      chart.legend(shapeField, shapeLegend === false ? false : legend18);
    }
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend ? sizeLegend : false);
  }
  if (!showLegend && !shapeLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label7(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField;
  var scatterGeometry = findGeometry(chart, "point");
  if (!label17) {
    scatterGeometry.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];
  if (quadrant) {
    var _a6 = quadrant.xBaseline, xBaseline = _a6 === void 0 ? 0 : _a6, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
    var quadrants = new Array(4).join(",").split(",");
    quadrants.forEach(function(_, index) {
      annotationOptions.push(__assign(__assign({ type: "region", top: false }, defaultConfig_1.regionStyle[index].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index]) }), __assign({ type: "text", top: true }, deepAssign({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
    });
    annotationOptions.push({
      type: "line",
      top: false,
      start: ["min", yBaseline],
      end: ["max", yBaseline],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: "line",
      top: false,
      start: [xBaseline, "min"],
      end: [xBaseline, "max"],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }
  return flow(annotation(annotationOptions))(params);
}
function regressionLine(params) {
  var options = params.options, chart = params.chart;
  var regressionLine2 = options.regressionLine;
  if (regressionLine2) {
    var style_1 = regressionLine2.style, _a6 = regressionLine2.equationStyle, equationStyle_1 = _a6 === void 0 ? {} : _a6, _b = regressionLine2.top, top_1 = _b === void 0 ? false : _b, _c = regressionLine2.showEquation, showEquation_1 = _c === void 0 ? false : _c;
    var defaultStyle_1 = {
      stroke: "#9ba29a",
      lineWidth: 2,
      opacity: 0.5
    };
    var defaulEquationStyle_1 = {
      x: 20,
      y: 20,
      textAlign: "left",
      textBaseline: "middle",
      fontSize: 14,
      fillOpacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function(container, view) {
        var group2 = container.addGroup({
          id: "".concat(chart.id, "-regression-line"),
          name: "regression-line-group"
        });
        var _a7 = getPath4({
          view,
          options
        }), path = _a7[0], equation = _a7[1];
        group2.addShape("path", {
          name: "regression-line",
          attrs: __assign(__assign({ path }, defaultStyle_1), style_1)
        });
        if (showEquation_1) {
          group2.addShape("text", {
            name: "regression-equation",
            attrs: __assign(__assign(__assign({}, defaulEquationStyle_1), equationStyle_1), { text: equation })
          });
        }
      }
    });
  }
  return params;
}
function tooltip4(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11) {
    chart.tooltip(tooltip11);
  } else if (tooltip11 === false) {
    chart.tooltip(false);
  }
  return params;
}
function adaptor11(params) {
  return flow(
    geometry15,
    meta7,
    axis5,
    legend6,
    tooltip4,
    label7,
    //  interaction 
    brushInteraction,
    slider,
    scrollbar,
    interaction,
    scatterAnnotation,
    animation,
    theme,
    regressionLine
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/scatter/constant.js
var DEFAULT_OPTIONS11 = deepAssign({}, Plot.getDefaultOptions(), {
  size: 4,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: true,
    crosshairs: {
      type: "xy"
    }
  }
});

// node_modules/@antv/g2plot/esm/interactions/drag-move.js
registerInteraction("drag-move", {
  start: [{ trigger: "plot:mousedown", action: "scale-translate:start" }],
  processing: [
    {
      trigger: "plot:mousemove",
      action: "scale-translate:translate",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ],
  end: [{ trigger: "plot:mouseup", action: "scale-translate:end" }]
});

// node_modules/@antv/g2plot/esm/plots/scatter/index.js
var Scatter = (
  /** @class */
  function(_super) {
    __extends(Scatter2, _super);
    function Scatter2(container, options) {
      var _this = _super.call(this, container, options) || this;
      _this.type = "scatter";
      _this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function(evt) {
        var _a6, _b;
        var _c = _this, options2 = _c.options, chart = _c.chart;
        if (((_a6 = evt.data) === null || _a6 === void 0 ? void 0 : _a6.source) === EVENTS3.FILTER) {
          var filteredData = _this.chart.filterData(_this.chart.getData());
          meta7({ chart, options: __assign(__assign({}, options2), { data: filteredData }) });
        }
        if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === EVENTS3.RESET) {
          meta7({ chart, options: options2 });
        }
      });
      return _this;
    }
    Scatter2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS11;
    };
    Scatter2.prototype.changeData = function(data3) {
      this.updateOption(transformOptions(deepAssign({}, this.options, { data: data3 })));
      var _a6 = this, options = _a6.options, chart = _a6.chart;
      meta7({ chart, options });
      this.chart.changeData(data3);
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/stock/constant.js
var Y_FIELD = "$$stock-range$$";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
var DEFAULT_TOOLTIP_OPTIONS = {
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: "xy",
    follow: true,
    text: function(type, defaultContent, items) {
      var textContent;
      if (type === "x") {
        var item = items[0];
        textContent = item ? item.title : defaultContent;
      } else {
        textContent = defaultContent;
      }
      return {
        position: type === "y" ? "start" : "end",
        content: textContent,
        style: {
          fill: "#dfdfdf"
        }
      };
    },
    //  crosshairs textBackground 
    textBackground: {
      padding: [2, 4],
      style: {
        fill: "#666"
      }
    }
  }
};
var DEFAULT_OPTIONS12 = deepAssign({}, Plot.getDefaultOptions(), {
  //  tooltips
  tooltip: DEFAULT_TOOLTIP_OPTIONS,
  interactions: [{ type: "tooltip" }],
  legend: {
    position: "top-left"
  },
  risingFill: "#ef5350",
  fallingFill: "#26a69a"
});

// node_modules/@antv/g2plot/esm/plots/stock/utils.js
function getStockData(data3, yField) {
  return map_default(data3, function(item) {
    var obj = item && __assign({}, item);
    if (is_array_default(yField) && obj) {
      var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
      obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
      obj[Y_FIELD] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }
    return obj;
  });
}

// node_modules/@antv/g2plot/esm/plots/stock/adaptor.js
function geometry16(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField;
  var data3 = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip11 = options.tooltip, stockStyle = options.stockStyle;
  chart.data(getStockData(data3, yField));
  var tooltipOptions = tooltip11;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
  }
  schema(deepAssign({}, params, {
    options: {
      schema: {
        shape: "candle",
        color: [risingFill, fallingFill],
        style: stockStyle
      },
      yField: Y_FIELD,
      seriesField: TREND_FIELD,
      rawFields: yField,
      tooltip: tooltipOptions
    }
  }));
  return params;
}
function meta8(params) {
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var meta23 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  var baseMeta = (_a6 = {}, _a6[xField] = {
    type: "timeCat",
    tickCount: 6
  }, _a6[TREND_FIELD] = {
    values: [TREND_UP, TREND_DOWN]
  }, _a6);
  var scales = deepAssign(baseMeta, meta23, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[Y_FIELD] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis6(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(Y_FIELD, false);
  } else {
    chart.axis(Y_FIELD, yAxis);
  }
  return params;
}
function tooltip5(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11 !== false) {
    chart.tooltip(tooltip11);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function legend7(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend;
  if (legend18) {
    chart.legend(TREND_FIELD, legend18);
  } else if (legend18 === false) {
    chart.legend(false);
  }
  return params;
}
function adaptor12(params) {
  flow(theme, geometry16, meta8, axis6, tooltip5, legend7, interaction, animation, annotation(), slider)(params);
}

// node_modules/@antv/g2plot/esm/plots/stock/index.js
var Stock = (
  /** @class */
  function(_super) {
    __extends(Stock2, _super);
    function Stock2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "stock";
      return _this;
    }
    Stock2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS12;
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    Stock2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var yField = this.options.yField;
      this.chart.changeData(getStockData(data3, yField));
    };
    return Stock2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/tiny-line/utils.js
function getTinyData(data3) {
  return map_default(data3 || [], function(y, x) {
    return { x: "".concat(x), y };
  });
}

// node_modules/@antv/g2plot/esm/plots/tiny-line/constants.js
var X_FIELD = "x";
var Y_FIELD2 = "y";
var DEFAULT_TOOLTIP_OPTIONS2 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data3) {
    return "".concat(get_default(data3, [0, "data", "y"], 0));
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: "x"
  }
};
var DEFAULT_OPTIONS13 = {
  appendPadding: 2,
  tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS2),
  animation: {}
};

// node_modules/@antv/g2plot/esm/plots/tiny-area/adaptor.js
function geometry17(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, color3 = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = getTinyData(data3);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD,
      yField: Y_FIELD2,
      area: { color: color3, style: areaStyle },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false } });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(second);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta9(params) {
  var _a6, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, data3 = options.data;
  var seriesData = getTinyData(data3);
  return flow(scale5((_a6 = {}, _a6[X_FIELD] = xAxis, _a6[Y_FIELD2] = yAxis, _a6), (_b = {}, _b[X_FIELD] = {
    type: "cat"
  }, _b[Y_FIELD2] = adjustYMetaByZero(seriesData, Y_FIELD2), _b)))(params);
}
function adaptor13(params) {
  return flow(pattern("areaStyle"), geometry17, meta9, tooltip, theme, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/tiny-area/constants.js
var DEFAULT_OPTIONS14 = {
  appendPadding: 2,
  tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS2),
  // 
  color: "l(90) 0:#E5EDFE 1:#ffffff",
  areaStyle: {
    fillOpacity: 0.6
  },
  line: {
    size: 1,
    color: "#5B8FF9"
  },
  animation: {}
};

// node_modules/@antv/g2plot/esm/plots/tiny-area/index.js
var TinyArea = (
  /** @class */
  function(_super) {
    __extends(TinyArea2, _super);
    function TinyArea2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-area";
      return _this;
    }
    TinyArea2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS14;
    };
    TinyArea2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this, chart = _a6.chart, options = _a6.options;
      meta9({ chart, options });
      chart.changeData(getTinyData(data3));
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/tiny-column/adaptor.js
function geometry18(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, color3 = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
  var seriesData = getTinyData(data3);
  chart.data(seriesData);
  var p = deepAssign({}, params, {
    options: {
      xField: X_FIELD,
      yField: Y_FIELD2,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color3
      }
    }
  });
  interval2(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction("element-active");
  return params;
}
function adaptor14(params) {
  return flow(theme, pattern("columnStyle"), geometry18, meta9, tooltip, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/tiny-column/constants.js
var DEFAULT_TOOLTIP_OPTIONS3 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data3) {
    return "".concat(get_default(data3, [0, "data", "y"], 0));
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  }
};
var DEFAULT_OPTIONS15 = {
  appendPadding: 2,
  tooltip: __assign({}, DEFAULT_TOOLTIP_OPTIONS3),
  animation: {}
};

// node_modules/@antv/g2plot/esm/plots/tiny-column/index.js
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends(TinyColumn2, _super);
    function TinyColumn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-column";
      return _this;
    }
    TinyColumn2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS15;
    };
    TinyColumn2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this, chart = _a6.chart, options = _a6.options;
      meta9({ chart, options });
      chart.changeData(getTinyData(data3));
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/tiny-line/adaptor.js
function geometry19(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, color3 = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var seriesData = getTinyData(data3);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD,
      yField: Y_FIELD2,
      line: {
        color: color3,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function adaptor15(params) {
  return flow(geometry19, meta9, theme, tooltip, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/tiny-line/index.js
var TinyLine = (
  /** @class */
  function(_super) {
    __extends(TinyLine2, _super);
    function TinyLine2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-line";
      return _this;
    }
    TinyLine2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS13;
    };
    TinyLine2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = this, chart = _a6.chart, options = _a6.options;
      meta9({ chart, options });
      chart.changeData(getTinyData(data3));
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/mix/utils.js
var PLOT_ADAPTORS = {
  line: adaptor,
  pie: adaptor8,
  column: adaptor3,
  bar: adaptor4,
  area: adaptor2,
  gauge: adaptor6,
  "tiny-line": adaptor15,
  "tiny-column": adaptor14,
  "tiny-area": adaptor13,
  "ring-progress": adaptor10,
  progress: adaptor9,
  scatter: adaptor11,
  histogram: adaptor7,
  funnel: adaptor5,
  stock: adaptor12
};
var PLOT_CONSTRUCTOR = {
  line: Line6,
  pie: Pie,
  column: Column,
  bar: Bar,
  area: Area2,
  gauge: Gauge,
  "tiny-line": TinyLine,
  "tiny-column": TinyColumn,
  "tiny-area": TinyArea,
  "ring-progress": RingProgress,
  progress: Progress,
  scatter: Scatter,
  histogram: Histogram,
  funnel: Funnel,
  stock: Stock
};
var DEFAULT_OPTIONS_MAP = {
  pie: { label: false },
  column: { tooltip: { showMarkers: false } },
  bar: { tooltip: { showMarkers: false } }
};
function execPlotAdaptor(plot, view, options) {
  var cls = PLOT_CONSTRUCTOR[plot];
  if (!cls) {
    console.error("could not find ".concat(plot, " plot"));
    return;
  }
  var module2 = PLOT_ADAPTORS[plot];
  module2({
    chart: view,
    options: deepAssign({}, cls.getDefaultOptions(), get_default(DEFAULT_OPTIONS_MAP, plot, {}), options)
  });
}

// node_modules/@antv/g2plot/esm/plots/mix/adaptor.js
function multiView(params) {
  var chart = params.chart, options = params.options;
  var views = options.views, legend18 = options.legend;
  each_default(views, function(v) {
    var region = v.region, data3 = v.data, meta23 = v.meta, axes = v.axes, coordinate11 = v.coordinate, interactions = v.interactions, annotations = v.annotations, tooltip11 = v.tooltip, geometries = v.geometries;
    var viewOfG2 = chart.createView({
      region
    });
    viewOfG2.data(data3);
    var scales = {};
    if (axes) {
      each_default(axes, function(axis22, field6) {
        scales[field6] = pick(axis22, AXIS_META_CONFIG_KEYS);
      });
    }
    scales = deepAssign({}, meta23, scales);
    viewOfG2.scale(scales);
    if (!axes) {
      viewOfG2.axis(false);
    } else {
      each_default(axes, function(axis22, field6) {
        viewOfG2.axis(field6, axis22);
      });
    }
    viewOfG2.coordinate(coordinate11);
    each_default(geometries, function(geometry35) {
      var ext = geometry({
        chart: viewOfG2,
        options: geometry35
      }).ext;
      var adjust3 = geometry35.adjust;
      if (adjust3) {
        ext.geometry.adjust(adjust3);
      }
    });
    each_default(interactions, function(interaction10) {
      if (interaction10.enable === false) {
        viewOfG2.removeInteraction(interaction10.type);
      } else {
        viewOfG2.interaction(interaction10.type, interaction10.cfg);
      }
    });
    each_default(annotations, function(annotation4) {
      viewOfG2.annotation()[annotation4.type](__assign({}, annotation4));
    });
    if (typeof v.animation === "boolean") {
      viewOfG2.animate(false);
    } else {
      viewOfG2.animate(true);
      each_default(viewOfG2.geometries, function(g) {
        g.animate(v.animation);
      });
    }
    if (tooltip11) {
      viewOfG2.interaction("tooltip");
      viewOfG2.tooltip(tooltip11);
    }
  });
  if (!legend18) {
    chart.legend(false);
  } else {
    each_default(legend18, function(l, field6) {
      chart.legend(field6, l);
    });
  }
  chart.tooltip(options.tooltip);
  return params;
}
function multiPlot(params) {
  var chart = params.chart, options = params.options;
  var plots = options.plots, _a6 = options.data, data3 = _a6 === void 0 ? [] : _a6;
  each_default(plots, function(plot) {
    var type = plot.type, region = plot.region, _a7 = plot.options, options2 = _a7 === void 0 ? {} : _a7, top = plot.top;
    var tooltip11 = options2.tooltip;
    if (top) {
      execPlotAdaptor(type, chart, __assign(__assign({}, options2), { data: data3 }));
      return;
    }
    var viewOfG2 = chart.createView(__assign({ region }, pick(options2, PLOT_CONTAINER_OPTIONS)));
    if (tooltip11) {
      viewOfG2.interaction("tooltip");
    }
    execPlotAdaptor(type, viewOfG2, __assign({ data: data3 }, options2));
  });
  return params;
}
function slider2(params) {
  var chart = params.chart, options = params.options;
  chart.option("slider", options.slider);
  return params;
}
function adaptor16(params) {
  return flow(
    animation,
    //  view 
    multiView,
    multiPlot,
    interaction,
    animation,
    theme,
    tooltip,
    slider2,
    annotation()
    // ...  adaptor flow
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/mix/interactions/utils.js
function getElementValue2(element, field6) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (is_array_default(record)) {
    value2 = record[0][field6];
  } else {
    value2 = record[field6];
  }
  return value2;
}
function clearHighlight2(view) {
  var elements = getAllElements(view);
  each_default(elements, function(el) {
    if (el.hasState("active")) {
      el.setState("active", false);
    }
    if (el.hasState("selected")) {
      el.setState("selected", false);
    }
    if (el.hasState("inactive")) {
      el.setState("inactive", false);
    }
  });
}

// node_modules/@antv/g2plot/esm/plots/mix/interactions/association.js
var Association = (
  /** @class */
  function(_super) {
    __extends(Association2, _super);
    function Association2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Association2.prototype.getAssociationItems = function(views, params) {
      var _a6;
      var event = this.context.event;
      var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
      var items = [];
      if ((_a6 = event.data) === null || _a6 === void 0 ? void 0 : _a6.data) {
        var data_1 = event.data.data;
        each_default(views, function(v) {
          var _a7, _b2;
          var field6 = linkField;
          if (dim === "x") {
            field6 = v.getXScale().field;
          } else if (dim === "y") {
            field6 = (_a7 = v.getYScales().find(function(s) {
              return s.field === field6;
            })) === null || _a7 === void 0 ? void 0 : _a7.field;
          } else if (!field6) {
            field6 = (_b2 = v.getGroupScales()[0]) === null || _b2 === void 0 ? void 0 : _b2.field;
          }
          if (!field6) {
            return;
          }
          var elements = map_default(getAllElements(v), function(ele) {
            var active = false;
            var inactive = false;
            var dataValue = is_array_default(data_1) ? get_default(data_1[0], field6) : get_default(data_1, field6);
            if (getElementValue2(ele, field6) === dataValue) {
              active = true;
            } else {
              inactive = true;
            }
            return { element: ele, view: v, active, inactive };
          });
          items.push.apply(items, elements);
        });
      }
      return items;
    };
    Association2.prototype.showTooltip = function(params) {
      var siblings = getSiblingViews(this.context.view);
      var elements = this.getAssociationItems(siblings, params);
      each_default(elements, function(ele) {
        if (ele.active) {
          var box2 = ele.element.shape.getCanvasBBox();
          ele.view.showTooltip({ x: box2.minX + box2.width / 2, y: box2.minY + box2.height / 2 });
        }
      });
    };
    Association2.prototype.hideTooltip = function() {
      var siblings = getSiblingViews(this.context.view);
      each_default(siblings, function(sibling) {
        sibling.hideTooltip();
      });
    };
    Association2.prototype.active = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each_default(items, function(item) {
        var active = item.active, element = item.element;
        if (active) {
          element.setState("active", true);
        }
      });
    };
    Association2.prototype.selected = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each_default(items, function(item) {
        var active = item.active, element = item.element;
        if (active) {
          element.setState("selected", true);
        }
      });
    };
    Association2.prototype.highlight = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each_default(items, function(item) {
        var inactive = item.inactive, element = item.element;
        if (inactive) {
          element.setState("inactive", true);
        }
      });
    };
    Association2.prototype.reset = function() {
      var views = getViews(this.context.view);
      each_default(views, function(v) {
        clearHighlight2(v);
      });
    };
    return Association2;
  }(base_default12)
);
registerAction("association", Association);
registerInteraction("association-active", {
  start: [{ trigger: "element:mouseenter", action: "association:active" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-selected", {
  start: [{ trigger: "element:mouseenter", action: "association:selected" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-highlight", {
  start: [{ trigger: "element:mouseenter", action: "association:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-tooltip", {
  start: [{ trigger: "element:mousemove", action: "association:showTooltip" }],
  end: [{ trigger: "element:mouseleave", action: "association:hideTooltip" }]
});

// node_modules/@antv/g2plot/esm/plots/mix/index.js
var Mix = (
  /** @class */
  function(_super) {
    __extends(Mix2, _super);
    function Mix2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "mix";
      return _this;
    }
    Mix2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Mix2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/lab.js
var Stage;
(function(Stage2) {
  Stage2["DEV"] = "DEV";
  Stage2["BETA"] = "BETA";
  Stage2["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
function notice(stage, plotType) {
  console.warn(stage === Stage.DEV ? "Plot '".concat(plotType, "' is in DEV stage, just give us issues.") : stage === Stage.BETA ? "Plot '".concat(plotType, "' is in BETA stage, DO NOT use it in production env.") : stage === Stage.STABLE ? "Plot '".concat(plotType, `' is in STABLE stage, import it by "import { `).concat(plotType, ` } from '@antv/g2plot'".`) : "invalid Stage type.");
}
var Lab2 = (
  /** @class */
  function() {
    function Lab3() {
    }
    Object.defineProperty(Lab3, "MultiView", {
      get: function() {
        notice(Stage.STABLE, "MultiView");
        return Mix;
      },
      enumerable: false,
      configurable: true
    });
    return Lab3;
  }()
);

// node_modules/@antv/g2plot/esm/plots/bidirectional-bar/constant.js
var FIRST_AXES_VIEW = "first-axes-view";
var SECOND_AXES_VIEW = "second-axes-view";
var SERIES_FIELD_KEY = "series-field-key";

// node_modules/@antv/g2plot/esm/plots/bidirectional-bar/utils.js
function transformData2(xField, yField, seriesField, data3, reverse2) {
  var hopeData = [];
  yField.forEach(function(d) {
    data3.forEach(function(k) {
      var _a7;
      var obj = (_a7 = {}, _a7[xField] = k[xField], _a7[seriesField] = d, _a7[d] = k[d], _a7);
      hopeData.push(obj);
    });
  });
  var groupData = Object.values(group_by_default(hopeData, seriesField));
  var _a6 = groupData[0], data1 = _a6 === void 0 ? [] : _a6, _b = groupData[1], data22 = _b === void 0 ? [] : _b;
  return reverse2 ? [data1.reverse(), data22.reverse()] : [data1, data22];
}
function isHorizontal(layout2) {
  return layout2 !== "vertical";
}
function syncViewPadding(chart, views, p) {
  var v1 = views[0], v2 = views[1];
  var p1 = v1.autoPadding;
  var p2 = v2.autoPadding;
  var _a6 = chart.__axisPosition, layout2 = _a6.layout, position = _a6.position;
  if (isHorizontal(layout2) && position === "top") {
    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
  }
  if (isHorizontal(layout2) && position === "bottom") {
    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
  }
  if (!isHorizontal(layout2) && position === "bottom") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left2);
    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left2);
  }
  if (!isHorizontal(layout2) && position === "top") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, 0, left2);
    v2.autoPadding = p.instance(0, p2.right, p1.top, left2);
  }
}

// node_modules/@antv/g2plot/esm/plots/bidirectional-bar/adaptor.js
function geometry20(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, xField = options.xField, yField = options.yField, color3 = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend18 = options.legend, layout2 = options.layout;
  var groupData = transformData2(xField, yField, SERIES_FIELD_KEY, data3, isHorizontal(layout2));
  if (legend18) {
    chart.legend(SERIES_FIELD_KEY, legend18);
  } else if (legend18 === false) {
    chart.legend(false);
  }
  var firstView;
  var secondView;
  var firstViewData = groupData[0], secondViewData = groupData[1];
  if (isHorizontal(layout2)) {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 0.5, y: 1 }
      },
      id: FIRST_AXES_VIEW
    });
    firstView.coordinate().transpose().reflect("x");
    secondView = chart.createView({
      region: {
        start: { x: 0.5, y: 0 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().transpose();
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  } else {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0.5 }
      },
      id: FIRST_AXES_VIEW
    });
    secondView = chart.createView({
      region: {
        start: { x: 0, y: 0.5 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().reflect("y");
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  }
  var left2 = deepAssign({}, params, {
    chart: firstView,
    options: {
      widthRatio,
      xField,
      yField: yField[0],
      seriesField: SERIES_FIELD_KEY,
      interval: {
        color: color3,
        style: barStyle
      }
    }
  });
  interval2(left2);
  var right2 = deepAssign({}, params, {
    chart: secondView,
    options: {
      xField,
      yField: yField[1],
      seriesField: SERIES_FIELD_KEY,
      widthRatio,
      interval: {
        color: color3,
        style: barStyle
      }
    }
  });
  interval2(right2);
  return params;
}
function meta10(params) {
  var _a6, _b, _c;
  var options = params.options, chart = params.chart;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var aliasMap = {};
  keys_default((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function(metaKey) {
    if (get_default(options === null || options === void 0 ? void 0 : options.meta, [metaKey, "alias"])) {
      aliasMap[metaKey] = options.meta[metaKey].alias;
    }
  });
  chart.scale((_a6 = {}, _a6[SERIES_FIELD_KEY] = {
    sync: true,
    formatter: function(v) {
      return get_default(aliasMap, v, v);
    }
  }, _a6));
  scale5((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, { chart: firstView }));
  scale5((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, { chart: secondView }));
  return params;
}
function axis7(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === "bottom") {
    secondView.axis(xField, __assign(__assign({}, xAxis), { label: { formatter: function() {
      return "";
    } } }));
  } else {
    secondView.axis(xField, false);
  }
  if (xAxis === false) {
    firstView.axis(xField, false);
  } else {
    firstView.axis(xField, __assign({
      //  firstView 
      position: isHorizontal(layout2) ? "top" : "bottom"
    }, xAxis));
  }
  if (yAxis === false) {
    firstView.axis(yField[0], false);
    secondView.axis(yField[1], false);
  } else {
    firstView.axis(yField[0], yAxis[yField[0]]);
    secondView.axis(yField[1], yAxis[yField[1]]);
  }
  chart.__axisPosition = {
    position: firstView.getOptions().axes[xField].position,
    layout: layout2
  };
  return params;
}
function interaction4(params) {
  var chart = params.chart;
  interaction(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  interaction(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function limitInPlot3(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField, yAxis = options.yAxis;
  limitInPlot2(deepAssign({}, params, {
    chart: findViewById(chart, FIRST_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[0]]
    }
  }));
  limitInPlot2(deepAssign({}, params, {
    chart: findViewById(chart, SECOND_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[1]]
    }
  }));
  return params;
}
function theme2(params) {
  var chart = params.chart;
  theme(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  theme(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  theme(params);
  return params;
}
function animation2(params) {
  var chart = params.chart;
  animation(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  animation(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function label8(params) {
  var _this = this;
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var leftGeometry = findGeometry(firstView, "interval");
  var rightGeometry = findGeometry(secondView, "interval");
  if (!label17) {
    leftGeometry.label(false);
    rightGeometry.label(false);
  } else {
    var callback = label17.callback, cfg_1 = __rest(label17, ["callback"]);
    if (!cfg_1.position) {
      cfg_1.position = "middle";
    }
    if (cfg_1.offset === void 0) {
      cfg_1.offset = 2;
    }
    var leftLabelCfg = __assign({}, cfg_1);
    if (isHorizontal(layout2)) {
      var textAlign = ((_a6 = leftLabelCfg.style) === null || _a6 === void 0 ? void 0 : _a6.textAlign) || (cfg_1.position === "middle" ? "center" : "left");
      cfg_1.style = deepAssign({}, cfg_1.style, { textAlign });
      var textAlignMap = { left: "right", right: "left", center: "center" };
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: textAlignMap[textAlign] });
    } else {
      var positionMap_1 = { top: "bottom", bottom: "top", middle: "middle" };
      if (typeof cfg_1.position === "string") {
        cfg_1.position = positionMap_1[cfg_1.position];
      } else if (typeof cfg_1.position === "function") {
        cfg_1.position = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return positionMap_1[cfg_1.position.apply(_this, args)];
        };
      }
      var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || "bottom";
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline });
      var textBaselineMap = { top: "bottom", bottom: "top", middle: "middle" };
      cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: textBaselineMap[textBaseline] });
    }
    leftGeometry.label({
      fields: [yField[0]],
      callback,
      cfg: transformLabel(leftLabelCfg)
    });
    rightGeometry.label({
      fields: [yField[1]],
      callback,
      cfg: transformLabel(cfg_1)
    });
  }
  return params;
}
function adaptor17(params) {
  return flow(geometry20, meta10, axis7, limitInPlot3, theme2, label8, tooltip, interaction4, animation2)(params);
}

// node_modules/@antv/g2plot/esm/plots/bidirectional-bar/index.js
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bidirectional-bar";
      return _this;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return deepAssign({}, _super.getDefaultOptions.call(this), {
        syncViewPadding
      });
    };
    BidirectionalBar2.prototype.changeData = function(data3) {
      if (data3 === void 0) {
        data3 = [];
      }
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ data: data3 });
      var _a6 = this.options, xField = _a6.xField, yField = _a6.yField, layout2 = _a6.layout;
      var groupData = transformData2(xField, yField, SERIES_FIELD_KEY, data3, isHorizontal(layout2));
      var firstViewData = groupData[0], secondViewData = groupData[1];
      var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
      var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
      firstView.data(firstViewData);
      secondView.data(secondViewData);
      this.chart.render(true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    BidirectionalBar2.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/box/constant.js
var _a5;
var BOX_RANGE = "$$range$$";
var BOX_RANGE_ALIAS = "low-q1-median-q3-high";
var BOX_SYNC_NAME = "$$y_outliers$$";
var OUTLIERS_VIEW_ID = "outliers_view";
var DEFAULT_OPTIONS16 = deepAssign({}, Plot.getDefaultOptions(), {
  meta: (_a5 = {}, _a5[BOX_RANGE] = { min: 0, alias: BOX_RANGE_ALIAS }, _a5),
  // 
  interactions: [{ type: "active-region" }],
  //  tooltips  markers
  tooltip: {
    showMarkers: false,
    shared: true
  },
  boxStyle: {
    lineWidth: 1
  }
});

// node_modules/@antv/g2plot/esm/plots/box/utils.js
var transformData3 = function(data3, yField) {
  var newData = data3;
  if (Array.isArray(yField)) {
    var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
    newData = map_default(data3, function(obj) {
      obj[BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }
  return newData;
};

// node_modules/@antv/g2plot/esm/plots/box/adaptor.js
function field5(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, groupField = options.groupField, color3 = options.color, tooltip11 = options.tooltip, boxStyle = options.boxStyle;
  chart.data(transformData3(options.data, yField));
  var yFieldName = is_array_default(yField) ? BOX_RANGE : yField;
  var rawFields = yField ? is_array_default(yField) ? yField : [yField] : [];
  var tooltipOptions = tooltip11;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: is_array_default(yField) ? yField : [] }, tooltipOptions);
  }
  var ext = schema(deepAssign({}, params, {
    options: {
      xField,
      yField: yFieldName,
      seriesField: groupField,
      tooltip: tooltipOptions,
      rawFields,
      //  label
      label: false,
      schema: {
        shape: "box",
        color: color3,
        style: boxStyle
      }
    }
  })).ext;
  if (groupField) {
    ext.geometry.adjust("dodge");
  }
  return params;
}
function outliersPoint(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, data3 = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding3 = options.padding, label17 = options.label;
  if (!outliersField)
    return params;
  var outliersView = chart.createView({ padding: padding3, id: OUTLIERS_VIEW_ID });
  var outliersViewData = data3.reduce(function(ret, datum) {
    var outliersData = datum[outliersField];
    outliersData.forEach(function(d) {
      var _a6;
      return ret.push(__assign(__assign({}, datum), (_a6 = {}, _a6[outliersField] = d, _a6)));
    });
    return ret;
  }, []);
  outliersView.data(outliersViewData);
  point({
    chart: outliersView,
    options: {
      xField,
      yField: outliersField,
      point: { shape: "circle", style: outliersStyle },
      label: label17
    }
  });
  outliersView.axis(false);
  return params;
}
function meta11(params) {
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var meta23 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  var baseMeta = {};
  if (outliersField) {
    var syncName = BOX_SYNC_NAME;
    baseMeta = (_a6 = {}, _a6[outliersField] = { sync: syncName, nice: true }, _a6[yFieldName] = { sync: syncName, nice: true }, _a6);
  }
  var scales = deepAssign(baseMeta, meta23, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis8(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(BOX_RANGE, false);
  } else {
    chart.axis(yFieldName, yAxis);
  }
  return params;
}
function legend8(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, groupField = options.groupField;
  if (groupField) {
    if (legend18) {
      chart.legend(groupField, legend18);
    } else {
      chart.legend(groupField, { position: "bottom" });
    }
  } else {
    chart.legend(false);
  }
  return params;
}
function adaptor18(params) {
  return flow(field5, outliersPoint, meta11, axis8, legend8, tooltip, annotation(), interaction, animation, theme)(params);
}

// node_modules/@antv/g2plot/esm/plots/box/index.js
var Box = (
  /** @class */
  function(_super) {
    __extends(Box2, _super);
    function Box2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "box";
      return _this;
    }
    Box2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS16;
    };
    Box2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var yField = this.options.yField;
      var outliersView = this.chart.views.find(function(v) {
        return v.id === OUTLIERS_VIEW_ID;
      });
      if (outliersView) {
        outliersView.data(data3);
      }
      this.chart.changeData(transformData3(data3, yField));
    };
    Box2.prototype.getDefaultOptions = function() {
      return Box2.getDefaultOptions();
    };
    Box2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Box2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/bullet/utils.js
function getSeriesFieldKey(values3, field6, index) {
  return values3.length > 1 ? "".concat(field6, "_").concat(index) : "".concat(field6);
}
function transformData4(options) {
  var data3 = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout2 = options.layout;
  var ds = [];
  var scales = [];
  data3.forEach(function(item, index) {
    var rangeValues = [item[rangeField]].flat();
    rangeValues.sort(function(a, b) {
      return a - b;
    });
    rangeValues.forEach(function(d, i) {
      var _a6;
      var range2 = i === 0 ? d : rangeValues[i] - rangeValues[i - 1];
      ds.push((_a6 = {
        rKey: "".concat(rangeField, "_").concat(i)
      }, _a6[xField] = xField ? item[xField] : String(index), _a6[rangeField] = range2, _a6));
    });
    var measureValues = [item[measureField]].flat();
    measureValues.forEach(function(d, i) {
      var _a6;
      ds.push((_a6 = {
        mKey: getSeriesFieldKey(measureValues, measureField, i)
      }, _a6[xField] = xField ? item[xField] : String(index), _a6[measureField] = d, _a6));
    });
    var targetValues = [item[targetField]].flat();
    targetValues.forEach(function(d, i) {
      var _a6;
      ds.push((_a6 = {
        tKey: getSeriesFieldKey(targetValues, targetField, i)
      }, _a6[xField] = xField ? item[xField] : String(index), _a6[targetField] = d, _a6));
    });
    scales.push(item[rangeField], item[measureField], item[targetField]);
  });
  var min5 = Math.min.apply(Math, scales.flat(Infinity));
  var max5 = Math.max.apply(Math, scales.flat(Infinity));
  min5 = min5 > 0 ? 0 : min5;
  if (layout2 === "vertical") {
    ds.reverse();
  }
  return { min: min5, max: max5, ds };
}

// node_modules/@antv/g2plot/esm/plots/bullet/adaptor.js
function geometry21(params) {
  var chart = params.chart, options = params.options;
  var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color3 = options.color, layout2 = options.layout, size3 = options.size, label17 = options.label;
  var _a6 = transformData4(options), min5 = _a6.min, max5 = _a6.max, ds = _a6.ds;
  chart.data(ds);
  var r = deepAssign({}, params, {
    options: {
      xField,
      yField: rangeField,
      seriesField: "rKey",
      isStack: true,
      label: get_default(label17, "range"),
      interval: {
        color: get_default(color3, "range"),
        style: get_default(bulletStyle, "range"),
        size: get_default(size3, "range")
      }
    }
  });
  interval2(r);
  chart.geometries[0].tooltip(false);
  var m = deepAssign({}, params, {
    options: {
      xField,
      yField: measureField,
      seriesField: "mKey",
      isStack: true,
      label: get_default(label17, "measure"),
      interval: {
        color: get_default(color3, "measure"),
        style: get_default(bulletStyle, "measure"),
        size: get_default(size3, "measure")
      }
    }
  });
  interval2(m);
  var t = deepAssign({}, params, {
    options: {
      xField,
      yField: targetField,
      seriesField: "tKey",
      label: get_default(label17, "target"),
      point: {
        color: get_default(color3, "target"),
        style: get_default(bulletStyle, "target"),
        size: is_function_default(get_default(size3, "target")) ? function(data3) {
          return get_default(size3, "target")(data3) / 2;
        } : get_default(size3, "target") / 2,
        shape: layout2 === "horizontal" ? "line" : "hyphen"
      }
    }
  });
  point(t);
  if (layout2 === "horizontal") {
    chart.coordinate().transpose();
  }
  return __assign(__assign({}, params), { ext: { data: { min: min5, max: max5 } } });
}
function meta12(params) {
  var _a6, _b;
  var options = params.options, ext = params.ext;
  var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
  var extData = ext.data;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[measureField] = yAxis, _a6), (_b = {}, _b[measureField] = { min: extData === null || extData === void 0 ? void 0 : extData.min, max: extData === null || extData === void 0 ? void 0 : extData.max, sync: true }, _b[targetField] = {
    sync: "".concat(measureField)
  }, _b[rangeField] = {
    sync: "".concat(measureField)
  }, _b)))(params);
}
function axis9(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
  chart.axis("".concat(rangeField), false);
  chart.axis("".concat(targetField), false);
  if (xAxis === false) {
    chart.axis("".concat(xField), false);
  } else {
    chart.axis("".concat(xField), xAxis);
  }
  if (yAxis === false) {
    chart.axis("".concat(measureField), false);
  } else {
    chart.axis("".concat(measureField), yAxis);
  }
  return params;
}
function legend9(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend;
  chart.removeInteraction("legend-filter");
  chart.legend(legend18);
  chart.legend("rKey", false);
  chart.legend("mKey", false);
  chart.legend("tKey", false);
  return params;
}
function label9(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
  var _a6 = chart.geometries, rangeGeometry = _a6[0], measureGeometry = _a6[1], targetGeometry = _a6[2];
  if (get_default(label17, "range")) {
    rangeGeometry.label("".concat(rangeField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label17.range)));
  } else {
    rangeGeometry.label(false);
  }
  if (get_default(label17, "measure")) {
    measureGeometry.label("".concat(measureField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label17.measure)));
  } else {
    measureGeometry.label(false);
  }
  if (get_default(label17, "target")) {
    targetGeometry.label("".concat(targetField), __assign({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label17.target)));
  } else {
    targetGeometry.label(false);
  }
  return params;
}
function adaptor19(params) {
  flow(geometry21, meta12, axis9, legend9, theme, label9, tooltip, interaction, animation)(params);
}

// node_modules/@antv/g2plot/esm/plots/bullet/constant.js
var DEFAULT_OPTIONS17 = deepAssign({}, Plot.getDefaultOptions(), {
  layout: "horizontal",
  size: {
    range: 30,
    measure: 20,
    target: 20
  },
  xAxis: {
    tickLine: false,
    line: null
  },
  bulletStyle: {
    range: {
      fillOpacity: 0.5
    }
  },
  label: {
    measure: {
      position: "right"
    }
  },
  tooltip: {
    // 
    showMarkers: false
  }
});

// node_modules/@antv/g2plot/esm/plots/bullet/index.js
var Bullet = (
  /** @class */
  function(_super) {
    __extends(Bullet2, _super);
    function Bullet2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bullet";
      return _this;
    }
    Bullet2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS17;
    };
    Bullet2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = transformData4(this.options), min5 = _a6.min, max5 = _a6.max, ds = _a6.ds;
      meta12({ options: this.options, ext: { data: { min: min5, max: max5 } }, chart: this.chart });
      this.chart.changeData(ds);
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/utils/transform/chord.js
var DEFAULT_OPTIONS18 = {
  y: 0,
  nodeWidthRatio: 0.05,
  weight: false,
  nodePaddingRatio: 0.1,
  id: function(node) {
    return node.id;
  },
  source: function(edge2) {
    return edge2.source;
  },
  target: function(edge2) {
    return edge2.target;
  },
  sourceWeight: function(edge2) {
    return edge2.value || 1;
  },
  targetWeight: function(edge2) {
    return edge2.value || 1;
  },
  sortBy: null
  // optional, id | weight | frequency | {function}
};
function processGraph(nodeById, edges, options) {
  for_in_default(nodeById, function(node, id) {
    node.inEdges = edges.filter(function(edge2) {
      return "".concat(options.target(edge2)) === "".concat(id);
    });
    node.outEdges = edges.filter(function(edge2) {
      return "".concat(options.source(edge2)) === "".concat(id);
    });
    node.edges = node.outEdges.concat(node.inEdges);
    node.frequency = node.edges.length;
    node.value = 0;
    node.inEdges.forEach(function(edge2) {
      node.value += options.targetWeight(edge2);
    });
    node.outEdges.forEach(function(edge2) {
      node.value += options.sourceWeight(edge2);
    });
  });
}
function sortNodes(nodes, options) {
  var sortMethods = {
    weight: function(a, b) {
      return b.value - a.value;
    },
    frequency: function(a, b) {
      return b.frequency - a.frequency;
    },
    id: function(a, b) {
      return "".concat(options.id(a)).localeCompare("".concat(options.id(b)));
    }
  };
  var method2 = sortMethods[options.sortBy];
  if (!method2 && is_function_default(options.sortBy)) {
    method2 = options.sortBy;
  }
  if (method2) {
    nodes.sort(method2);
  }
}
function layoutNodes(nodes, options) {
  var len3 = nodes.length;
  if (!len3) {
    throw new TypeError("Invalid nodes: it's empty!");
  }
  if (options.weight) {
    var nodePaddingRatio_1 = options.nodePaddingRatio;
    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
      throw new TypeError("Invalid nodePaddingRatio: it must be in range [0, 1)!");
    }
    var margin_1 = nodePaddingRatio_1 / (2 * len3);
    var nodeWidthRatio_1 = options.nodeWidthRatio;
    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
      throw new TypeError("Invalid nodeWidthRatio: it must be in range (0, 1)!");
    }
    var totalValue_1 = 0;
    nodes.forEach(function(node) {
      totalValue_1 += node.value;
    });
    nodes.forEach(function(node) {
      node.weight = node.value / totalValue_1;
      node.width = node.weight * (1 - nodePaddingRatio_1);
      node.height = nodeWidthRatio_1;
    });
    nodes.forEach(function(node, index) {
      var deltaX = 0;
      for (var i = index - 1; i >= 0; i--) {
        deltaX += nodes[i].width + 2 * margin_1;
      }
      var minX = node.minX = margin_1 + deltaX;
      var maxX = node.maxX = node.minX + node.width;
      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
      var maxY2 = node.maxY = minY + nodeWidthRatio_1;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
    });
  } else {
    var deltaX_1 = 1 / len3;
    nodes.forEach(function(node, index) {
      node.x = (index + 0.5) * deltaX_1;
      node.y = options.y;
    });
  }
  return nodes;
}
function locatingEdges(nodeById, edges, options) {
  if (options.weight) {
    var valueById_1 = {};
    for_in_default(nodeById, function(node, id) {
      valueById_1[id] = node.value;
    });
    edges.forEach(function(edge2) {
      var sId = options.source(edge2);
      var tId = options.target(edge2);
      var sNode = nodeById[sId];
      var tNode = nodeById[tId];
      if (sNode && tNode) {
        var sValue = valueById_1[sId];
        var currentSValue = options.sourceWeight(edge2);
        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
        var sEnd = sStart + currentSValue / sNode.value * sNode.width;
        valueById_1[sId] -= currentSValue;
        var tValue = valueById_1[tId];
        var currentTValue = options.targetWeight(edge2);
        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
        var tEnd = tStart + currentTValue / tNode.value * tNode.width;
        valueById_1[tId] -= currentTValue;
        var y = options.y;
        edge2.x = [sStart, sEnd, tStart, tEnd];
        edge2.y = [y, y, y, y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  } else {
    edges.forEach(function(edge2) {
      var sNode = nodeById[options.source(edge2)];
      var tNode = nodeById[options.target(edge2)];
      if (sNode && tNode) {
        edge2.x = [sNode.x, tNode.x];
        edge2.y = [sNode.y, tNode.y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  }
  return edges;
}
function getDefaultOptions(options) {
  return mix({}, DEFAULT_OPTIONS18, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
  var options = getDefaultOptions(chordLayoutOptions);
  var nodeById = {};
  var nodes = chordLayoutInputData.nodes;
  var links = chordLayoutInputData.links;
  nodes.forEach(function(node) {
    var id = options.id(node);
    nodeById[id] = node;
  });
  processGraph(nodeById, links, options);
  sortNodes(nodes, options);
  var outputNodes = layoutNodes(nodes, options);
  var outputLinks = locatingEdges(nodeById, links, options);
  return {
    nodes: outputNodes,
    links: outputLinks
  };
}

// node_modules/@antv/g2plot/esm/plots/chord/constant.js
var X_FIELD2 = "x";
var Y_FIELD3 = "y";
var NODE_COLOR_FIELD = "name";
var EDGE_COLOR_FIELD = "source";
var DEFAULT_OPTIONS19 = {
  nodeStyle: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  },
  edgeStyle: {
    opacity: 0.5,
    lineWidth: 2
  },
  label: {
    fields: ["x", "name"],
    callback: function(x, name) {
      var centerX = (x[0] + x[1]) / 2;
      var offsetX = centerX > 0.5 ? -4 : 4;
      return {
        offsetX,
        content: name
      };
    },
    labelEmit: true,
    style: {
      fill: "#8c8c8c"
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["source", "target", "value", "isNode"],
    // node  tooltip ()edge  tooltip
    showContent: function(items) {
      return !get_default(items, [0, "data", "isNode"]);
    },
    formatter: function(datum) {
      var source = datum.source, target = datum.target, value2 = datum.value;
      return {
        name: "".concat(source, " -> ").concat(target),
        value: value2
      };
    }
  },
  interactions: [
    {
      type: "element-active"
    }
  ],
  weight: true,
  nodePaddingRatio: 0.1,
  nodeWidthRatio: 0.05
};

// node_modules/@antv/g2plot/esm/plots/chord/adaptor.js
function transformData5(params) {
  var options = params.options;
  var data3 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6;
  var chordLayoutInputData = transformDataToNodeLinkData(data3, sourceField, targetField, weightField);
  var _b = chordLayout({ weight: true, nodePaddingRatio, nodeWidthRatio }, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
  var nodesData = nodes.map(function(node) {
    return __assign(__assign({}, pick(node, __spreadArray(["id", "x", "y", "name"], rawFields, true))), { isNode: true });
  });
  var edgesData = links.map(function(link) {
    return __assign(__assign({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArray(["x", "y", "value"], rawFields, true))), { isNode: false });
  });
  return __assign(__assign({}, params), { ext: __assign(__assign({}, params.ext), {
    // chordDataextgeometry
    chordData: { nodesData, edgesData }
  }) });
}
function scale6(params) {
  var _a6;
  var chart = params.chart;
  chart.scale((_a6 = {
    x: { sync: true, nice: true },
    y: { sync: true, nice: true, max: 1 }
  }, _a6[NODE_COLOR_FIELD] = { sync: "color" }, _a6[EDGE_COLOR_FIELD] = { sync: "color" }, _a6));
  return params;
}
function axis10(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend10(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function tooltip6(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  chart.tooltip(tooltip11);
  return params;
}
function coordinate6(params) {
  var chart = params.chart;
  chart.coordinate("polar").reflect("y");
  return params;
}
function nodeGeometry(params) {
  var chart = params.chart, options = params.options;
  var nodesData = params.ext.chordData.nodesData;
  var nodeStyle = options.nodeStyle, label17 = options.label, tooltip11 = options.tooltip;
  var nodeView = chart.createView();
  nodeView.data(nodesData);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD2,
      yField: Y_FIELD3,
      seriesField: NODE_COLOR_FIELD,
      polygon: {
        style: nodeStyle
      },
      label: label17,
      tooltip: tooltip11
    }
  });
  return params;
}
function edgeGeometry(params) {
  var chart = params.chart, options = params.options;
  var edgesData = params.ext.chordData.edgesData;
  var edgeStyle = options.edgeStyle, tooltip11 = options.tooltip;
  var edgeView = chart.createView();
  edgeView.data(edgesData);
  var edgeOptions = {
    xField: X_FIELD2,
    yField: Y_FIELD3,
    seriesField: EDGE_COLOR_FIELD,
    edge: {
      style: edgeStyle,
      shape: "arc"
    },
    tooltip: tooltip11
  };
  edge({
    chart: edgeView,
    options: edgeOptions
  });
  return params;
}
function animation3(params) {
  var chart = params.chart, options = params.options;
  var animation7 = options.animation;
  addViewAnimation(chart, animation7, getAllGeometriesRecursively(chart));
  return params;
}
function adaptor20(params) {
  return flow(theme, transformData5, coordinate6, scale6, axis10, legend10, tooltip6, edgeGeometry, nodeGeometry, interaction, state, animation3)(params);
}

// node_modules/@antv/g2plot/esm/plots/chord/index.js
var Chord = (
  /** @class */
  function(_super) {
    __extends(Chord2, _super);
    function Chord2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "chord";
      return _this;
    }
    Chord2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS19;
    };
    Chord2.prototype.getDefaultOptions = function() {
      return Chord2.getDefaultOptions();
    };
    Chord2.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Chord2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/circle-packing/constant.js
var RAW_FIELDS = ["x", "y", "r", "name", "value", "path", "depth"];
var DEFAULT_OPTIONS20 = {
  //  name 
  colorField: "name",
  autoFit: true,
  pointStyle: {
    lineWidth: 0,
    stroke: "#fff"
  },
  // 
  legend: false,
  hierarchyConfig: {
    size: [1, 1],
    padding: 0
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  // 
  drilldown: { enabled: false }
};

// node_modules/@antv/g2plot/esm/interactions/actions/drill-down.js
var PADDING = 4;
var PADDING_LEFT = 0;
var PADDING_TOP3 = 5;
var BREAD_CRUMB_NAME = "drilldown-bread-crumb";
var DEFAULT_BREAD_CRUMB_CONFIG = {
  /**  */
  position: "top-left",
  dividerText: "/",
  textStyle: {
    fontSize: 12,
    fill: "rgba(0, 0, 0, 0.65)",
    cursor: "pointer"
  },
  activeTextStyle: {
    fill: "#87B5FF"
  }
};
var HIERARCHY_DATA_TRANSFORM_PARAMS = "hierarchy-data-transform-params";
var DrillDownAction = (
  /** @class */
  function(_super) {
    __extends(DrillDownAction2, _super);
    function DrillDownAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.name = "drill-down";
      _this.historyCache = [];
      _this.breadCrumbGroup = null;
      _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
      return _this;
    }
    DrillDownAction2.prototype.click = function() {
      var data3 = get_default(this.context, ["event", "data", "data"]);
      if (!data3)
        return false;
      this.drill(data3);
      this.drawBreadCrumb();
    };
    DrillDownAction2.prototype.resetPosition = function() {
      if (!this.breadCrumbGroup)
        return;
      var coordinate11 = this.context.view.getCoordinate();
      var breadCrumbGroup = this.breadCrumbGroup;
      var bbox = breadCrumbGroup.getBBox();
      var position = this.getButtonCfg().position;
      var point2 = { x: coordinate11.start.x, y: coordinate11.end.y - (bbox.height + PADDING_TOP3 * 2) };
      if (coordinate11.isPolar) {
        point2 = { x: 0, y: 0 };
      }
      if (position === "bottom-left") {
        point2 = { x: coordinate11.start.x, y: coordinate11.start.y };
      }
      var matrix = Util.transform(null, [["t", point2.x + PADDING_LEFT, point2.y + bbox.height + PADDING_TOP3]]);
      breadCrumbGroup.setMatrix(matrix);
    };
    DrillDownAction2.prototype.back = function() {
      if (size(this.historyCache)) {
        this.backTo(this.historyCache.slice(0, -1));
      }
    };
    DrillDownAction2.prototype.reset = function() {
      if (this.historyCache[0]) {
        this.backTo(this.historyCache.slice(0, 1));
      }
      this.historyCache = [];
      this.hideCrumbGroup();
    };
    DrillDownAction2.prototype.drill = function(nodeInfo) {
      var view = this.context.view;
      var transformData10 = get_default(view, ["interactions", "drill-down", "cfg", "transformData"], function(v) {
        return v;
      });
      var drillData = transformData10(__assign({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
      view.changeData(drillData);
      var historyCache = [];
      var node = nodeInfo;
      while (node) {
        var nodeData = node.data;
        historyCache.unshift({
          id: "".concat(nodeData.name, "_").concat(node.height, "_").concat(node.depth),
          name: nodeData.name,
          // children 
          children: transformData10(__assign({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
        });
        node = node.parent;
      }
      this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
    };
    DrillDownAction2.prototype.backTo = function(historyCache) {
      if (!historyCache || historyCache.length <= 0) {
        return;
      }
      var view = this.context.view;
      var data3 = last(historyCache).children;
      view.changeData(data3);
      if (historyCache.length > 1) {
        this.historyCache = historyCache;
        this.drawBreadCrumb();
      } else {
        this.historyCache = [];
        this.hideCrumbGroup();
      }
    };
    DrillDownAction2.prototype.getButtonCfg = function() {
      var view = this.context.view;
      var drillDownConfig = get_default(view, ["interactions", "drill-down", "cfg", "drillDownConfig"]);
      return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
    };
    DrillDownAction2.prototype.drawBreadCrumb = function() {
      this.drawBreadCrumbGroup();
      this.resetPosition();
      this.breadCrumbGroup.show();
    };
    DrillDownAction2.prototype.drawBreadCrumbGroup = function() {
      var _this = this;
      var config = this.getButtonCfg();
      var cache3 = this.historyCache;
      if (!this.breadCrumbGroup) {
        this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
          name: BREAD_CRUMB_NAME
        });
      } else {
        this.breadCrumbGroup.clear();
      }
      var left2 = 0;
      cache3.forEach(function(record, index) {
        var textShape = _this.breadCrumbGroup.addShape({
          type: "text",
          id: record.id,
          name: "".concat(BREAD_CRUMB_NAME, "_").concat(record.name, "_text"),
          attrs: __assign(__assign({ text: index === 0 && !is_nil_default(config.rootText) ? config.rootText : record.name }, config.textStyle), { x: left2, y: 0 })
        });
        var textShapeBox = textShape.getBBox();
        left2 += textShapeBox.width + PADDING;
        textShape.on("click", function(event) {
          var _a6;
          var targetId = event.target.get("id");
          if (targetId !== ((_a6 = last(cache3)) === null || _a6 === void 0 ? void 0 : _a6.id)) {
            var newHistoryCache = cache3.slice(0, cache3.findIndex(function(d) {
              return d.id === targetId;
            }) + 1);
            _this.backTo(newHistoryCache);
          }
        });
        textShape.on("mouseenter", function(event) {
          var _a6;
          var targetId = event.target.get("id");
          if (targetId !== ((_a6 = last(cache3)) === null || _a6 === void 0 ? void 0 : _a6.id)) {
            textShape.attr(config.activeTextStyle);
          } else {
            textShape.attr({ cursor: "default" });
          }
        });
        textShape.on("mouseleave", function() {
          textShape.attr(config.textStyle);
        });
        if (index < cache3.length - 1) {
          var dividerShape = _this.breadCrumbGroup.addShape({
            type: "text",
            name: "".concat(config.name, "_").concat(record.name, "_divider"),
            attrs: __assign(__assign({ text: config.dividerText }, config.textStyle), { x: left2, y: 0 })
          });
          var dividerBox = dividerShape.getBBox();
          left2 += dividerBox.width + PADDING;
        }
      });
    };
    DrillDownAction2.prototype.hideCrumbGroup = function() {
      if (this.breadCrumbGroup) {
        this.breadCrumbGroup.hide();
      }
    };
    DrillDownAction2.prototype.destroy = function() {
      if (this.breadCrumbGroup) {
        this.breadCrumbGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return DrillDownAction2;
  }(base_default12)
);

// node_modules/d3-hierarchy/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  cluster: () => cluster_default,
  hierarchy: () => hierarchy,
  pack: () => pack_default,
  packEnclose: () => enclose_default,
  packSiblings: () => siblings_default,
  partition: () => partition_default,
  stratify: () => stratify_default,
  tree: () => tree_default2,
  treemap: () => treemap_default,
  treemapBinary: () => binary_default,
  treemapDice: () => dice_default,
  treemapResquarify: () => resquarify_default,
  treemapSlice: () => slice_default,
  treemapSliceDice: () => sliceDice_default,
  treemapSquarify: () => squarify_default
});

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x, c) {
  return x + c.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y, c) {
  return Math.max(y, c.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x = 0;
    root2.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };
  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum2 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum2 += children[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default8(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data3, children) {
  if (data3 instanceof Map) {
    data3 = [void 0, data3];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root2 = new Node(data3), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data3) {
  this.data = data3;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default8,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/array.js
function array_default2(x) {
  return typeof x === "object" && "length" in x ? x : Array.from(x);
}
function shuffle(array) {
  var m = array.length, t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B2 = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e;
}
function extendBasis(B2, p) {
  var i, j;
  if (enclosesWeakAll(p, B2))
    return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
        return [B2[i], B2[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b22 = y1 - y2, b32 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a2 * b32, xa = (b22 * d3 - b32 * d2) / (ab * 2) - x1, xb = (b32 * c2 - b22 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A2 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r = -(A2 ? (B2 + Math.sqrt(B2 * B2 - 4 * A2 * C2)) / (2 * A2) : C2 / B2);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a, c) {
  var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b22 = b.r + c.r, b22 *= b22;
    if (a2 > b22) {
      x = (d2 + b22 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b22 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b22) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array_default2(circles)).length))
    return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk;
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1))
    return a.r;
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2))
    return a.r + b.r;
  place(b, a, c = circles[2]);
  a = new Node2(a), b = new Node2(b), c = new Node2(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;
  pack:
    for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node2(c);
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c.previous = a, c.next = b, a.next = b.previous = b = c;
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }
  a = [b._], c = b;
  while ((c = c.next) !== b)
    a.push(c._);
  c = enclose_default(a);
  for (i = 0; i < n; ++i)
    a = circles[i], a.x -= c.x, a.y -= c.y;
  return c.r;
}
function siblings_default(circles) {
  packEnclose(circles);
  return circles;
}

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding3 = constantZero;
  function pack2(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding3, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding3, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack2.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack2) : radius;
  };
  pack2.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack2) : [dx, dy];
  };
  pack2.padding = function(x) {
    return arguments.length ? (padding3 = typeof x === "function" ? x : constant_default2(+x), pack2) : padding3;
  };
  return pack2;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding3, k) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding3(node) * k || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packEnclose(children);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent2 = node.parent;
    node.r *= k;
    if (parent2) {
      node.x = parent2.x + k * node.x;
      node.y = parent2.y + k * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent2, x0, y0, x1, y1) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k = parent2.value && (x1 - x0) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding3 = 0, round5 = false;
  function partition3(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding3;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode(dy, n));
    if (round5)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding3, y1 = node.y1 - padding3;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition3.round = function(x) {
    return arguments.length ? (round5 = !!x, partition3) : round5;
  };
  partition3.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition3) : [dx, dy];
  };
  partition3.padding = function(x) {
    return arguments.length ? (padding3 = +x, partition3) : padding3;
  };
  return partition3;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id = defaultId, parentId = defaultParentId;
  function stratify(data3) {
    var nodes = Array.from(data3), n = nodes.length, d, i, root2, parent2, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data3)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data3)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent2 = nodeByKey.get(nodeId);
        if (!parent2)
          throw new Error("missing: " + nodeId);
        if (parent2 === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent2.children)
          parent2.children.push(node);
        else
          parent2.children = [node];
        node.parent = parent2;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };
  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };
  return stratify;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default2() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s - left2.x, kx = dx / (right2.x + s + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint2 = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint2;
      } else {
        v.z = midpoint2;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };
  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent2, x0, y0, x1, y1) {
  var nodes = parent2.children, node, i = -1, n = nodes.length, k = parent2.value && (y1 - y0) / parent2.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent2, x0, y0, x1, y1) {
  var rows = [], nodes = parent2.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent2.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else
      slice_default(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom10(ratio) {
  function squarify(parent2, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent2, x0, y0, x1, y1);
  }
  squarify.ratio = function(x) {
    return custom10((x = +x) > 1 ? x : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round5 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap2(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round5)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap2.round = function(x) {
    return arguments.length ? (round5 = !!x, treemap2) : round5;
  };
  treemap2.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap2) : [dx, dy];
  };
  treemap2.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap2) : tile;
  };
  treemap2.padding = function(x) {
    return arguments.length ? treemap2.paddingInner(x).paddingOuter(x) : treemap2.paddingInner();
  };
  treemap2.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant_default2(+x), treemap2) : paddingInner;
  };
  treemap2.paddingOuter = function(x) {
    return arguments.length ? treemap2.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap2.paddingTop();
  };
  treemap2.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant_default2(+x), treemap2) : paddingTop;
  };
  treemap2.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant_default2(+x), treemap2) : paddingRight;
  };
  treemap2.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant_default2(+x), treemap2) : paddingBottom;
  };
  treemap2.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant_default2(+x), treemap2) : paddingLeft;
  };
  return treemap2;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent2, x0, y0, x1, y1) {
  var nodes = parent2.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition3(0, n, parent2.value, x0, y0, x1, y1);
  function partition3(i2, j, value2, x02, y02, x12, y12) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x02, node.y0 = y02;
      node.x1 = x12, node.y1 = y12;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid2 = k + hi >>> 1;
      if (sums[mid2] < valueTarget)
        k = mid2 + 1;
      else
        hi = mid2;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
    if (x12 - x02 > y12 - y02) {
      var xk = value2 ? (x02 * valueRight + x12 * valueLeft) / value2 : x12;
      partition3(i2, k, valueLeft, x02, y02, xk, y12);
      partition3(k, j, valueRight, xk, y02, x12, y12);
    } else {
      var yk = value2 ? (y02 * valueRight + y12 * valueLeft) / value2 : y12;
      partition3(i2, k, valueLeft, x02, y02, x12, yk);
      partition3(k, j, valueRight, x02, yk, x12, y12);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent2, x0, y0, x1, y1) {
  (parent2.depth & 1 ? slice_default : dice_default)(parent2, x0, y0, x1, y1);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom11(ratio) {
  function resquarify(parent2, x0, y0, x1, y1) {
    if ((rows = parent2._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value2 = parent2.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x0, y0, x1, value2 ? y0 += (y1 - y0) * row.value / value2 : y1);
        else
          slice_default(row, x0, y0, value2 ? x0 += (x1 - x0) * row.value / value2 : x1, y1);
        value2 -= row.value;
      }
    } else {
      parent2._squarify = rows = squarifyRatio(ratio, parent2, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x) {
    return custom11((x = +x) > 1 ? x : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2plot/esm/utils/hierarchy/util.js
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  var field6 = options.field, fields = options.fields;
  if (is_string_default(field6)) {
    return field6;
  }
  if (is_array_default(field6)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field6[0];
  }
  console.warn("".concat(INVALID_FIELD_ERR_MSG, " will try to get fields instead."));
  if (is_string_default(fields)) {
    return fields;
  }
  if (is_array_default(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root2) {
  var nodes = [];
  if (root2 && root2.each) {
    var parent_1;
    var index_1;
    root2.each(function(node) {
      var _a6, _b;
      if (node.parent !== parent_1) {
        parent_1 = node.parent;
        index_1 = 0;
      } else {
        index_1 += 1;
      }
      var ancestors = filter_default((((_a6 = node.ancestors) === null || _a6 === void 0 ? void 0 : _a6.call(node)) || []).map(function(d) {
        return nodes.find(function(n) {
          return n.name === d.name;
        }) || d;
      }), function(_a7) {
        var depth = _a7.depth;
        return depth > 0 && depth < node.depth;
      });
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index_1;
      nodes.push(node);
    });
  } else if (root2 && root2.eachNode) {
    root2.eachNode(function(node) {
      nodes.push(node);
    });
  }
  return nodes;
}

// node_modules/@antv/g2plot/esm/utils/hierarchy/pack.js
var DEFAULT_OPTIONS21 = {
  field: "value",
  as: ["x", "y", "r"],
  // 
  sort: function(a, b) {
    return b.value - a.value;
  }
};
function pack(data3, options) {
  options = mix({}, DEFAULT_OPTIONS21, options);
  var as = options.as;
  if (!is_array_default(as) || as.length !== 3) {
    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
  }
  var field6;
  try {
    field6 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var packLayout = function(data4) {
    return pack_default().size(options.size).padding(options.padding)(hierarchy(data4).sum(function(d) {
      return d[field6];
    }).sort(options.sort));
  };
  var root2 = packLayout(data3);
  var x = as[0];
  var y = as[1];
  var r = as[2];
  root2.each(function(node) {
    node[x] = node.x;
    node[y] = node.y;
    node[r] = node.r;
  });
  return getAllNodes(root2);
}

// node_modules/@antv/g2plot/esm/plots/circle-packing/utils.js
function transformData6(options) {
  var data3 = options.data, hierarchyConfig = options.hierarchyConfig, _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6, enableDrillDown = options.enableDrillDown;
  var nodes = pack(data3, __assign(__assign({}, hierarchyConfig), { field: "value", as: ["x", "y", "r"] }));
  var result2 = [];
  nodes.forEach(function(node) {
    var _a7;
    var path = node.data.name;
    var ancestorNode = __assign({}, node);
    while (ancestorNode.depth > 1) {
      path = "".concat((_a7 = ancestorNode.parent.data) === null || _a7 === void 0 ? void 0 : _a7.name, " / ").concat(path);
      ancestorNode = ancestorNode.parent;
    }
    if (enableDrillDown && node.depth > 2) {
      return null;
    }
    var nodeInfo = deepAssign({}, node.data, __assign(__assign(__assign({}, pick(node.data, rawFields)), { path }), node));
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };
    result2.push(nodeInfo);
  });
  return result2;
}
function resolvePaddingForCircle(padding3, appendPadding, containerSize) {
  var tempPadding = resolveAllPadding([padding3, appendPadding]);
  var top = tempPadding[0], right2 = tempPadding[1], bottom = tempPadding[2], left2 = tempPadding[3];
  var width = containerSize.width, height = containerSize.height;
  var wSize = width - (left2 + right2);
  var hSize = height - (top + bottom);
  var minSize = Math.min(wSize, hSize);
  var restWidthPadding = (wSize - minSize) / 2;
  var restHeightPadding = (hSize - minSize) / 2;
  var finalTop = top + restHeightPadding;
  var finalRight = right2 + restWidthPadding;
  var finalBottom = bottom + restHeightPadding;
  var finalLeft = left2 + restWidthPadding;
  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];
  var finalSize = minSize < 0 ? 0 : minSize;
  return { finalPadding, finalSize };
}

// node_modules/@antv/g2plot/esm/plots/circle-packing/adaptor.js
function defaultOptions4(params) {
  var chart = params.chart;
  var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
  return deepAssign({
    options: {
      size: function(_a6) {
        var r = _a6.r;
        return r * diameter;
      }
      // autofitfalse
    }
  }, params);
}
function padding(params) {
  var options = params.options, chart = params.chart;
  var containerSize = chart.viewBBox;
  var padding3 = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
  var tempAppendPadding = appendPadding;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
    tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
  }
  var finalPadding = resolvePaddingForCircle(padding3, tempAppendPadding, containerSize).finalPadding;
  chart.padding = finalPadding;
  chart.appendPadding = 0;
  return params;
}
function geometry22(params) {
  var chart = params.chart, options = params.options;
  var padding3 = chart.padding, appendPadding = chart.appendPadding;
  var color3 = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6, drilldown = options.drilldown;
  var data3 = transformData6({
    data: options.data,
    hierarchyConfig,
    enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
    rawFields
  });
  chart.data(data3);
  var containerSize = chart.viewBBox;
  var finalSize = resolvePaddingForCircle(padding3, appendPadding, containerSize).finalSize;
  var circleSize = function(_a7) {
    var r = _a7.r;
    return r * finalSize;
  };
  if (sizeField) {
    circleSize = function(d) {
      return d[sizeField] * finalSize;
    };
  }
  point(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      sizeField,
      rawFields: __spreadArray(__spreadArray([], RAW_FIELDS, true), rawFields, true),
      point: {
        color: color3,
        style: pointStyle,
        shape: "circle",
        size: circleSize
      }
    }
  }));
  return params;
}
function meta13(params) {
  return flow(scale5({}, {
    //  nice
    x: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
    y: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true }
  }))(params);
}
function tooltip7(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip11;
    if (!get_default(tooltip11, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get_default(chart.getOptions(), "scales");
            var nameFormatter = get_default(scales, ["name", "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get_default(scales, ["value", "formatter"], function(v) {
              return v;
            });
            return __assign(__assign({}, item), { name: nameFormatter(item.data.name), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function axis11(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction(options) {
  var drilldown = options.drilldown, _a6 = options.interactions, interactions = _a6 === void 0 ? [] : _a6;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArray(__spreadArray([], interactions, true), [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData6, enableDrillDown: true }
        }
      ], false)
    });
  }
  return options;
}
function interaction5(params) {
  var chart = params.chart, options = params.options;
  interaction({
    chart,
    options: adaptorInteraction(options)
  });
  return params;
}
function adaptor21(params) {
  return flow(pattern("pointStyle"), defaultOptions4, padding, theme, meta13, geometry22, axis11, legend, tooltip7, interaction5, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/interactions/drill-down.js
function isParentNode(context) {
  var data3 = get_default(context, ["event", "data", "data"], {});
  return is_array_default(data3.children) && data3.children.length > 0;
}
function inCenter(context) {
  var coordinate11 = context.view.getCoordinate();
  var innerRadius = coordinate11.innerRadius;
  if (innerRadius) {
    var _a6 = context.event, x = _a6.x, y = _a6.y;
    var _b = coordinate11.center, centerX = _b.x, centerY = _b.y;
    var r = coordinate11.getRadius() * innerRadius;
    var distance9 = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
    return distance9 < r;
  }
  return false;
}
registerAction("drill-down-action", DrillDownAction);
registerInteraction("drill-down", {
  showEnable: [
    { trigger: "element:mouseenter", action: "cursor:pointer", isEnable: isParentNode },
    { trigger: "element:mouseleave", action: "cursor:default" },
    //  element:mouseleave 
    { trigger: "element:mouseleave", action: "cursor:pointer", isEnable: inCenter }
  ],
  start: [
    {
      trigger: "element:click",
      isEnable: isParentNode,
      action: ["drill-down-action:click"]
    },
    {
      trigger: "afterchangesize",
      action: ["drill-down-action:resetPosition"]
    },
    {
      // 
      trigger: "click",
      isEnable: inCenter,
      action: ["drill-down-action:back"]
    }
  ]
});

// node_modules/@antv/g2plot/esm/plots/circle-packing/index.js
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends(CirclePacking2, _super);
    function CirclePacking2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle-packing";
      return _this;
    }
    CirclePacking2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS20;
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    CirclePacking2.prototype.triggerResize = function() {
      if (!this.chart.destroyed) {
        this.chart.forceFit();
        this.chart.clear();
        this.execAdaptor();
        this.chart.render(true);
      }
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/dual-axes/constant.js
var LEFT_AXES_VIEW = "left-axes-view";
var RIGHT_AXES_VIEW = "right-axes-view";
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
var DEFAULT_LEFT_YAXIS_CONFIG = __assign(__assign({}, DEFAULT_YAXIS_CONFIG), { position: "left" });
var DEFAULT_RIGHT_YAXIS_CONFIG = __assign(__assign({}, DEFAULT_YAXIS_CONFIG), { position: "right", grid: null });

// node_modules/@antv/g2plot/esm/plots/dual-axes/types.js
var AxisType;
(function(AxisType2) {
  AxisType2["Left"] = "Left";
  AxisType2["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function(DualAxesGeometry2) {
  DualAxesGeometry2["Line"] = "line";
  DualAxesGeometry2["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));

// node_modules/@antv/g2plot/esm/plots/dual-axes/util/option.js
function isLine(geometryOption) {
  return get_default(geometryOption, "geometry") === DualAxesGeometry.Line;
}
function isColumn(geometryOption) {
  return get_default(geometryOption, "geometry") === DualAxesGeometry.Column;
}
function getGeometryOption(xField, yField, geometryOption) {
  return isColumn(geometryOption) ? deepAssign({}, {
    geometry: DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function(item) {
        var _a6;
        return (_a6 = item[yField]) === null || _a6 === void 0 ? void 0 : _a6.join("-");
      }
    } : void 0
  }, geometryOption) : __assign({ geometry: DualAxesGeometry.Line }, geometryOption);
}
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0], y2 = yField[1];
  if (is_array_default(transformAttribute)) {
    var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = get_default(transformAttribute, y1);
  var a2 = get_default(transformAttribute, y2);
  return [a1, a2];
}
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === AxisType.Left) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === AxisType.Right) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}

// node_modules/@antv/g2plot/esm/plots/dual-axes/util/geometry.js
function drawSingleGeometry(params) {
  var options = params.options, chart = params.chart;
  var geometryOption = options.geometryOption;
  var isStack = geometryOption.isStack, color3 = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
  var FIELD_KEY = ["xField", "yField"];
  if (isLine(geometryOption)) {
    line(deepAssign({}, params, {
      options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), { line: {
        color: geometryOption.color,
        style: geometryOption.lineStyle
      } })
    }));
    point(deepAssign({}, params, {
      options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && __assign({ color: color3, shape: "circle" }, geometryOption.point) })
    }));
    var adjust_1 = [];
    if (isGroup) {
      adjust_1.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        customOffset: 0
      });
    }
    if (isStack) {
      adjust_1.push({
        type: "stack"
      });
    }
    if (adjust_1.length) {
      each_default(chart.geometries, function(g) {
        g.adjust(adjust_1);
      });
    }
  }
  if (isColumn(geometryOption)) {
    adaptor3(deepAssign({}, params, {
      options: __assign(__assign(__assign({}, pick(options, FIELD_KEY)), geometryOption), { widthRatio: geometryOption.columnWidthRatio, interval: __assign(__assign({}, pick(geometryOption, ["color"])), { style: geometryOption.columnStyle }) })
    }));
  }
  return params;
}

// node_modules/@antv/g2plot/esm/plots/dual-axes/util/legend.js
function getViewLegendItems(params) {
  var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend18 = params.legend;
  var userMarker = get_default(legend18, "marker");
  var geometry35 = findGeometry(view, isLine(geometryOption) ? "line" : "interval");
  if (!geometryOption.seriesField) {
    var legendItemName = get_default(view, "options.scales.".concat(yField, ".alias")) || yField;
    var colorAttribute = geometry35.getAttribute("color");
    var color3 = view.getTheme().defaultColor;
    if (colorAttribute) {
      color3 = Util.getMappingValue(colorAttribute, legendItemName, get_default(colorAttribute, ["values", 0], color3));
    }
    var marker = (is_function_default(userMarker) ? userMarker : !is_empty_default(userMarker) && deepAssign({}, {
      style: {
        stroke: color3,
        fill: color3
      }
    }, userMarker)) || (isLine(geometryOption) ? {
      symbol: function(x, y, r) {
        return [
          ["M", x - r, y],
          ["L", x + r, y]
        ];
      },
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color3
      }
    } : {
      symbol: "square",
      style: {
        fill: color3
      }
    });
    return [
      {
        value: yField,
        name: legendItemName,
        marker,
        isGeometry: true,
        viewId: view.id
      }
    ];
  }
  var attributes = geometry35.getGroupAttributes();
  return reduce_default(attributes, function(items, attr) {
    var attrItems = Util.getLegendItems(view, geometry35, attr, view.getTheme(), userMarker);
    return items.concat(attrItems);
  }, []);
}

// node_modules/@antv/g2plot/esm/plots/dual-axes/util/render-sider.js
var doSliderFilter = function(view, sliderValue) {
  var min5 = sliderValue[0], max5 = sliderValue[1];
  var data3 = view.getOptions().data;
  var xScale = view.getXScale();
  var dataSize = size(data3);
  if (!xScale || !dataSize) {
    return;
  }
  var isHorizontal2 = true;
  var values3 = values_of_key_default(data3, xScale.field);
  var xValues = isHorizontal2 ? values3 : values3.reverse();
  var xTickCount = size(xValues);
  var minIndex = Math.floor(min5 * (xTickCount - 1));
  var maxIndex = Math.floor(max5 * (xTickCount - 1));
  view.filter(xScale.field, function(value2) {
    var idx = xValues.indexOf(value2);
    return idx > -1 ? isBetween3(idx, minIndex, maxIndex) : true;
  });
  view.getRootView().render(true);
};

// node_modules/@antv/g2plot/esm/plots/dual-axes/adaptor.js
function transformOptions2(params) {
  var _a6;
  var options = params.options;
  var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
  var allLine = every_default(geometryOptions, function(_a7) {
    var geometry35 = _a7.geometry;
    return geometry35 === DualAxesGeometry.Line || geometry35 === void 0;
  });
  return deepAssign({}, {
    options: {
      geometryOptions: [],
      meta: (_a6 = {}, _a6[xField] = {
        //  cat 
        type: "cat",
        // x  scale 
        sync: true,
        // 
        range: allLine ? [0, 1] : void 0
      }, _a6),
      tooltip: {
        showMarkers: allLine,
        //  crosshairs
        showCrosshairs: allLine,
        shared: true,
        crosshairs: {
          type: "x"
        }
      },
      interactions: !allLine ? [{ type: "legend-visible-filter" }, { type: "active-region" }] : [{ type: "legend-visible-filter" }],
      legend: {
        position: "top-left"
      }
    }
  }, params, {
    options: {
      // yAxis
      yAxis: transformObjectToArray(yField, options.yAxis),
      // geometryOptions
      geometryOptions: [
        getGeometryOption(xField, yField[0], geometryOptions[0]),
        getGeometryOption(xField, yField[1], geometryOptions[1])
      ],
      // annotations
      annotations: transformObjectToArray(yField, options.annotations)
    }
  });
}
function createViews(params) {
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var SORT_MAP = { line: 0, column: 1 };
  var geometries = [
    { type: (_a6 = geometryOptions[0]) === null || _a6 === void 0 ? void 0 : _a6.geometry, id: LEFT_AXES_VIEW },
    { type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry, id: RIGHT_AXES_VIEW }
  ];
  geometries.sort(function(a, b) {
    return -SORT_MAP[a.type] + SORT_MAP[b.type];
  }).forEach(function(g) {
    return chart.createView({ id: g.id });
  });
  return params;
}
function geometry23(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data3 = options.data, tooltip11 = options.tooltip;
  var geometries = [
    __assign(__assign({}, geometryOptions[0]), { id: LEFT_AXES_VIEW, data: data3[0], yField: yField[0] }),
    __assign(__assign({}, geometryOptions[1]), { id: RIGHT_AXES_VIEW, data: data3[1], yField: yField[1] })
  ];
  geometries.forEach(function(geometry35) {
    var id = geometry35.id, data4 = geometry35.data, yField2 = geometry35.yField;
    var isPercent = isColumn(geometry35) && geometry35.isPercent;
    var formatData = isPercent ? percent(data4, yField2, xField, yField2) : data4;
    var view = findViewById(chart, id).data(formatData);
    var tooltipOptions = isPercent ? __assign({ formatter: function(datum) {
      return {
        name: datum[geometry35.seriesField] || yField2,
        value: (Number(datum[yField2]) * 100).toFixed(2) + "%"
      };
    } }, tooltip11) : tooltip11;
    drawSingleGeometry({
      chart: view,
      options: {
        xField,
        yField: yField2,
        tooltip: tooltipOptions,
        geometryOption: geometry35
      }
    });
  });
  return params;
}
function color2(params) {
  var _a6;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var themeColor = ((_a6 = chart.getTheme()) === null || _a6 === void 0 ? void 0 : _a6.colors10) || [];
  var start = 0;
  chart.once("beforepaint", function() {
    each_default(geometryOptions, function(geometryOption, index) {
      var view = findViewById(chart, index === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
      if (geometryOption.color)
        return;
      var groupScale = view.getGroupScales();
      var count2 = get_default(groupScale, [0, "values", "length"], 1);
      var color3 = themeColor.slice(start, start + count2).concat(index === 0 ? [] : themeColor);
      view.geometries.forEach(function(geometry35) {
        if (geometryOption.seriesField) {
          geometry35.color(geometryOption.seriesField, color3);
        } else {
          geometry35.color(color3[0]);
        }
      });
      start += count2;
    });
    chart.render(true);
  });
  return params;
}
function meta14(params) {
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField[0]] = yAxis[0], _a6))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  scale5((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function axis12(params) {
  var chart = params.chart, options = params.options;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  chart.axis(xField, false);
  chart.axis(yField[0], false);
  chart.axis(yField[1], false);
  leftView.axis(xField, xAxis);
  leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
  rightView.axis(xField, false);
  rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
  return params;
}
function tooltip8(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  chart.tooltip(tooltip11);
  leftView.tooltip({
    shared: true
  });
  rightView.tooltip({
    shared: true
  });
  return params;
}
function interaction6(params) {
  var chart = params.chart;
  interaction(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  interaction(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function annotation2(params) {
  var chart = params.chart, options = params.options;
  var annotations = options.annotations;
  var a1 = get_default(annotations, [0]);
  var a2 = get_default(annotations, [1]);
  annotation(a1)(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      annotations: a1
    }
  }));
  annotation(a2)(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      annotations: a2
    }
  }));
  return params;
}
function theme3(params) {
  var chart = params.chart;
  theme(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  theme(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  theme(params);
  return params;
}
function animation4(params) {
  var chart = params.chart;
  animation(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  animation(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function limitInPlot4(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis;
  limitInPlot2(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      yAxis: yAxis[0]
    }
  }));
  limitInPlot2(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      yAxis: yAxis[1]
    }
  }));
  return params;
}
function legend11(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data3 = options.data;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (legend18 === false) {
    chart.legend(false);
  } else if (is_object_default(legend18) && legend18.custom === true) {
    chart.legend(legend18);
  } else {
    var leftLegend_1 = get_default(geometryOptions, [0, "legend"], legend18);
    var rightLegend_1 = get_default(geometryOptions, [1, "legend"], legend18);
    chart.once("beforepaint", function() {
      var leftItems = data3[0].length ? getViewLegendItems({
        view: leftView,
        geometryOption: geometryOptions[0],
        yField: yField[0],
        legend: leftLegend_1
      }) : [];
      var rightItems = data3[1].length ? getViewLegendItems({
        view: rightView,
        geometryOption: geometryOptions[1],
        yField: yField[1],
        legend: rightLegend_1
      }) : [];
      chart.legend(deepAssign({}, legend18, {
        custom: true,
        // todo 
        // @ts-ignore
        items: leftItems.concat(rightItems)
      }));
    });
    if (geometryOptions[0].seriesField) {
      leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
    }
    if (geometryOptions[1].seriesField) {
      rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
    }
    chart.on("legend-item:click", function(evt) {
      var delegateObject = get_default(evt, "gEvent.delegateObject", {});
      if (delegateObject && delegateObject.item) {
        var _a6 = delegateObject.item, field_1 = _a6.value, isGeometry = _a6.isGeometry, viewId = _a6.viewId;
        if (isGeometry) {
          var idx = find_index_default(yField, function(yF) {
            return yF === field_1;
          });
          if (idx > -1) {
            var geometries = get_default(findViewById(chart, viewId), "geometries");
            each_default(geometries, function(g) {
              g.changeVisible(!delegateObject.item.unchecked);
            });
          }
        } else {
          var legendItem_1 = get_default(chart.getController("legend"), "option.items", []);
          each_default(chart.views, function(view) {
            var groupScale = view.getGroupScales();
            each_default(groupScale, function(scale8) {
              if (scale8.values && scale8.values.indexOf(field_1) > -1) {
                view.filter(scale8.field, function(value2) {
                  var curLegendItem = find_default(legendItem_1, function(item) {
                    return item.value === value2;
                  });
                  return !curLegendItem.unchecked;
                });
              }
            });
            chart.render(true);
          });
        }
      }
    });
  }
  return params;
}
function slider3(params) {
  var chart = params.chart, options = params.options;
  var slider4 = options.slider;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (slider4) {
    leftView.option("slider", slider4);
    leftView.on("slider:valuechanged", function(evt) {
      var _a6 = evt.event, value2 = _a6.value, originValue = _a6.originValue;
      if (is_equal_default(value2, originValue)) {
        return;
      }
      doSliderFilter(rightView, value2);
    });
    chart.once("afterpaint", function() {
      if (!is_boolean_default(slider4)) {
        var start = slider4.start, end = slider4.end;
        if (start || end) {
          doSliderFilter(rightView, [start, end]);
        }
      }
    });
  }
  return params;
}
function adaptor22(params) {
  return flow(
    transformOptions2,
    createViews,
    // 
    theme3,
    geometry23,
    meta14,
    axis12,
    limitInPlot4,
    tooltip8,
    interaction6,
    annotation2,
    animation4,
    color2,
    legend11,
    slider3
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/dual-axes/index.js
var DualAxes = (
  /** @class */
  function(_super) {
    __extends(DualAxes2, _super);
    function DualAxes2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dual-axes";
      return _this;
    }
    DualAxes2.prototype.getDefaultOptions = function() {
      return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
        yAxis: [],
        syncViewPadding: true
      });
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/facet/utils.js
function execViewAdaptor(viewOfG2, options) {
  var data3 = options.data, coordinate11 = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation7 = options.animation, tooltip11 = options.tooltip, axes = options.axes, meta23 = options.meta, geometries = options.geometries;
  if (data3) {
    viewOfG2.data(data3);
  }
  var scales = {};
  if (axes) {
    each_default(axes, function(axis22, field6) {
      scales[field6] = pick(axis22, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta23, scales);
  viewOfG2.scale(scales);
  if (coordinate11) {
    viewOfG2.coordinate(coordinate11);
  }
  if (axes === false) {
    viewOfG2.axis(false);
  } else {
    each_default(axes, function(axis22, field6) {
      viewOfG2.axis(field6, axis22);
    });
  }
  each_default(geometries, function(geometry35) {
    var ext = geometry({
      chart: viewOfG2,
      options: geometry35
    }).ext;
    var adjust3 = geometry35.adjust;
    if (adjust3) {
      ext.geometry.adjust(adjust3);
    }
  });
  each_default(interactions, function(interaction10) {
    if (interaction10.enable === false) {
      viewOfG2.removeInteraction(interaction10.type);
    } else {
      viewOfG2.interaction(interaction10.type, interaction10.cfg);
    }
  });
  each_default(annotations, function(annotation4) {
    viewOfG2.annotation()[annotation4.type](__assign({}, annotation4));
  });
  addViewAnimation(viewOfG2, animation7);
  if (tooltip11) {
    viewOfG2.interaction("tooltip");
    viewOfG2.tooltip(tooltip11);
  } else if (tooltip11 === false) {
    viewOfG2.removeInteraction("tooltip");
  }
}

// node_modules/@antv/g2plot/esm/plots/facet/adaptor.js
function facetAdaptor(params) {
  var chart = params.chart, options = params.options;
  var facetType = options.type, data3 = options.data, fields = options.fields, eachView = options.eachView;
  var restFacetCfg = omit_default(options, [
    "type",
    "data",
    "fields",
    "eachView",
    "axes",
    "meta",
    "tooltip",
    "coordinate",
    "theme",
    "legend",
    "interactions",
    "annotations"
  ]);
  chart.data(data3);
  chart.facet(facetType, __assign(__assign({}, restFacetCfg), { fields, eachView: function(viewOfG2, facet) {
    var viewOptions = eachView(viewOfG2, facet);
    if (viewOptions.geometries) {
      execViewAdaptor(viewOfG2, viewOptions);
    } else {
      var plot = viewOptions;
      var plotOptions = plot.options;
      if (plotOptions.tooltip) {
        viewOfG2.interaction("tooltip");
      }
      execPlotAdaptor(plot.type, viewOfG2, plotOptions);
    }
  } }));
  return params;
}
function component(params) {
  var chart = params.chart, options = params.options;
  var axes = options.axes, meta23 = options.meta, tooltip11 = options.tooltip, coordinate11 = options.coordinate, theme4 = options.theme, legend18 = options.legend, interactions = options.interactions, annotations = options.annotations;
  var scales = {};
  if (axes) {
    each_default(axes, function(axis22, field6) {
      scales[field6] = pick(axis22, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta23, scales);
  chart.scale(scales);
  chart.coordinate(coordinate11);
  if (!axes) {
    chart.axis(false);
  } else {
    each_default(axes, function(axis22, field6) {
      chart.axis(field6, axis22);
    });
  }
  if (tooltip11) {
    chart.interaction("tooltip");
    chart.tooltip(tooltip11);
  } else if (tooltip11 === false) {
    chart.removeInteraction("tooltip");
  }
  chart.legend(legend18);
  if (theme4) {
    chart.theme(theme4);
  }
  each_default(interactions, function(interaction10) {
    if (interaction10.enable === false) {
      chart.removeInteraction(interaction10.type);
    } else {
      chart.interaction(interaction10.type, interaction10.cfg);
    }
  });
  each_default(annotations, function(annotation4) {
    chart.annotation()[annotation4.type](__assign({}, annotation4));
  });
  return params;
}
function adaptor23(params) {
  return flow(theme, facetAdaptor, component)(params);
}

// node_modules/@antv/g2plot/esm/plots/facet/constant.js
var DEFAULT_OPTIONS22 = {
  title: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  rowTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  columnTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  }
};

// node_modules/@antv/g2plot/esm/plots/facet/index.js
var Facet2 = (
  /** @class */
  function(_super) {
    __extends(Facet3, _super);
    function Facet3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "area";
      return _this;
    }
    Facet3.getDefaultOptions = function() {
      return DEFAULT_OPTIONS22;
    };
    Facet3.prototype.getDefaultOptions = function() {
      return Facet3.getDefaultOptions();
    };
    Facet3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Facet3;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/heatmap/adaptor.js
function geometry24(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, type = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color3 = options.color, tooltip11 = options.tooltip, heatmapStyle = options.heatmapStyle, meta23 = options.meta;
  chart.data(data3);
  var geometryType = "polygon";
  if (type === "density") {
    geometryType = "heatmap";
  }
  var _a6 = getTooltipMapping(tooltip11, [xField, yField, colorField]), fields = _a6.fields, formatter = _a6.formatter;
  var checkedSizeRatio = 1;
  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn("sizeRatio is not in effect: Must define shape or sizeField first");
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn("sizeRatio is not in effect: It must be a number in [0,1]");
    } else {
      checkedSizeRatio = sizeRatio;
    }
  }
  geometry(deepAssign({}, params, {
    options: {
      type: geometryType,
      colorField,
      tooltipFields: fields,
      shapeField: sizeField || "",
      label: void 0,
      mapping: {
        tooltip: formatter,
        shape: shape && (sizeField ? function(dautm) {
          var field6 = data3.map(function(row) {
            return row[sizeField];
          });
          var _a7 = (meta23 === null || meta23 === void 0 ? void 0 : meta23[sizeField]) || {}, min5 = _a7.min, max5 = _a7.max;
          min5 = is_number_default(min5) ? min5 : Math.min.apply(Math, field6);
          max5 = is_number_default(max5) ? max5 : Math.max.apply(Math, field6);
          return [shape, (get_default(dautm, sizeField) - min5) / (max5 - min5), checkedSizeRatio];
        } : function() {
          return [shape, 1, checkedSizeRatio];
        }),
        color: color3 || colorField && chart.getTheme().sequenceColors.join("-"),
        style: heatmapStyle
      }
    }
  }));
  return params;
}
function meta15(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6)))(params);
}
function axis13(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend12(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
  var showLegend = legend18 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend18 : false);
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend === void 0 ? legend18 : sizeLegend);
  }
  if (!showLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label10(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, colorField = options.colorField, type = options.type;
  var geometry35 = findGeometry(chart, type === "density" ? "heatmap" : "polygon");
  if (!label17) {
    geometry35.label(false);
  } else if (colorField) {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: [colorField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate7(params) {
  var _a6, _b;
  var chart = params.chart, options = params.options;
  var coordinate11 = options.coordinate, reflect = options.reflect;
  var coordinateOption = deepAssign({ actions: [] }, coordinate11 !== null && coordinate11 !== void 0 ? coordinate11 : { type: "rect" });
  if (reflect) {
    (_b = (_a6 = coordinateOption.actions) === null || _a6 === void 0 ? void 0 : _a6.push) === null || _b === void 0 ? void 0 : _b.call(_a6, ["reflect", reflect]);
  }
  chart.coordinate(coordinateOption);
  return params;
}
function adaptor24(params) {
  return flow(theme, pattern("heatmapStyle"), meta15, coordinate7, geometry24, axis13, legend12, tooltip, label10, annotation(), interaction, animation, state)(params);
}

// node_modules/@antv/g2plot/esm/plots/heatmap/constant.js
var DEFAULT_OPTIONS23 = deepAssign({}, Plot.getDefaultOptions(), {
  type: "polygon",
  legend: false,
  coordinate: {
    type: "rect"
  },
  xAxis: {
    tickLine: null,
    line: null,
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  },
  yAxis: {
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  }
});

// node_modules/@antv/g2plot/esm/plots/heatmap/shapes/circle.js
registerShape("polygon", "circle", {
  draw: function(cfg, group2) {
    var _a6, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value2);
    var fill2 = ((_a6 = cfg.style) === null || _a6 === void 0 ? void 0 : _a6.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("circle", {
      attrs: __assign(__assign(__assign({ x: cx, y: cy, r: radius }, cfg.defaultStyle), cfg.style), { fill: fill2 })
    });
    return polygon2;
  }
});

// node_modules/@antv/g2plot/esm/plots/heatmap/shapes/square.js
registerShape("polygon", "square", {
  draw: function(cfg, group2) {
    var _a6, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxSideLength = Math.min(width, height);
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value2);
    var fill2 = ((_a6 = cfg.style) === null || _a6 === void 0 ? void 0 : _a6.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("rect", {
      attrs: __assign(__assign(__assign({ x: cx - sideLength / 2, y: cy - sideLength / 2, width: sideLength, height: sideLength }, cfg.defaultStyle), cfg.style), { fill: fill2 })
    });
    return polygon2;
  }
});

// node_modules/@antv/g2plot/esm/plots/heatmap/index.js
var Heatmap2 = (
  /** @class */
  function(_super) {
    __extends(Heatmap3, _super);
    function Heatmap3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      return _this;
    }
    Heatmap3.getDefaultOptions = function() {
      return DEFAULT_OPTIONS23;
    };
    Heatmap3.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    Heatmap3.prototype.getDefaultOptions = function() {
      return Heatmap3.getDefaultOptions();
    };
    return Heatmap3;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/liquid/utils.js
var CAT_VALUE = "liquid";
function getLiquidData(percent2) {
  return [{ percent: percent2, type: CAT_VALUE }];
}

// node_modules/@antv/g2plot/esm/plots/liquid/adaptor.js
function geometry25(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape, shapeStyle = options.shapeStyle, animation7 = options.animation;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data(getLiquidData(percent2));
  var color3 = options.color || chart.getTheme().defaultColor;
  var p = deepAssign({}, params, {
    options: {
      xField: "type",
      yField: "percent",
      // radius  columnWidthRatio 
      //   radius 
      widthRatio: radius,
      interval: {
        color: color3,
        style: liquidStyle,
        shape: "liquid-fill-gauge"
      }
    }
  });
  var ext = interval2(p).ext;
  var geometry35 = ext.geometry;
  var background = chart.getTheme().background;
  var customInfo = {
    percent: percent2,
    radius,
    outline,
    wave,
    shape,
    shapeStyle,
    background,
    animation: animation7
  };
  geometry35.customInfo(customInfo);
  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
function statistic3(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic4 = options.statistic, percent2 = options.percent, meta23 = options.meta;
  chart.getController("annotation").clear(true);
  var metaFormatter = get_default(meta23, ["percent", "formatter"]) || function(v) {
    return "".concat((v * 100).toFixed(2), "%");
  };
  var contentOpt = statistic4.content;
  if (contentOpt) {
    contentOpt = deepAssign({}, contentOpt, {
      content: !is_nil_default(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
    });
  }
  renderStatistic(chart, { statistic: __assign(__assign({}, statistic4), { content: contentOpt }), plotType: "liquid" }, { percent: percent2 });
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor25(params) {
  return flow(theme, pattern("liquidStyle"), geometry25, statistic3, scale5({}), animation, interaction)(params);
}

// node_modules/@antv/g2plot/esm/plots/liquid/constants.js
var DEFAULT_OPTIONS24 = {
  radius: 0.9,
  statistic: {
    title: false,
    content: {
      style: {
        opacity: 0.75,
        fontSize: "30px",
        lineHeight: "30px",
        textAlign: "center"
      }
    }
  },
  outline: {
    border: 2,
    distance: 0
  },
  wave: {
    count: 3,
    length: 192
  },
  shape: "circle"
};

// node_modules/@antv/g2plot/esm/plots/liquid/shapes/liquid.js
var DURATION = 5e3;
function lerp4(min5, max5, factor) {
  return min5 + (max5 - min5) * factor;
}
function getFillAttrs(cfg) {
  var attrs = __assign({ opacity: 1 }, cfg.style);
  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }
  return attrs;
}
function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: "#fff",
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = mix({}, defaultAttrs, cfg.style);
  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }
  if (is_number_default(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }
  return attrs;
}
function getWaterWavePositions(x, stage, waveLength, amplitude2) {
  if (stage === 0) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, amplitude2 / 2],
      [x + 1 / 2 * waveLength / Math.PI, amplitude2],
      [x + waveLength / 4, amplitude2]
    ];
  }
  if (stage === 1) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude2],
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude2 / 2],
      [x + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude2 / 2],
      [x + 1 / 2 * waveLength / Math.PI, -amplitude2],
      [x + waveLength / 4, -amplitude2]
    ];
  }
  return [
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude2],
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude2 / 2],
    [x + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude2, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path = [];
  var _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  var left2 = cx - radius + _phase - radius * 2;
  path.push(["M", left2, waterLevel]);
  var waveRight = 0;
  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude2);
    path.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path.push(["L", waveRight + left2, cy + radius]);
  path.push(["L", left2, cy + radius]);
  path.push(["Z"]);
  return path;
}
function addWaterWave(x, y, level, waveCount, waveAttrs, group2, clip, radius, waveLength, animation7) {
  var fill2 = waveAttrs.fill, opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;
  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    var wave = group2.addShape("path", {
      name: "waterwave-path",
      attrs: {
        // 
        path: getWaterWavePath(
          radius,
          bbox.minY + height * level,
          waveLength,
          0,
          width / 32,
          // 
          x,
          y
        ),
        fill: fill2,
        opacity: lerp4(0.2, 0.9, factor) * opacity
      }
    });
    try {
      if (animation7 === false)
        return;
      var matrix = transform5([["t", waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({ matrix }, {
        duration: lerp4(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}
function pin(x, y, width, height) {
  var w = width * 2 / 3;
  var h = Math.max(w, height);
  var r = w / 2;
  var cx = x;
  var cy = r + y - h / 2;
  var theta = Math.asin(r / ((h - r) * 0.85));
  var dy = Math.sin(theta) * r;
  var dx = Math.cos(theta) * r;
  var x0 = cx - dx;
  var y0 = cy + dy;
  var cpX = x;
  var cpY = cy + r / Math.sin(theta);
  return "\n      M ".concat(x0, " ").concat(y0, "\n      A ").concat(r, " ").concat(r, " 0 1 1 ").concat(x0 + dx * 2, " ").concat(y0, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x, " ").concat(y + h / 2, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x0, " ").concat(y0, "\n      Z \n    ");
}
function circle(x, y, width, height) {
  var rx = width / 2;
  var ry = height / 2;
  return "\n      M ".concat(x, " ").concat(y - ry, " \n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(ry * 2, "\n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(-ry * 2, "\n      Z\n    ");
}
function diamond(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y, "\n      L ").concat(x, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y, "\n      Z\n    ");
}
function triangle(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
function rect(x, y, width, height) {
  var GOLDEN_SECTION_RATIO = 0.618;
  var h = height / 2;
  var w = width / 2 * GOLDEN_SECTION_RATIO;
  return "\n      M ".concat(x - w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
var builtInShapeByName = {
  pin,
  circle,
  diamond,
  triangle,
  rect
};
registerShape("interval", "liquid-fill-gauge", {
  draw: function(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var _a6 = customInfo, percent2 = _a6.percent, radio = _a6.radius, shape = _a6.shape, shapeStyle = _a6.shapeStyle, background = _a6.background, animation7 = _a6.animation;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border, distance9 = outline.distance;
    var waveCount = wave.count, waveLength = wave.length;
    var minX = reduce_default(cfg.points, function(r, p) {
      return Math.min(r, p.x);
    }, Infinity);
    var center2 = this.parsePoint({ x: cx, y: cy });
    var minXPoint = this.parsePoint({ x: minX, y: cy });
    var halfWidth = center2.x - minXPoint.x;
    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs(cfg);
    var outlineAttrs = getLineAttrs(mix({}, cfg, outline));
    var innerRadius = radius - border / 2;
    var buildPath = typeof shape === "function" ? shape : builtInShapeByName[shape] || builtInShapeByName["circle"];
    var shapePath = buildPath(center2.x, center2.y, innerRadius * 2, innerRadius * 2);
    if (shapeStyle) {
      container.addShape("path", {
        name: "shape",
        attrs: __assign({ path: shapePath }, shapeStyle)
      });
    }
    if (percent2 > 0) {
      var waves = container.addGroup({
        name: "waves"
      });
      var clipPath = waves.setClip({
        type: "path",
        attrs: {
          path: shapePath
        }
      });
      addWaterWave(center2.x, center2.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength, animation7);
    }
    container.addShape("path", {
      name: "distance",
      attrs: {
        path: shapePath,
        fill: "transparent",
        lineWidth: border + distance9 * 2,
        stroke: background === "transparent" ? "#fff" : background
      }
    });
    container.addShape("path", {
      name: "wrap",
      attrs: mix(outlineAttrs, {
        path: shapePath,
        fill: "transparent",
        lineWidth: border
      })
    });
    return container;
  }
});

// node_modules/@antv/g2plot/esm/plots/liquid/index.js
var Liquid = (
  /** @class */
  function(_super) {
    __extends(Liquid2, _super);
    function Liquid2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "liquid";
      return _this;
    }
    Liquid2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS24;
    };
    Liquid2.prototype.getDefaultOptions = function() {
      return Liquid2.getDefaultOptions();
    };
    Liquid2.prototype.changeData = function(percent2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ percent: percent2 });
      this.chart.data(getLiquidData(percent2));
      statistic3({ chart: this.chart, options: this.options }, true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    Liquid2.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return Liquid2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/radar/adaptor.js
function geometry26(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, lineStyle = options.lineStyle, color3 = options.color, pointOptions = options.point, areaOptions = options.area;
  chart.data(data3);
  var primary = deepAssign({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color3
      },
      point: pointOptions ? __assign({ color: color3 }, pointOptions) : pointOptions,
      area: areaOptions ? __assign({ color: color3 }, areaOptions) : areaOptions,
      // label  geometry adaptor label adaptor 
      label: void 0
    }
  });
  var second = deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  area(second);
  return params;
}
function meta16(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6)))(params);
}
function coord(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate("polar", {
    radius,
    startAngle,
    endAngle
  });
  return params;
}
function axis14(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function label11(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField;
  var geometry35 = findGeometry(chart, "line");
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor26(params) {
  return flow(geometry26, meta16, theme, coord, axis14, legend, tooltip, label11, interaction, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/radar/interactions/radar-tooltip-action.js
var RadarTooltipController = (
  /** @class */
  function(_super) {
    __extends(RadarTooltipController2, _super);
    function RadarTooltipController2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RadarTooltipController2.prototype, "name", {
      get: function() {
        return "radar-tooltip";
      },
      enumerable: false,
      configurable: true
    });
    RadarTooltipController2.prototype.getTooltipItems = function(point2) {
      var _a6 = this.getTooltipCfg(), shared = _a6.shared, cfgTitle = _a6.title;
      var hintItems = _super.prototype.getTooltipItems.call(this, point2);
      if (hintItems.length > 0) {
        var geometry_1 = this.view.geometries[0];
        var dataArray = geometry_1.dataArray;
        var title_1 = hintItems[0].name;
        var result_1 = [];
        dataArray.forEach(function(mappingData) {
          mappingData.forEach(function(d) {
            var items = Util.getTooltipItems(d, geometry_1);
            var item = items[0];
            if (!shared && item && item.name === title_1) {
              var displayTitle = is_nil_default(cfgTitle) ? title_1 : cfgTitle;
              result_1.push(__assign(__assign({}, item), { name: item.title, title: displayTitle }));
            } else if (shared && item) {
              var displayTitle = is_nil_default(cfgTitle) ? item.name || title_1 : cfgTitle;
              result_1.push(__assign(__assign({}, item), { name: item.title, title: displayTitle }));
            }
          });
        });
        return result_1;
      }
      return [];
    };
    return RadarTooltipController2;
  }(tooltip_default)
);
registerComponentController("radar-tooltip", RadarTooltipController);
var RadarTooltipAction = (
  /** @class */
  function(_super) {
    __extends(RadarTooltipAction2, _super);
    function RadarTooltipAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RadarTooltipAction2.prototype.init = function() {
      var view = this.context.view;
      view.removeInteraction("tooltip");
    };
    RadarTooltipAction2.prototype.show = function() {
      var event = this.context.event;
      var controller = this.getTooltipController();
      controller.showTooltip({ x: event.x, y: event.y });
    };
    RadarTooltipAction2.prototype.hide = function() {
      var controller = this.getTooltipController();
      controller.hideTooltip();
    };
    RadarTooltipAction2.prototype.getTooltipController = function() {
      var view = this.context.view;
      return view.getController("radar-tooltip");
    };
    return RadarTooltipAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/radar/interactions/index.js
registerAction("radar-tooltip", RadarTooltipAction);
registerInteraction("radar-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "radar-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "radar-tooltip:hide" }]
});

// node_modules/@antv/g2plot/esm/plots/radar/index.js
var Radar = (
  /** @class */
  function(_super) {
    __extends(Radar2, _super);
    function Radar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radar";
      return _this;
    }
    Radar2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      this.chart.changeData(data3);
    };
    Radar2.prototype.getDefaultOptions = function() {
      return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
        xAxis: {
          label: {
            offset: 15
          },
          grid: {
            line: {
              type: "line"
            }
          }
        },
        yAxis: {
          grid: {
            line: {
              type: "circle"
            }
          }
        },
        legend: {
          position: "top"
        },
        tooltip: {
          shared: true,
          showCrosshairs: true,
          showMarkers: true,
          crosshairs: {
            type: "xy",
            line: {
              style: {
                stroke: "#565656",
                lineDash: [4]
              }
            },
            follow: true
          }
        }
      });
    };
    Radar2.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Radar2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/radial-bar/utils.js
function getScaleMax(maxAngle, yField, data3) {
  var yData = data3.map(function(item) {
    return item[yField];
  }).filter(function(v) {
    return v !== void 0;
  });
  var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
  var formatRadian = Math.abs(maxAngle) % 360;
  if (!formatRadian) {
    return maxValue;
  }
  return maxValue * 360 / formatRadian;
}
function getStackedData(data3, xField, yField) {
  var stackedData = [];
  data3.forEach(function(item) {
    var valueItem = stackedData.find(function(v) {
      return v[xField] === item[xField];
    });
    if (valueItem) {
      valueItem[yField] += item[yField] || null;
    } else {
      stackedData.push(__assign({}, item));
    }
  });
  return stackedData;
}

// node_modules/@antv/g2plot/esm/plots/radial-bar/adaptor.js
function geometry27(params) {
  var chart = params.chart, options = params.options;
  var style = options.barStyle, color3 = options.color, tooltip11 = options.tooltip, colorField = options.colorField, type = options.type, xField = options.xField, yField = options.yField, data3 = options.data, shape = options.shape;
  var processData2 = processIllegalData(data3, yField);
  chart.data(processData2);
  var p = deepAssign({}, params, {
    options: {
      tooltip: tooltip11,
      seriesField: colorField,
      interval: {
        style,
        color: color3,
        shape: shape || (type === "line" ? "line" : "intervel")
      },
      // 
      minColumnWidth: options.minBarWidth,
      maxColumnWidth: options.maxBarWidth,
      columnBackground: options.barBackground
    }
  });
  interval2(p);
  if (type === "line") {
    point({
      chart,
      options: { xField, yField, seriesField: colorField, point: { shape: "circle", color: color3 } }
    });
  }
  return params;
}
function meta17(params) {
  var _a6;
  var options = params.options;
  var yField = options.yField, xField = options.xField, data3 = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
  var actualData = isStack && !isGroup && colorField ? getStackedData(data3, xField, yField) : data3;
  var processData2 = processIllegalData(actualData, yField);
  return flow(scale5((_a6 = {}, _a6[yField] = {
    min: 0,
    max: getScaleMax(maxAngle, yField, processData2)
  }, _a6)))(params);
}
function coordinate8(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  }).transpose();
  return params;
}
function axis15(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis;
  chart.axis(xField, xAxis);
  return params;
}
function label12(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, yField = options.yField;
  var intervalGeometry = findGeometry(chart, "interval");
  if (!label17) {
    intervalGeometry.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    intervalGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign(__assign({}, transformLabel(cfg)), { type: "polar" })
    });
  }
  return params;
}
function adaptor27(params) {
  return flow(pattern("barStyle"), geometry27, meta17, axis15, coordinate8, interaction, animation, theme, tooltip, legend, annotation(), label12)(params);
}

// node_modules/@antv/g2plot/esm/plots/radial-bar/constant.js
var DEFAULT_OPTIONS25 = deepAssign({}, Plot.getDefaultOptions(), {
  interactions: [{ type: "element-active" }],
  legend: false,
  tooltip: {
    showMarkers: false
  },
  xAxis: {
    grid: null,
    tickLine: null,
    line: null
  },
  maxAngle: 240
});

// node_modules/@antv/g2plot/esm/plots/radial-bar/index.js
var RadialBar = (
  /** @class */
  function(_super) {
    __extends(RadialBar2, _super);
    function RadialBar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radial-bar";
      return _this;
    }
    RadialBar2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS25;
    };
    RadialBar2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      meta17({ chart: this.chart, options: this.options });
      this.chart.changeData(data3);
    };
    RadialBar2.prototype.getDefaultOptions = function() {
      return RadialBar2.getDefaultOptions();
    };
    RadialBar2.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/rose/adaptor.js
function geometry28(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, sectorStyle = options.sectorStyle, shape = options.shape, color3 = options.color;
  chart.data(data3);
  flow(interval2)(deepAssign({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color3,
        shape
      }
    }
  }));
  return params;
}
function label13(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, xField = options.xField;
  var geometry35 = findGeometry(chart, "interval");
  if (label17 === false) {
    geometry35.label(false);
  } else if (is_object_default(label17)) {
    var callback = label17.callback, fields = label17.fields, cfg = __rest(label17, ["callback", "fields"]);
    var offset = cfg.offset;
    var layout2 = cfg.layout;
    if (offset === void 0 || offset >= 0) {
      layout2 = layout2 ? is_array_default(layout2) ? layout2 : [layout2] : [];
      cfg.layout = filter_default(layout2, function(v) {
        return v.type !== "limit-in-shape";
      });
      cfg.layout.length || delete cfg.layout;
    }
    geometry35.label({
      fields: fields || [xField],
      callback,
      cfg: transformLabel(cfg)
    });
  } else {
    log2(LEVEL.WARN, label17 === null, "the label option must be an Object.");
    geometry35.label({ fields: [xField] });
  }
  return params;
}
function legend13(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, seriesField = options.seriesField;
  if (legend18 === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend18);
  }
  return params;
}
function coordinate9(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function meta18(params) {
  var _a6;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6)))(params);
}
function axis16(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function adaptor28(params) {
  flow(pattern("sectorStyle"), geometry28, meta18, label13, coordinate9, axis16, legend13, tooltip, interaction, animation, theme, annotation(), state)(params);
}

// node_modules/@antv/g2plot/esm/plots/rose/constant.js
var DEFAULT_OPTIONS26 = deepAssign({}, Plot.getDefaultOptions(), {
  xAxis: false,
  yAxis: false,
  legend: {
    position: "right",
    radio: {}
  },
  sectorStyle: {
    stroke: "#fff",
    lineWidth: 1
  },
  label: {
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});

// node_modules/@antv/g2plot/esm/plots/rose/index.js
var Rose = (
  /** @class */
  function(_super) {
    __extends(Rose2, _super);
    function Rose2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rose";
      return _this;
    }
    Rose2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS26;
    };
    Rose2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      this.chart.changeData(data3);
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/sankey/constant.js
var X_FIELD3 = "x";
var Y_FIELD4 = "y";
var COLOR_FIELD = "name";
var NODES_VIEW_ID = "nodes";
var EDGES_VIEW_ID = "edges";

// node_modules/@antv/g2plot/esm/plots/sankey/circle.js
function getNodes(edges, sourceField, targetField) {
  var nodes = [];
  edges.forEach(function(e) {
    var source = e[sourceField];
    var target = e[targetField];
    if (!nodes.includes(source)) {
      nodes.push(source);
    }
    if (!nodes.includes(target)) {
      nodes.push(target);
    }
  });
  return nodes;
}
function getMatrix(edges, nodes, sourceField, targetField) {
  var graphMatrix = {};
  nodes.forEach(function(pre) {
    graphMatrix[pre] = {};
    nodes.forEach(function(next) {
      graphMatrix[pre][next] = 0;
    });
  });
  edges.forEach(function(edge2) {
    graphMatrix[edge2[sourceField]][edge2[targetField]] = 1;
  });
  return graphMatrix;
}
function cutoffCircle(edges, sourceField, targetField) {
  if (!is_array_default(edges))
    return [];
  var removedData = [];
  var nodes = getNodes(edges, sourceField, targetField);
  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
  var visited = {};
  nodes.forEach(function(node) {
    visited[node] = 0;
  });
  function DFS(dfsNode) {
    visited[dfsNode] = 1;
    nodes.forEach(function(node) {
      if (graphMatrix[dfsNode][node] != 0) {
        if (visited[node] == 1) {
          removedData.push("".concat(dfsNode, "_").concat(node));
        } else if (visited[node] == -1) {
          return;
        } else {
          DFS(node);
        }
      }
    });
    visited[dfsNode] = -1;
  }
  nodes.forEach(function(node) {
    if (visited[node] == -1) {
      return;
    }
    DFS(node);
  });
  if (removedData.length !== 0) {
    console.warn("sankey data contains circle, ".concat(removedData.length, " records removed."), removedData);
  }
  return edges.filter(function(edge2) {
    return removedData.findIndex(function(i) {
      return i === "".concat(edge2[sourceField], "_").concat(edge2[targetField]);
    }) < 0;
  });
}

// node_modules/@antv/g2plot/esm/plots/sankey/sankey/align.js
function targetDepth(d) {
  return d.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min_by_default(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2plot/esm/plots/sankey/sankey/helper.js
function constant(x) {
  return function() {
    return x;
  };
}
function sumBy(arr, func) {
  var r = 0;
  for (var i = 0; i < arr.length; i++) {
    r += func(arr[i]);
  }
  return r;
}
function maxValueBy(arr, func) {
  var r = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.max(func(arr[i]), r);
  }
  return r;
}
function minValueBy(arr, func) {
  var r = Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.min(func(arr[i]), r);
  }
  return r;
}

// node_modules/@antv/g2plot/esm/plots/sankey/sankey/sankey.js
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId2(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find2(nodeById, id) {
  var node = nodeById.get(id);
  if (!node)
    throw new Error("missing: " + id);
  return node;
}
function computeLinkBreadths(_a6) {
  var nodes = _a6.nodes;
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node = nodes_1[_i];
    var y0 = node.y0;
    var y1 = y0;
    for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
      var link = _c[_b];
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
      var link = _e[_d];
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  var x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  var dx = 24;
  var dy = 8, py;
  var id = defaultId2;
  var align = justify;
  var depth;
  var sort;
  var linkSort;
  var nodes = defaultNodes;
  var links = defaultLinks;
  var iterations = 6;
  function sankey(arg) {
    var graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id = typeof _ === "function" ? _ : constant(_), sankey) : id;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
  };
  sankey.nodeDepth = function(_) {
    return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [
      [x0, y0],
      [x1, y1]
    ];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks(_a6) {
    var nodes2 = _a6.nodes, links2 = _a6.links;
    nodes2.forEach(function(node, idx) {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = new Map(nodes2.map(function(d) {
      return [id(d), d];
    }));
    links2.forEach(function(link, idx) {
      link.index = idx;
      var source = link.source, target = link.target;
      if (typeof source !== "object")
        source = link.source = find2(nodeById, source);
      if (typeof target !== "object")
        target = link.target = find2(nodeById, target);
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
    if (linkSort != null) {
      for (var _i = 0, nodes_2 = nodes2; _i < nodes_2.length; _i++) {
        var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues(_a6) {
    var nodes2 = _a6.nodes;
    for (var _i = 0, nodes_3 = nodes2; _i < nodes_3.length; _i++) {
      var node = nodes_3[_i];
      node.value = node.fixedValue === void 0 ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths(_a6) {
    var nodes2 = _a6.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node2) {
        node2.depth = x;
        for (var _i = 0, _a7 = node2.sourceLinks; _i < _a7.length; _i++) {
          var target = _a7[_i].target;
          next.add(target);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      var maxDepth = Math.max(maxValueBy(nodes2, function(d) {
        return d.depth;
      }) + 1, 0);
      var node = void 0;
      for (var i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth);
      }
    }
  }
  function computeNodeHeights(_a6) {
    var nodes2 = _a6.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node) {
        node.height = x;
        for (var _i = 0, _a7 = node.targetLinks; _i < _a7.length; _i++) {
          var source = _a7[_i].source;
          next.add(source);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers(_a6) {
    var nodes2 = _a6.nodes;
    var x = Math.max(maxValueBy(nodes2, function(d) {
      return d.depth;
    }) + 1, 0);
    var kx = (x1 - x0 - dx) / (x - 1);
    var columns = new Array(x).fill(0).map(function() {
      return [];
    });
    for (var _i = 0, nodes_4 = nodes2; _i < nodes_4.length; _i++) {
      var node = nodes_4[_i];
      var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort)
      for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {
        var column = columns_1[_b];
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    var ky = minValueBy(columns, function(c) {
      return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value);
    });
    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
      var nodes_6 = columns_2[_i];
      var y = y0;
      for (var _a6 = 0, nodes_5 = nodes_6; _a6 < nodes_5.length; _a6++) {
        var node = nodes_5[_a6];
        node.y0 = y;
        node.y1 = y + node.value * ky;
        y = node.y1 + py;
        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
          var link = _c[_b];
          link.width = link.value * ky;
        }
      }
      y = (y1 - y + py) / (nodes_6.length + 1);
      for (var i = 0; i < nodes_6.length; ++i) {
        var node = nodes_6[i];
        node.y0 += y * (i + 1);
        node.y1 += y * (i + 1);
      }
      reorderLinks(nodes_6);
    }
  }
  function computeNodeBreadths(graph) {
    var columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function(c) {
      return c.length;
    }) - 1));
    initializeNodeBreadths(columns);
    for (var i = 0; i < iterations; ++i) {
      var alpha = Math.pow(0.99, i);
      var beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (var i = 1, n = columns.length; i < n; ++i) {
      var column = columns[i];
      for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
        var target = column_1[_i];
        var y = 0;
        var w = 0;
        for (var _a6 = 0, _b = target.targetLinks; _a6 < _b.length; _a6++) {
          var _c = _b[_a6], source = _c.source, value_1 = _c.value;
          var v = value_1 * (target.layer - source.layer);
          y += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_1 = (y / w - target.y0) * alpha;
        target.y0 += dy_1;
        target.y1 += dy_1;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (var n = columns.length, i = n - 2; i >= 0; --i) {
      var column = columns[i];
      for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
        var source = column_2[_i];
        var y = 0;
        var w = 0;
        for (var _a6 = 0, _b = source.sourceLinks; _a6 < _b.length; _a6++) {
          var _c = _b[_a6], target = _c.target, value_2 = _c.value;
          var v = value_2 * (target.layer - source.layer);
          y += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_2 = (y / w - source.y0) * alpha;
        source.y0 += dy_2;
        source.y1 += dy_2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    var i = nodes2.length >> 1;
    var subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y, i, alpha) {
    for (; i < nodes2.length; ++i) {
      var node = nodes2[i];
      var dy_3 = (y - node.y0) * alpha;
      if (dy_3 > 1e-6)
        node.y0 += dy_3, node.y1 += dy_3;
      y = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y, i, alpha) {
    for (; i >= 0; --i) {
      var node = nodes2[i];
      var dy_4 = (node.y1 - y) * alpha;
      if (dy_4 > 1e-6)
        node.y0 -= dy_4, node.y1 -= dy_4;
      y = node.y0 - py;
    }
  }
  function reorderNodeLinks(_a6) {
    var sourceLinks = _a6.sourceLinks, targetLinks = _a6.targetLinks;
    if (linkSort === void 0) {
      for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {
        var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;
        sourceLinks_2.sort(ascendingTargetBreadth);
      }
      for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {
        var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;
        targetLinks_2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (var _i = 0, nodes_7 = nodes2; _i < nodes_7.length; _i++) {
        var _a6 = nodes_7[_i], sourceLinks = _a6.sourceLinks, targetLinks = _a6.targetLinks;
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (var _i = 0, _a6 = source.sourceLinks; _i < _a6.length; _i++) {
      var _b = _a6[_i], node = _b.target, width = _b.width;
      if (node === target)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.source, width = _e.width;
      if (node === source)
        break;
      y -= width;
    }
    return y;
  }
  function sourceTop(source, target) {
    var y = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (var _i = 0, _a6 = target.targetLinks; _i < _a6.length; _i++) {
      var _b = _a6[_i], node = _b.source, width = _b.width;
      if (node === source)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.target, width = _e.width;
      if (node === target)
        break;
      y -= width;
    }
    return y;
  }
  return sankey;
}

// node_modules/@antv/g2plot/esm/plots/sankey/layout.js
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
var DEFAULT_OPTIONS27 = {
  nodeId: function(node) {
    return node.index;
  },
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodeSort: void 0
};
function getNodeAlignFunction(nodeAlign) {
  var func = is_string_default(nodeAlign) ? ALIGN_METHOD[nodeAlign] : is_function_default(nodeAlign) ? nodeAlign : null;
  return func || justify;
}
function getDefaultOptions2(sankeyLayoutOptions) {
  return mix({}, DEFAULT_OPTIONS27, sankeyLayoutOptions);
}
function sankeyLayout(sankeyLayoutOptions, data3) {
  var options = getDefaultOptions2(sankeyLayoutOptions);
  var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
  var sankeyProcessor = Sankey().nodeSort(nodeSort).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([
    [0, 0],
    [1, 1]
  ]).nodeId(nodeId);
  var layoutData = sankeyProcessor(data3);
  var nodes = layoutData.nodes.map(function(node) {
    var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
    node.x = [x0, x1, x1, x0];
    node.y = [y0, y0, y1, y1];
    return node;
  }).filter(function(node) {
    return node.name !== null;
  });
  var links = layoutData.links.map(function(edge2) {
    var source = edge2.source, target = edge2.target;
    var sx = source.x1;
    var tx = target.x0;
    edge2.x = [sx, sx, tx, tx];
    var offset = edge2.width / 2;
    edge2.y = [edge2.y0 + offset, edge2.y0 - offset, edge2.y1 + offset, edge2.y1 - offset];
    return edge2;
  }).filter(function(edge2) {
    var source = edge2.source, target = edge2.target;
    return source.name !== null && target.name !== null;
  });
  return { nodes, links };
}

// node_modules/@antv/g2plot/esm/plots/sankey/helper.js
function isNodeLink(dataType) {
  return dataType === "node-link";
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
  return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
  return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
function transformToViewsData(options, width, height) {
  var dataType = options.dataType, data3 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6;
  var sankeyLayoutInputData;
  if (!isNodeLink(dataType)) {
    sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data3, sourceField, targetField), sourceField, targetField, weightField, rawFields);
  } else {
    sankeyLayoutInputData = data3;
  }
  var _b = sankeyLayout({
    nodeAlign,
    nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
    nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
    nodeSort,
    nodeDepth
  }, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
  return {
    nodes: nodes.map(function(node) {
      return __assign(__assign({}, pick(node, __spreadArray(["x", "y", "name"], rawFields, true))), { isNode: true });
    }),
    edges: links.map(function(link) {
      return __assign(__assign({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArray(["x", "y", "value"], rawFields, true))), { isNode: false });
    })
  };
}

// node_modules/@antv/g2plot/esm/plots/sankey/adaptor.js
function defaultOptions5(params) {
  var options = params.options;
  var _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6;
  return deepAssign({}, {
    options: {
      tooltip: {
        fields: uniq(__spreadArray(["name", "source", "target", "value", "isNode"], rawFields, true))
      },
      label: {
        fields: uniq(__spreadArray(["x", "name"], rawFields, true))
      }
    }
  }, params);
}
function geometry29(params) {
  var chart = params.chart, options = params.options;
  var color3 = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label17 = options.label, tooltip11 = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState, _a6 = options.rawFields, rawFields = _a6 === void 0 ? [] : _a6;
  chart.legend(false);
  chart.tooltip(tooltip11);
  chart.axis(false);
  chart.coordinate().reflect("y");
  var _b = transformToViewsData(options, chart.width, chart.height), nodes = _b.nodes, edges = _b.edges;
  var edgeView = chart.createView({ id: EDGES_VIEW_ID });
  edgeView.data(edges);
  edge({
    chart: edgeView,
    // @ts-ignore
    options: {
      xField: X_FIELD3,
      yField: Y_FIELD4,
      seriesField: COLOR_FIELD,
      rawFields: __spreadArray(["source", "target"], rawFields, true),
      edge: {
        color: color3,
        style: edgeStyle,
        shape: "arc"
      },
      tooltip: tooltip11,
      state: edgeState
    }
  });
  var nodeView = chart.createView({ id: NODES_VIEW_ID });
  nodeView.data(nodes);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD3,
      yField: Y_FIELD4,
      seriesField: COLOR_FIELD,
      polygon: {
        color: color3,
        style: nodeStyle
      },
      label: label17,
      tooltip: tooltip11,
      state: nodeState
    }
  });
  chart.interaction("element-active");
  chart.scale({
    x: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    y: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    name: { sync: "color", type: "cat" }
  });
  return params;
}
function animation5(params) {
  var chart = params.chart, options = params.options;
  var animation7 = options.animation;
  var geometries = __spreadArray(__spreadArray([], chart.views[0].geometries, true), chart.views[1].geometries, true);
  addViewAnimation(chart, animation7, geometries);
  return params;
}
function nodeDraggable(params) {
  var chart = params.chart, options = params.options;
  var nodeDraggable2 = options.nodeDraggable;
  var DRAG_INTERACTION = "sankey-node-draggable";
  if (nodeDraggable2) {
    chart.interaction(DRAG_INTERACTION);
  } else {
    chart.removeInteraction(DRAG_INTERACTION);
  }
  return params;
}
function interaction7(params) {
  var chart = params.chart, options = params.options;
  var _a6 = options.interactions, interactions = _a6 === void 0 ? [] : _a6;
  var nodeInteractions = [].concat(interactions, options.nodeInteractions || []);
  var edgeInteractions = [].concat(interactions, options.edgeInteractions || []);
  var nodeView = findViewById(chart, NODES_VIEW_ID);
  var edgeView = findViewById(chart, EDGES_VIEW_ID);
  nodeInteractions.forEach(function(i) {
    if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
      nodeView.removeInteraction(i.type);
    } else {
      nodeView.interaction(i.type, i.cfg || {});
    }
  });
  edgeInteractions.forEach(function(i) {
    if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
      edgeView.removeInteraction(i.type);
    } else {
      edgeView.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor29(params) {
  return flow(
    defaultOptions5,
    geometry29,
    interaction7,
    nodeDraggable,
    animation5,
    theme
    // ...  adaptor flow
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/sankey/interactions/actions/node-drag.js
var SankeyNodeDragAction = (
  /** @class */
  function(_super) {
    __extends(SankeyNodeDragAction2, _super);
    function SankeyNodeDragAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isDragging = false;
      return _this;
    }
    SankeyNodeDragAction2.prototype.isNodeElement = function() {
      var shape = get_default(this.context, "event.target");
      if (shape) {
        var element = shape.get("element");
        return element && element.getModel().data.isNode;
      }
      return false;
    };
    SankeyNodeDragAction2.prototype.getNodeView = function() {
      return findViewById(this.context.view, NODES_VIEW_ID);
    };
    SankeyNodeDragAction2.prototype.getEdgeView = function() {
      return findViewById(this.context.view, EDGES_VIEW_ID);
    };
    SankeyNodeDragAction2.prototype.getCurrentDatumIdx = function(element) {
      return this.getNodeView().geometries[0].elements.indexOf(element);
    };
    SankeyNodeDragAction2.prototype.start = function() {
      if (this.isNodeElement()) {
        this.prevPoint = {
          x: get_default(this.context, "event.x"),
          y: get_default(this.context, "event.y")
        };
        var element = this.context.event.target.get("element");
        var idx = this.getCurrentDatumIdx(element);
        if (idx === -1) {
          return;
        }
        this.currentElementIdx = idx;
        this.context.isDragging = true;
        this.isDragging = true;
        this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
        this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
        this.getNodeView().animate(false);
        this.getEdgeView().animate(false);
      }
    };
    SankeyNodeDragAction2.prototype.translate = function() {
      if (this.isDragging) {
        var chart = this.context.view;
        var currentPoint = {
          x: get_default(this.context, "event.x"),
          y: get_default(this.context, "event.y")
        };
        var x = currentPoint.x - this.prevPoint.x;
        var y = currentPoint.y - this.prevPoint.y;
        var nodeView = this.getNodeView();
        var element = nodeView.geometries[0].elements[this.currentElementIdx];
        if (element && element.getModel()) {
          var prevDatum = element.getModel().data;
          var data3 = nodeView.getOptions().data;
          var coordinate11 = nodeView.getCoordinate();
          var datumGap_1 = {
            x: x / coordinate11.getWidth(),
            y: y / coordinate11.getHeight()
          };
          var nextDatum = __assign(__assign({}, prevDatum), { x: prevDatum.x.map(function(x2) {
            return x2 += datumGap_1.x;
          }), y: prevDatum.y.map(function(y2) {
            return y2 += datumGap_1.y;
          }) });
          var newData = __spreadArray([], data3, true);
          newData[this.currentElementIdx] = nextDatum;
          nodeView.data(newData);
          var name_1 = prevDatum.name;
          var edgeView = this.getEdgeView();
          var edgeData = edgeView.getOptions().data;
          edgeData.forEach(function(datum) {
            if (datum.source === name_1) {
              datum.x[0] += datumGap_1.x;
              datum.x[1] += datumGap_1.x;
              datum.y[0] += datumGap_1.y;
              datum.y[1] += datumGap_1.y;
            }
            if (datum.target === name_1) {
              datum.x[2] += datumGap_1.x;
              datum.x[3] += datumGap_1.x;
              datum.y[2] += datumGap_1.y;
              datum.y[3] += datumGap_1.y;
            }
          });
          edgeView.data(edgeData);
          this.prevPoint = currentPoint;
          chart.render(true);
        }
      }
    };
    SankeyNodeDragAction2.prototype.end = function() {
      this.isDragging = false;
      this.context.isDragging = false;
      this.prevPoint = null;
      this.currentElementIdx = null;
      this.getNodeView().animate(this.prevNodeAnimateCfg);
      this.getEdgeView().animate(this.prevEdgeAnimateCfg);
    };
    return SankeyNodeDragAction2;
  }(base_default12)
);

// node_modules/@antv/g2plot/esm/plots/sankey/interactions/node-draggable.js
registerAction("sankey-node-drag", SankeyNodeDragAction);
registerInteraction("sankey-node-draggable", {
  showEnable: [
    { trigger: "polygon:mouseenter", action: "cursor:pointer" },
    { trigger: "polygon:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "polygon:mousedown", action: "sankey-node-drag:start" }],
  processing: [
    { trigger: "plot:mousemove", action: "sankey-node-drag:translate" },
    { isEnable: function(context) {
      return context.isDragging;
    }, trigger: "plot:mousemove", action: "cursor:move" }
  ],
  end: [{ trigger: "plot:mouseup", action: "sankey-node-drag:end" }]
});

// node_modules/@antv/g2plot/esm/plots/sankey/index.js
var Sankey2 = (
  /** @class */
  function(_super) {
    __extends(Sankey3, _super);
    function Sankey3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "sankey";
      return _this;
    }
    Sankey3.getDefaultOptions = function() {
      return {
        appendPadding: 8,
        syncViewPadding: true,
        nodeStyle: {
          opacity: 1,
          fillOpacity: 1,
          lineWidth: 1
        },
        edgeStyle: {
          opacity: 0.3,
          lineWidth: 0
        },
        edgeState: {
          active: {
            style: {
              opacity: 0.8,
              lineWidth: 0
            }
          }
        },
        label: {
          formatter: function(_a6) {
            var name = _a6.name;
            return name;
          },
          callback: function(x) {
            var isLast = x[1] === 1;
            return {
              style: {
                fill: "#545454",
                textAlign: isLast ? "end" : "start"
              },
              offsetX: isLast ? -8 : 8
            };
          },
          layout: [
            {
              type: "hide-overlap"
            }
          ]
        },
        tooltip: {
          showTitle: false,
          showMarkers: false,
          shared: false,
          // node  tooltipedge  tooltip
          showContent: function(items) {
            return !get_default(items, [0, "data", "isNode"]);
          },
          formatter: function(datum) {
            var source = datum.source, target = datum.target, value2 = datum.value;
            return {
              name: source + " -> " + target,
              value: value2
            };
          }
        },
        nodeWidthRatio: 8e-3,
        nodePaddingRatio: 0.01,
        animation: {
          appear: {
            animation: "wave-in"
          },
          enter: {
            animation: "wave-in"
          }
        }
      };
    };
    Sankey3.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      var _a6 = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a6.nodes, edges = _a6.edges;
      var nodesView = findViewById(this.chart, NODES_VIEW_ID);
      var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
      nodesView.changeData(nodes);
      edgesView.changeData(edges);
    };
    Sankey3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    Sankey3.prototype.getDefaultOptions = function() {
      return Sankey3.getDefaultOptions();
    };
    return Sankey3;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/sunburst/constant.js
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
var SUNBURST_Y_FIELD = "value";
var SUNBURST_PATH_FIELD = "path";
var RAW_FIELDS2 = [
  SUNBURST_PATH_FIELD,
  NODE_INDEX_FIELD,
  NODE_ANCESTORS_FIELD,
  CHILD_NODE_COUNT,
  "name",
  "depth",
  "height"
];
var DEFAULT_OPTIONS28 = deepAssign({}, Plot.getDefaultOptions(), {
  innerRadius: 0,
  radius: 0.85,
  // 
  hierarchyConfig: {
    //  value
    field: "value"
  },
  // 
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20,
    showTitle: false
  },
  legend: false,
  // 
  sunburstStyle: {
    lineWidth: 0.5,
    stroke: "#FFF"
  },
  // 
  drilldown: { enabled: true }
});

// node_modules/@antv/g2plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS29 = {
  field: "value",
  size: [1, 1],
  round: false,
  padding: 0,
  // 
  sort: function(a, b) {
    return b.value - a.value;
  },
  as: ["x", "y"],
  //  parentValue,  true 
  ignoreParentValue: true
};
function partition(data3, options) {
  options = mix({}, DEFAULT_OPTIONS29, options);
  var as = options.as;
  if (!is_array_default(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field6;
  try {
    field6 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var partition3 = function(data4) {
    return partition_default().size(options.size).round(options.round).padding(options.padding)(
      /**
       * d3Hierarchy  sum  node  node  post-order traversal  value  node
       * for example:
       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
       * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
       * sum d  data, children 
       */
      hierarchy(data4).sum(function(d) {
        return size(d.children) ? options.ignoreParentValue ? 0 : d[field6] - reduce_default(d.children, function(a, b) {
          return a + b[field6];
        }, 0) : d[field6];
      }).sort(options.sort)
    );
  };
  var root2 = partition3(data3);
  var x = as[0];
  var y = as[1];
  root2.each(function(node) {
    var _a6, _b;
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a6 = node.data) === null || _a6 === void 0 ? void 0 : _a6.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}

// node_modules/@antv/g2plot/esm/utils/hierarchy/treemap.js
var DEFAULT_OPTIONS30 = {
  field: "value",
  tile: "treemapSquarify",
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ["x", "y"],
  // 
  sort: function(a, b) {
    return b.value - a.value;
  },
  // , treemapSquarify 
  ratio: 0.5 * (1 + Math.sqrt(5))
};
function getTileMethod(tile, ratio) {
  return tile === "treemapSquarify" ? src_exports3[tile].ratio(ratio) : src_exports3[tile];
}
function treemap(data3, options) {
  options = mix({}, DEFAULT_OPTIONS30, options);
  var as = options.as;
  if (!is_array_default(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field6;
  try {
    field6 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var tileMethod = getTileMethod(options.tile, options.ratio);
  var partition3 = function(data4) {
    return treemap_default().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
      /**
       * d3Hierarchy  sum  node  node  post-order traversal  value  node
       * for example:
       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
       * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
       * ignoreParentValue  true()  0 + 5 + 5 = 10
       * ignoreParentValue  false   10 + 5 + 5 = 20
       * sum d  data, children 
       */
      hierarchy(data4).sum(function(d) {
        return options.ignoreParentValue && d.children ? 0 : d[field6];
      }).sort(options.sort)
    );
  };
  var root2 = partition3(data3);
  var x = as[0];
  var y = as[1];
  root2.each(function(node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}

// node_modules/@antv/g2plot/esm/plots/sunburst/utils.js
function transformData7(options) {
  var data3 = options.data, colorField = options.colorField, rawFields = options.rawFields, _a6 = options.hierarchyConfig, hierarchyConfig = _a6 === void 0 ? {} : _a6;
  var activeDepth = hierarchyConfig.activeDepth;
  var transform9 = {
    partition,
    treemap
  };
  var seriesField = options.seriesField;
  var type = options.type || "partition";
  var nodes = transform9[type](data3, __assign(__assign({ field: seriesField || "value" }, omit_default(hierarchyConfig, ["activeDepth"])), {
    // @ts-ignore
    type: "hierarchy.".concat(type),
    as: ["x", "y"]
  }));
  var result2 = [];
  nodes.forEach(function(node) {
    var _a7;
    var _b, _c, _d, _e, _f;
    if (node.depth === 0) {
      return null;
    }
    if (activeDepth > 0 && node.depth > activeDepth) {
      return null;
    }
    var path = node.data.name;
    var ancestorNode = __assign({}, node);
    while (ancestorNode.depth > 1) {
      path = "".concat((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name, " / ").concat(path);
      ancestorNode = ancestorNode.parent;
    }
    var nodeInfo = __assign(__assign(__assign({}, pick(node.data, __spreadArray(__spreadArray([], rawFields || [], true), [hierarchyConfig.field], false))), (_a7 = {}, _a7[SUNBURST_PATH_FIELD] = path, _a7[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a7)), node);
    if (seriesField) {
      nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
    }
    if (colorField) {
      nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
    }
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, rawFields };
    result2.push(nodeInfo);
  });
  return result2;
}

// node_modules/@antv/g2plot/esm/plots/sunburst/adaptor.js
function geometry30(params) {
  var chart = params.chart, options = params.options;
  var color3 = options.color, _a6 = options.colorField, colorField = _a6 === void 0 ? SUNBURST_ANCESTOR_FIELD : _a6, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b, shape = options.shape;
  var data3 = transformData7(options);
  chart.data(data3);
  var style;
  if (sunburstStyle) {
    style = function(datum) {
      return deepAssign({}, {
        fillOpacity: Math.pow(0.85, datum.depth)
      }, is_function_default(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
    };
  }
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields: uniq(__spreadArray(__spreadArray([], RAW_FIELDS2, true), rawFields, true)),
      polygon: {
        color: color3,
        style,
        shape
      }
    }
  }));
  return params;
}
function axis17(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function label14(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label;
  var geometry35 = findGeometry(chart, "polygon");
  if (!label17) {
    geometry35.label(false);
  } else {
    var _a6 = label17.fields, fields = _a6 === void 0 ? ["name"] : _a6, callback = label17.callback, cfg = __rest(label17, ["fields", "callback"]);
    geometry35.label({
      fields,
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate10(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
  var coord2 = chart.coordinate({
    type: "polar",
    cfg: {
      innerRadius,
      radius
    }
  });
  if (reflect) {
    coord2.reflect(reflect);
  }
  return params;
}
function meta19(params) {
  var _a6;
  var options = params.options;
  var hierarchyConfig = options.hierarchyConfig, meta23 = options.meta;
  return flow(scale5({}, (_a6 = {}, _a6[SUNBURST_Y_FIELD] = get_default(meta23, get_default(hierarchyConfig, ["field"], "value")), _a6)))(params);
}
function tooltip9(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip;
  if (tooltip11 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip11;
    if (!get_default(tooltip11, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get_default(chart.getOptions(), "scales");
            var pathFormatter = get_default(scales, [SUNBURST_PATH_FIELD, "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get_default(scales, [SUNBURST_Y_FIELD, "formatter"], function(v) {
              return v;
            });
            return __assign(__assign({}, item), { name: pathFormatter(item.data[SUNBURST_PATH_FIELD]), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptorInteraction2(options) {
  var drilldown = options.drilldown, _a6 = options.interactions, interactions = _a6 === void 0 ? [] : _a6;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArray(__spreadArray([], interactions, true), [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData7 }
        }
      ], false)
    });
  }
  return options;
}
function interaction8(params) {
  var chart = params.chart, options = params.options;
  var drilldown = options.drilldown;
  interaction({
    chart,
    options: adaptorInteraction2(options)
  });
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor30(params) {
  return flow(theme, pattern("sunburstStyle"), geometry30, axis17, meta19, legend, coordinate10, tooltip9, label14, interaction8, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/sunburst/index.js
var Sunburst = (
  /** @class */
  function(_super) {
    __extends(Sunburst2, _super);
    function Sunburst2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "sunburst";
      return _this;
    }
    Sunburst2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS28;
    };
    Sunburst2.prototype.getDefaultOptions = function() {
      return Sunburst2.getDefaultOptions();
    };
    Sunburst2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    Sunburst2.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
    Sunburst2.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
    Sunburst2.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
    return Sunburst2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/treemap/utils.js
function findInteraction(interactions, interactionType) {
  if (!is_array_default(interactions))
    return void 0;
  return interactions.find(function(i) {
    return i.type === interactionType;
  });
}
function enableInteraction(interactions, interactionType) {
  var interaction10 = findInteraction(interactions, interactionType);
  return interaction10 && interaction10.enable !== false;
}
function enableDrillInteraction(options) {
  var interactions = options.interactions, drilldown = options.drilldown;
  return get_default(drilldown, "enabled") || enableInteraction(interactions, "treemap-drill-down");
}
function resetDrillDown(chart) {
  var drillDownInteraction = chart.interactions["drill-down"];
  if (!drillDownInteraction)
    return;
  var drillDownAction = drillDownInteraction.context.actions.find(function(i) {
    return i.name === "drill-down-action";
  });
  drillDownAction.reset();
}
function transformData8(options) {
  var data3 = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
  var nodes = treemap(data3, __assign(__assign({}, hierarchyConfig), {
    // @ts-ignore
    type: "hierarchy.treemap",
    field: "value",
    as: ["x", "y"]
  }));
  var result2 = [];
  nodes.forEach(function(node) {
    if (node.depth === 0) {
      return null;
    }
    if (enableDrillDown && node.depth !== 1) {
      return null;
    }
    if (!enableDrillDown && node.children) {
      return null;
    }
    var curPath = node.ancestors().map(function(n) {
      return {
        data: n.data,
        height: n.height,
        value: n.value
      };
    });
    var path = enableDrillDown && is_array_default(data3.path) ? curPath.concat(data3.path.slice(1)) : curPath;
    var nodeInfo = Object.assign({}, node.data, __assign({ x: node.x, y: node.y, depth: node.depth, value: node.value, path }, node));
    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function(n) {
        return n.data[colorField];
      });
      nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      nodeInfo[colorField] = node.data[colorField];
    }
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, enableDrillDown };
    result2.push(nodeInfo);
  });
  return result2;
}

// node_modules/@antv/g2plot/esm/plots/treemap/adaptor.js
function defaultOptions6(params) {
  var options = params.options;
  var colorField = options.colorField;
  return deepAssign({
    options: {
      rawFields: ["value"],
      tooltip: {
        fields: ["name", "value", colorField, "path"],
        formatter: function(data3) {
          return {
            name: data3.name,
            value: data3.value
          };
        }
      }
    }
  }, params);
}
function geometry31(params) {
  var chart = params.chart, options = params.options;
  var color3 = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
  var data3 = transformData8({
    data: options.data,
    colorField: options.colorField,
    enableDrillDown: enableDrillInteraction(options),
    hierarchyConfig
  });
  chart.data(data3);
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields,
      polygon: {
        color: color3,
        style: rectStyle
      }
    }
  }));
  chart.coordinate().reflect("y");
  return params;
}
function axis18(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction3(options) {
  var drilldown = options.drilldown, _a6 = options.interactions, interactions = _a6 === void 0 ? [] : _a6;
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    return deepAssign({}, options, {
      interactions: __spreadArray(__spreadArray([], interactions, true), [
        {
          type: "drill-down",
          //   API
          cfg: { drillDownConfig: drilldown, transformData: transformData8 }
        }
      ], false)
    });
  }
  return options;
}
function interaction9(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, drilldown = options.drilldown;
  interaction({
    chart,
    options: adaptorInteraction3(options)
  });
  var viewZoomInteraction = findInteraction(interactions, "view-zoom");
  if (viewZoomInteraction) {
    if (viewZoomInteraction.enable !== false) {
      chart.getCanvas().on("mousewheel", function(ev) {
        ev.preventDefault();
      });
    } else {
      chart.getCanvas().off("mousewheel");
    }
  }
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get_default(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor31(params) {
  return flow(defaultOptions6, theme, pattern("rectStyle"), geometry31, axis18, legend, tooltip, interaction9, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/treemap/constant.js
var DEFAULT_OPTIONS31 = {
  //  name 
  colorField: "name",
  rectStyle: {
    lineWidth: 1,
    stroke: "#fff"
  },
  hierarchyConfig: {
    tile: "treemapSquarify"
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  // 
  drilldown: {
    enabled: false,
    breadCrumb: {
      position: "bottom-left",
      rootText: "",
      dividerText: "/",
      textStyle: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.65)",
        cursor: "pointer"
      },
      activeTextStyle: {
        fill: "#87B5FF"
      }
    }
  }
};

// node_modules/@antv/g2plot/esm/plots/treemap/index.js
var Treemap = (
  /** @class */
  function(_super) {
    __extends(Treemap2, _super);
    function Treemap2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "treemap";
      return _this;
    }
    Treemap2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS31;
    };
    Treemap2.prototype.changeData = function(data3) {
      var _a6 = this.options, colorField = _a6.colorField, interactions = _a6.interactions, hierarchyConfig = _a6.hierarchyConfig;
      this.updateOption({ data: data3 });
      var transData = transformData8({
        data: data3,
        colorField,
        enableDrillDown: enableInteraction(interactions, "treemap-drill-down"),
        hierarchyConfig
      });
      this.chart.changeData(transData);
      resetDrillDown(this.chart);
    };
    Treemap2.prototype.getDefaultOptions = function() {
      return Treemap2.getDefaultOptions();
    };
    Treemap2.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Treemap2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/venn/constant.js
var ID_FIELD = "id";
var PATH_FIELD = "path";
var DEFAULT_OPTIONS32 = {
  appendPadding: [10, 0, 20, 0],
  blendMode: "multiply",
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["id", "size"],
    formatter: function(datum) {
      return { name: datum.id, value: datum.size };
    }
  },
  legend: { position: "top-left" },
  label: {
    style: {
      textAlign: "center",
      fill: "#fff"
    }
  },
  //  
  interactions: [{ type: "legend-filter", enable: false }],
  state: {
    active: {
      style: {
        stroke: "#000"
      }
    },
    selected: {
      style: {
        stroke: "#000",
        lineWidth: 2
      }
    },
    inactive: {
      style: {
        fillOpacity: 0.3,
        strokeOpacity: 0.3
      }
    }
  },
  // 
  defaultInteractions: ["tooltip", "venn-legend-active"]
};

// node_modules/@antv/g2plot/esm/plots/venn/interactions/util.js
function placeElementsOrdered(view) {
  if (!view) {
    return;
  }
  var elements = view.geometries[0].elements;
  elements.forEach(function(elem) {
    elem.shape.toFront();
  });
}

// node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/active.js
var ElementActiveAction = getActionClass("element-active");
var VennElementActive = (
  /** @class */
  function(_super) {
    __extends(VennElementActive2, _super);
    function VennElementActive2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementActive2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementActive2.prototype.active = function() {
      _super.prototype.active.call(this);
      this.syncElementsPos();
    };
    VennElementActive2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementActive2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementActive2;
  }(ElementActiveAction)
);

// node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/highlight.js
var ElementHighlightAction = getActionClass("element-highlight");
var VennElementHighlight = (
  /** @class */
  function(_super) {
    __extends(VennElementHighlight2, _super);
    function VennElementHighlight2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementHighlight2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementHighlight2.prototype.highlight = function() {
      _super.prototype.highlight.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementHighlight2;
  }(ElementHighlightAction)
);

// node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/selected.js
var ElementSelectedAction = getActionClass("element-selected");
var ElementSingleSelectedAction = getActionClass("element-single-selected");
var VennElementSelected = (
  /** @class */
  function(_super) {
    __extends(VennElementSelected2, _super);
    function VennElementSelected2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementSelected2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementSelected2.prototype.selected = function() {
      _super.prototype.selected.call(this);
      this.syncElementsPos();
    };
    VennElementSelected2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementSelected2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementSelected2;
  }(ElementSelectedAction)
);
var VennElementSingleSelected = (
  /** @class */
  function(_super) {
    __extends(VennElementSingleSelected2, _super);
    function VennElementSingleSelected2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementSingleSelected2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementSingleSelected2.prototype.selected = function() {
      _super.prototype.selected.call(this);
      this.syncElementsPos();
    };
    VennElementSingleSelected2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementSingleSelected2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementSingleSelected2;
  }(ElementSingleSelectedAction)
);

// node_modules/@antv/g2plot/esm/plots/venn/interactions/index.js
registerAction("venn-element-active", VennElementActive);
registerAction("venn-element-highlight", VennElementHighlight);
registerAction("venn-element-selected", VennElementSelected);
registerAction("venn-element-single-selected", VennElementSingleSelected);
registerInteraction("venn-element-active", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-active:reset" }]
});
registerInteraction("venn-element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-highlight:reset" }]
});
registerInteraction("venn-element-selected", {
  start: [{ trigger: "element:click", action: "venn-element-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-selected:reset"] }]
});
registerInteraction("venn-element-single-selected", {
  start: [{ trigger: "element:click", action: "venn-element-single-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-single-selected:reset"] }]
});
registerInteraction("venn-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "venn-element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "venn-element-active:reset"] }]
});
registerInteraction("venn-legend-highlight", {
  start: [
    {
      trigger: "legend-item:mouseenter",
      action: ["legend-item-highlight:highlight", "venn-element-highlight:highlight"]
    }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "venn-element-highlight:reset"] }]
});

// node_modules/@antv/g2plot/esm/plots/venn/label.js
var VennLabel = (
  /** @class */
  function(_super) {
    __extends(VennLabel2, _super);
    function VennLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var _a6 = labelCfg.data, x = _a6.x, y = _a6.y;
      var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
      return {
        content: labelCfg.content[index],
        x: x + offsetX,
        y: y + offsetY
      };
    };
    return VennLabel2;
  }(base_default14)
);
registerGeometryLabel("venn", VennLabel);

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto2 = Object.prototype;
var hasOwnProperty4 = objectProto2.hasOwnProperty;
var nativeObjectToString = objectProto2.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty4.call(value2, symToStringTag), tag = value2[symToStringTag];
  try {
    value2[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag] = tag;
    } else {
      delete value2[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto3 = Object.prototype;
var nativeObjectToString2 = objectProto3.toString;
function objectToString(value2) {
  return nativeObjectToString2.call(value2);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag_default(value2) : objectToString_default(value2);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike3(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_default = isObjectLike3;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike_default(value2) && baseGetTag_default(value2) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN;
  }
  return +value2;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee2) {
  var index = -1, length5 = array == null ? 0 : array.length, result2 = Array(length5);
  while (++index < length5) {
    result2[index] = iteratee2(array[index], index, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray2 = Array.isArray;
var isArray_default = isArray2;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray_default(value2)) {
    return arrayMap_default(value2, baseToString) + "";
  }
  if (isSymbol_default(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value2, other2) {
    var result2;
    if (value2 === void 0 && other2 === void 0) {
      return defaultValue;
    }
    if (value2 !== void 0) {
      result2 = value2;
    }
    if (other2 !== void 0) {
      if (result2 === void 0) {
        return other2;
      }
      if (typeof value2 == "string" || typeof other2 == "string") {
        value2 = baseToString_default(value2);
        other2 = baseToString_default(other2);
      } else {
        value2 = baseToNumber_default(value2);
        other2 = baseToNumber_default(other2);
      }
      result2 = operator(value2, other2);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add5 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add5;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_default(value2)) {
    return NAN2;
  }
  if (isObject_default(value2)) {
    var other2 = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject_default(other2) ? other2 + "" : other2;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim_default(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN2 : +value2;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber_default(value2);
  if (value2 === INFINITY2 || value2 === -INFINITY2) {
    var sign = value2 < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value2) {
  var result2 = toFinite_default(value2), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity4(value2) {
  return value2;
}
var identity_default3 = identity4;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject_default(value2)) {
    return false;
  }
  var tag = baseGetTag_default(value2);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto4 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty5 = objectProto4.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty5).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject_default(value2) || isMasked_default(value2)) {
    return false;
  }
  var pattern2 = isFunction_default(value2) ? reIsNative : reIsHostCtor;
  return pattern2.test(toSource_default(value2));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue2;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value2 = getValue_default(object, key);
  return baseIsNative_default(value2) ? value2 : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default3 : function(func, data3) {
  metaMap_default.set(func, data3);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array, placeholder) {
  var length5 = array.length, result2 = 0;
  while (length5--) {
    if (array[length5] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value2) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default2 = noop;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default2 : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto5 = Object.prototype;
var hasOwnProperty6 = objectProto5.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array = realNames_default[result2], length5 = hasOwnProperty6.call(realNames_default, result2) ? array.length : 0;
  while (length5--) {
    var data3 = array[length5], otherFunc = data3.func;
    if (otherFunc == null || otherFunc == func) {
      return data3.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value2, chainAll) {
  this.__wrapped__ = value2;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length5 = source.length;
  array || (array = Array(length5));
  while (++index < length5) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto6 = Object.prototype;
var hasOwnProperty7 = objectProto6.hasOwnProperty;
function lodash(value2) {
  if (isObjectLike_default(value2) && !isArray_default(value2) && !(value2 instanceof LazyWrapper_default)) {
    if (value2 instanceof LodashWrapper_default) {
      return value2;
    }
    if (hasOwnProperty7.call(value2, "__wrapped__")) {
      return wrapperClone_default(value2);
    }
  }
  return new LodashWrapper_default(value2);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other2 = wrapperLodash_default[funcName];
  if (typeof other2 != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other2) {
    return true;
  }
  var data3 = getData_default(other2);
  return !!data3 && func === data3[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length5 = details.length;
  if (!length5) {
    return source;
  }
  var lastIndex = length5 - 1;
  details[lastIndex] = (length5 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length5 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant2(value2) {
  return function() {
    return value2;
  };
}
var constant_default3 = constant2;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default3 : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default3(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee2) {
  var index = -1, length5 = array == null ? 0 : array.length;
  while (++index < length5) {
    if (iteratee2(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length5 = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length5) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value2) {
  return value2 !== value2;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value2, fromIndex) {
  var index = fromIndex - 1, length5 = array.length;
  while (++index < length5) {
    if (array[index] === value2) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf_default(array, value2, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value2) {
  var length5 = array == null ? 0 : array.length;
  return !!length5 && baseIndexOf_default(array, value2, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value2 = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value2)) {
      details.push(value2);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length5) {
  var type = typeof value2;
  length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
  return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length5);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array, indexes) {
  var arrLength = array.length, length5 = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
  while (length5--) {
    var index = indexes[length5];
    array[length5] = isIndex_default(index, arrLength) ? oldArray[index] : void 0;
  }
  return array;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array, placeholder) {
  var index = -1, length5 = array.length, resIndex = 0, result2 = [];
  while (++index < length5) {
    var value2 = array[index];
    if (value2 === placeholder || value2 === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result2[resIndex++] = index;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length5 = arguments.length, args = Array(length5), index = length5;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length5 -= holdersCount;
    if (isCurried && length5 < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length5
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length5 = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length5 > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length5) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length5 = arguments.length, args = Array(length5), index = length5, placeholder = getHolder_default(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length5 < 3 && args[0] !== placeholder && args[length5 - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length5 -= holders.length;
    if (length5 < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length5
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data3, source) {
  var bitmask = data3[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data3[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data3;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data3[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value2 = source[3];
  if (value2) {
    var partials = data3[3];
    data3[3] = partials ? composeArgs_default(partials, value2, source[4]) : value2;
    data3[4] = partials ? replaceHolders_default(data3[3], PLACEHOLDER2) : source[4];
  }
  value2 = source[5];
  if (value2) {
    partials = data3[5];
    data3[5] = partials ? composeArgsRight_default(partials, value2, source[6]) : value2;
    data3[6] = partials ? replaceHolders_default(data3[5], PLACEHOLDER2) : source[6];
  }
  value2 = source[7];
  if (value2) {
    data3[7] = value2;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data3[8] = data3[8] == null ? source[8] : nativeMin2(data3[8], source[8]);
  }
  if (data3[9] == null) {
    data3[9] = source[9];
  }
  data3[0] = source[0];
  data3[1] = newBitmask;
  return data3;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length5 = partials ? partials.length : 0;
  if (!length5) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length5 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data3 = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data3) {
    mergeData_default(newData, data3);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length5, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data3 ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value2, other2) {
  return value2 === other2 || value2 !== value2 && other2 !== other2;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto7 = Object.prototype;
var hasOwnProperty8 = objectProto7.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty8.call(object, key) && eq_default(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value2);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length5 = props.length;
  while (++index < length5) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform9) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length5 = nativeMax4(args.length - start, 0), array = Array(length5);
    while (++index < length5) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform9(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default3), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike2(value2) {
  return value2 != null && isLength_default(value2.length) && !isFunction_default(value2);
}
var isArrayLike_default = isArrayLike2;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value2, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value2);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : void 0, guard = length5 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length5 < 3 ? void 0 : customizer;
      length5 = 1;
    }
    object = Object(object);
    while (++index < length5) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto8 = Object.prototype;
function isPrototype2(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto8;
  return value2 === proto;
}
var isPrototype_default = isPrototype2;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index = -1, result2 = Array(n);
  while (++index < n) {
    result2[index] = iteratee2(index);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto9 = Object.prototype;
var hasOwnProperty9 = objectProto9.hasOwnProperty;
var propertyIsEnumerable = objectProto9.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value2) {
  return isObjectLike_default(value2) && hasOwnProperty9.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike_default(value2) && isLength_default(value2.length) && !!typedArrayTags[baseGetTag_default(value2)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty10 = objectProto10.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray_default(value2), isArg = !isArr && isArguments_default(value2), isBuff = !isArr && !isArg && isBuffer_default(value2), isType3 = !isArr && !isArg && !isBuff && isTypedArray_default(value2), skipIndexes = isArr || isArg || isBuff || isType3, result2 = skipIndexes ? baseTimes_default(value2.length, String) : [], length5 = result2.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty10.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length5)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform9) {
  return function(arg) {
    return func(transform9(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto11 = Object.prototype;
var hasOwnProperty11 = objectProto11.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty11.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys2(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default2 = keys2;

// node_modules/lodash-es/assign.js
var objectProto12 = Object.prototype;
var hasOwnProperty12 = objectProto12.hasOwnProperty;
var assign2 = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default2(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty12.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign2;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto13 = Object.prototype;
var hasOwnProperty13 = objectProto13.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty13.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default2(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value2, object) {
  if (isArray_default(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_default(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto14 = Object.prototype;
var hasOwnProperty14 = objectProto14.hasOwnProperty;
function hashGet(key) {
  var data3 = this.__data__;
  if (nativeCreate_default) {
    var result2 = data3[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty14.call(data3, key) ? data3[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto15 = Object.prototype;
var hasOwnProperty15 = objectProto15.hasOwnProperty;
function hashHas(key) {
  var data3 = this.__data__;
  return nativeCreate_default ? data3[key] !== void 0 : hasOwnProperty15.call(data3, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data3 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data3[key] = nativeCreate_default && value2 === void 0 ? HASH_UNDEFINED2 : value2;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length5) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length5 = array.length;
  while (length5--) {
    if (eq_default(array[length5][0], key)) {
      return length5;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice3 = arrayProto.splice;
function listCacheDelete(key) {
  var data3 = this.__data__, index = assocIndexOf_default(data3, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data3.length - 1;
  if (index == lastIndex) {
    data3.pop();
  } else {
    splice3.call(data3, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data3 = this.__data__, index = assocIndexOf_default(data3, key);
  return index < 0 ? void 0 : data3[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value2) {
  var data3 = this.__data__, index = assocIndexOf_default(data3, key);
  if (index < 0) {
    ++this.size;
    data3.push([key, value2]);
  } else {
    data3[index][1] = value2;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length5) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map5, key) {
  var data3 = map5.__data__;
  return isKeyable_default(key) ? data3[typeof key == "string" ? "string" : "hash"] : data3.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value2) {
  var data3 = getMapData_default(this, key), size3 = data3.size;
  data3.set(key, value2);
  this.size += data3.size == size3 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length5 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length5) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
    if (cache3.has(key)) {
      return cache3.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache3.set(key, result2) || cache3;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default2 = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default2(func, function(key) {
    if (cache3.size === MAX_MEMOIZE_SIZE) {
      cache3.clear();
    }
    return key;
  });
  var cache3 = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString4(value2) {
  return value2 == null ? "" : baseToString_default(value2);
}
var toString_default = toString4;

// node_modules/lodash-es/_castPath.js
function castPath(value2, object) {
  if (isArray_default(value2)) {
    return value2;
  }
  return isKey_default(value2, object) ? [value2] : stringToPath_default(toString_default(value2));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol_default(value2)) {
    return value2;
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length5 = path.length;
  while (object != null && index < length5) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length5 ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default2 = get;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index = -1, length5 = paths.length, result2 = Array(length5), skip = object == null;
  while (++index < length5) {
    result2[index] = skip ? void 0 : get_default2(object, paths[index]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values3) {
  var index = -1, length5 = values3.length, offset = array.length;
  while (++index < length5) {
    array[offset + index] = values3[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray_default(value2) || isArguments_default(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result2) {
  var index = -1, length5 = array.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index < length5) {
    var value2 = array[index];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value2);
      }
    } else if (!isStrict) {
      result2[result2.length] = value2;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten2(array) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? baseFlatten_default(array, 1) : [];
}
var flatten_default2 = flatten2;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default2), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto16 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty16 = objectProto16.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject3(value2) {
  if (!isObjectLike_default(value2) || baseGetTag_default(value2) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty16.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject3;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value2) {
  if (!isObjectLike_default(value2)) {
    return false;
  }
  var tag = baseGetTag_default(value2);
  return tag == errorTag2 || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject_default(value2);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind2 = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind2));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind2.placeholder = {};
var bind_default = bind2;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length5 = array.length;
  if (start < 0) {
    start = -start > length5 ? 0 : length5 + start;
  }
  end = end > length5 ? length5 : end;
  if (end < 0) {
    end += length5;
  }
  length5 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length5);
  while (++index < length5) {
    result2[index] = array[index + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length5 = array.length;
  end = end === void 0 ? length5 : end;
  return !start && end >= length5 ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst2 = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst2;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index = -1, length5 = array == null ? 0 : array.length;
  if (initAccum && length5) {
    accumulator = array[++index];
  }
  while (++index < length5) {
    accumulator = iteratee2(accumulator, array[index], index, array);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern2, guard) {
  string = toString_default(string);
  pattern2 = guard ? void 0 : pattern2;
  if (pattern2 === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern2) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "[']";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word2, index) {
  word2 = word2.toLowerCase();
  return result2 + (index ? capitalize_default(word2) : word2);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value2 = arguments[0];
  return isArray_default(value2) ? value2 : [value2];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber_default(number);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString_default(number) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value2) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil3 = createRound_default("ceil");
var ceil_default = ceil3;

// node_modules/lodash-es/chain.js
function chain(value2) {
  var result2 = wrapperLodash_default(value2);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array, size3, guard) {
  if (guard ? isIterateeCall_default(array, size3, guard) : size3 === void 0) {
    size3 = 1;
  } else {
    size3 = nativeMax5(toInteger_default(size3), 0);
  }
  var length5 = array == null ? 0 : array.length;
  if (!length5 || size3 < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result2 = Array(nativeCeil(length5 / size3));
  while (index < length5) {
    result2[resIndex++] = baseSlice_default(array, index, index += size3);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp2(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number), lower, upper);
}
var clamp_default2 = clamp2;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data3 = this.__data__, result2 = data3["delete"](key);
  this.size = data3.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value2) {
  var data3 = this.__data__;
  if (data3 instanceof ListCache_default) {
    var pairs = data3.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value2]);
      this.size = ++data3.size;
      return this;
    }
    data3 = this.__data__ = new MapCache_default(pairs);
  }
  data3.set(key, value2);
  this.size = data3.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack2(entries) {
  var data3 = this.__data__ = new ListCache_default(entries);
  this.size = data3.size;
}
Stack2.prototype.clear = stackClear_default;
Stack2.prototype["delete"] = stackDelete_default;
Stack2.prototype.get = stackGet_default;
Stack2.prototype.has = stackHas_default;
Stack2.prototype.set = stackSet_default;
var Stack_default = Stack2;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default2(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length5 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length5 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length5) {
    var value2 = array[index];
    if (predicate(value2, index, array)) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto17 = Object.prototype;
var propertyIsEnumerable2 = objectProto17.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default2, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value2) {
    var result2 = baseGetTag_default(value2), Ctor = result2 == objectTag3 ? value2.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto18 = Object.prototype;
var hasOwnProperty17 = objectProto18.hasOwnProperty;
function initCloneArray(array) {
  var length5 = array.length, result2 = new array.constructor(length5);
  if (length5 && typeof array[0] == "string" && hasOwnProperty17.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array = root_default.Uint8Array;
var Uint8Array_default = Uint8Array;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value2, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value2, key, object, stack) : customizer(value2);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value2)) {
    return value2;
  }
  var isArr = isArray_default(value2);
  if (isArr) {
    result2 = initCloneArray_default(value2);
    if (!isDeep) {
      return copyArray_default(value2, result2);
    }
  } else {
    var tag = getTag_default(value2), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value2)) {
      return cloneBuffer_default(value2, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value2, baseAssignIn_default(result2, value2)) : copySymbols_default(value2, baseAssign_default(result2, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value2 : {};
      }
      result2 = initCloneByTag_default(value2, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result2);
  if (isSet_default(value2)) {
    value2.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap_default(value2)) {
    value2.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default2;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach_default(props || value2, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone6(value2) {
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG2);
}
var clone_default2 = clone6;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value2) {
  return baseClone_default(value2, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value2, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array) {
  var index = -1, length5 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length5) {
    var value2 = array[index];
    if (value2) {
      result2[resIndex++] = value2;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length5 = arguments.length;
  if (!length5) {
    return [];
  }
  var args = Array(length5 - 1), array = arguments[0], index = length5;
  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values3) {
  var index = -1, length5 = values3 == null ? 0 : values3.length;
  this.__data__ = new MapCache_default();
  while (++index < length5) {
    this.add(values3[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length5 = array == null ? 0 : array.length;
  while (++index < length5) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache3, key) {
  return cache3.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other2, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other2.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other2);
  if (arrStacked && othStacked) {
    return arrStacked == other2 && othStacked == array;
  }
  var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other2);
  stack.set(other2, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other2[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other2, array, stack) : customizer(arrValue, othValue, index, array, other2, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other2, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other2);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map5) {
  var index = -1, result2 = Array(map5.size);
  map5.forEach(function(value2, key) {
    result2[++index] = [key, value2];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set6) {
  var index = -1, result2 = Array(set6.size);
  set6.forEach(function(value2) {
    result2[++index] = value2;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other2, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other2.byteLength || object.byteOffset != other2.byteOffset) {
        return false;
      }
      object = object.buffer;
      other2 = other2.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other2.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other2))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other2);
    case errorTag4:
      return object.name == other2.name && object.message == other2.message;
    case regexpTag4:
    case stringTag4:
      return object == other2 + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other2.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other2;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other2);
      var result2 = equalArrays_default(convert(object), convert(other2), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other2);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto19 = Object.prototype;
var hasOwnProperty18 = objectProto19.hasOwnProperty;
function equalObjects(object, other2, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other2), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other2 : hasOwnProperty18.call(other2, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other2);
  if (objStacked && othStacked) {
    return objStacked == other2 && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other2);
  stack.set(other2, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other2[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other2, object, stack) : customizer(objValue, othValue, key, object, other2, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other2.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other2);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto20 = Object.prototype;
var hasOwnProperty19 = objectProto20.hasOwnProperty;
function baseIsEqualDeep(object, other2, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other2), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other2);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other2)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other2, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other2, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty19.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty19.call(other2, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other2.value() : other2;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other2, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value2, other2, bitmask, customizer, stack) {
  if (value2 === other2) {
    return true;
  }
  if (value2 == null || other2 == null || !isObjectLike_default(value2) && !isObjectLike_default(other2)) {
    return value2 !== value2 && other2 !== other2;
  }
  return baseIsEqualDeep_default(value2, other2, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length5 = index, noCustomizer = !customizer;
  if (object == null) {
    return !length5;
  }
  object = Object(object);
  while (index--) {
    var data3 = matchData[index];
    if (noCustomizer && data3[2] ? data3[1] !== object[data3[0]] : !(data3[0] in object)) {
      return false;
    }
  }
  while (++index < length5) {
    data3 = matchData[index];
    var key = data3[0], objValue = object[key], srcValue = data3[1];
    if (noCustomizer && data3[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value2) {
  return value2 === value2 && !isObject_default(value2);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default2(object), length5 = result2.length;
  while (length5--) {
    var key = result2[length5], value2 = object[key];
    result2[length5] = [key, value2, isStrictComparable_default(value2)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length5 = path.length, result2 = false;
  while (++index < length5) {
    var key = toKey_default(path[index]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index != length5) {
    return result2;
  }
  length5 = object == null ? 0 : object.length;
  return !!length5 && isLength_default(length5) && isIndex_default(key, length5) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity_default3;
  }
  if (typeof value2 == "object") {
    return isArray_default(value2) ? baseMatchesProperty_default(value2[0], value2[1]) : baseMatches_default(value2);
  }
  return property_default(value2);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs) {
  var length5 = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length5 ? [] : arrayMap_default(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index = -1;
    while (++index < length5) {
      var pair = pairs[index];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length5 = props.length;
  if (object == null) {
    return !length5;
  }
  object = Object(object);
  while (length5--) {
    var key = props[length5], predicate = source[key], value2 = object[key];
    if (value2 === void 0 && !(key in object) || !predicate(value2)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default2(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default2(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee2, accumulator) {
  var index = -1, length5 = array == null ? 0 : array.length;
  while (++index < length5) {
    var value2 = array[index];
    setter(accumulator, value2, iteratee2(value2), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length5 = props.length;
    while (length5--) {
      var key = props[fromRight ? length5 : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default2);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length5 = collection.length, index = fromRight ? length5 : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length5) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value2, key, collection2) {
    setter(accumulator, value2, iteratee2(value2), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto21 = Object.prototype;
var hasOwnProperty20 = objectProto21.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value2, key) {
  if (hasOwnProperty20.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create6(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create6;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now2 = function() {
  return root_default.Date.now();
};
var now_default = now2;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default2 = debounce2;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value2, defaultValue) {
  return value2 == null || value2 !== value2 ? defaultValue : value2;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto22 = Object.prototype;
var hasOwnProperty21 = objectProto22.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index = -1;
  var length5 = sources.length;
  var guard = length5 > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length5 = 1;
  }
  while (++index < length5) {
    var source = sources[index];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value2 = object[key];
      if (value2 === void 0 || eq_default(value2, objectProto22[key]) && !hasOwnProperty21.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value2) {
  if (value2 !== void 0 && !eq_default(object[key], value2) || value2 === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value2);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value2) {
  return isObjectLike_default(value2) && isArrayLike_default(value2);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value2) {
  return copyObject_default(value2, keysIn_default(value2));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value2, comparator) {
  var index = -1, length5 = array == null ? 0 : array.length;
  while (++index < length5) {
    if (comparator(value2, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array, values3, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, isCommon = true, length5 = array.length, result2 = [], valuesLength = values3.length;
  if (!length5) {
    return result2;
  }
  if (iteratee2) {
    values3 = arrayMap_default(values3, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values3.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values3 = new SetCache_default(values3);
  }
  outer:
    while (++index < length5) {
      var value2 = array[index], computed = iteratee2 == null ? value2 : iteratee2(value2);
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values3[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value2);
      } else if (!includes2(values3, computed, comparator)) {
        result2.push(value2);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference2 = baseRest_default(function(array, values3) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values3, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default2 = difference2;

// node_modules/lodash-es/last.js
function last2(array) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? array[length5 - 1] : void 0;
}
var last_default = last2;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array, values3) {
  var iteratee2 = last_default(values3);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values3, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array, values3) {
  var comparator = last_default(values3);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values3, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide3 = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide3;

// node_modules/lodash-es/drop.js
function drop(array, n, guard) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, n < 0 ? 0 : n, length5);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array, n, guard) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length5 - n;
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array, predicate, isDrop, fromRight) {
  var length5 = array.length, index = fromRight ? length5 : -1;
  while ((fromRight ? index-- : ++index < length5) && predicate(array[index], index, array)) {
  }
  return isDrop ? baseSlice_default(array, fromRight ? 0 : index, fromRight ? index + 1 : length5) : baseSlice_default(array, fromRight ? index + 1 : 0, fromRight ? length5 : index);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value2) {
  return typeof value2 == "function" ? value2 : identity_default3;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach4(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach4;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array, iteratee2) {
  var length5 = array == null ? 0 : array.length;
  while (length5--) {
    if (iteratee2(array[length5], length5, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default2);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length5 = string.length;
  position = position === void 0 ? length5 : baseClamp_default(toInteger_default(position), 0, length5);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set6) {
  var index = -1, result2 = Array(set6.size);
  set6.forEach(function(value2) {
    result2[++index] = [value2, value2];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default2);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index = -1, length5 = array == null ? 0 : array.length;
  while (++index < length5) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value2, index, collection2) {
    result2 = !!predicate(value2, index, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every2(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default2 = every2;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array, value2, start, end) {
  var length5 = array.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length5 ? 0 : length5 + start;
  }
  end = end === void 0 || end > length5 ? length5 : toInteger_default(end);
  if (end < 0) {
    end += length5;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array[start++] = value2;
  }
  return array;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array, value2, start, end) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array, value2, start)) {
    start = 0;
    end = length5;
  }
  return baseFill_default(array, value2, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value2, index, collection2) {
    if (predicate(value2, index, collection2)) {
      result2.push(value2);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter2(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default4 = filter2;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default2(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex2(array, predicate, fromIndex) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax7(length5 + index, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
}
var findIndex_default = findIndex2;

// node_modules/lodash-es/find.js
var find3 = createFind_default(findIndex_default);
var find_default3 = find3;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value2, key, collection2) {
    if (predicate(value2, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return -1;
  }
  var index = length5 - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax8(length5 + index, 0) : nativeMin5(index, length5 - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head2(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default = head2;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2, key, collection2) {
    result2[++index] = iteratee2(value2, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map4(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default2 = map4;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default2(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default2(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default2(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? baseFlatten_default(array, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array, depth) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor3 = createRound_default("floor");
var floor_default = floor3;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length5 = funcs.length, index = length5, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length5;
    while (++index < length5) {
      func = funcs[index];
      var funcName = getFuncName_default(func), data3 = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data3 && isLaziable_default(data3[0]) && data3[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data3[4].length && data3[9] == 1) {
        wrapper = wrapper[getFuncName_default(data3[0])].apply(wrapper, data3[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value2 = args[0];
      if (wrapper && args.length == 1 && isArray_default(value2)) {
        return wrapper.plant(value2).value();
      }
      var index2 = 0, result2 = length5 ? funcs[index2].apply(this, args) : value2;
      while (++index2 < length5) {
        result2 = funcs[index2].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow2 = createFlow_default();
var flow_default = flow2;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index = -1, length5 = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index < length5) {
    var pair = pairs[index];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default2(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto23 = Object.prototype;
var hasOwnProperty22 = objectProto23.hasOwnProperty;
var groupBy2 = createAggregator_default(function(result2, value2, key) {
  if (hasOwnProperty22.call(result2, key)) {
    result2[key].push(value2);
  } else {
    baseAssignValue_default(result2, key, [value2]);
  }
});
var groupBy_default = groupBy2;

// node_modules/lodash-es/_baseGt.js
function baseGt(value2, other2) {
  return value2 > other2;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value2, other2) {
    if (!(typeof value2 == "string" && typeof other2 == "string")) {
      value2 = toNumber_default(value2);
      other2 = toNumber_default(other2);
    }
    return operator(value2, other2);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value2, other2) {
  return value2 >= other2;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto24 = Object.prototype;
var hasOwnProperty23 = objectProto24.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty23.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path) {
  return object != null && hasPath_default(object, path, baseHas_default);
}
var has_default2 = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number, start, end) {
  return number >= nativeMin6(start, end) && number < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number = toNumber_default(number);
  return baseInRange_default(number, start, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value2) {
  return typeof value2 == "string" || !isArray_default(value2) && isObjectLike_default(value2) && baseGetTag_default(value2) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values2(object) {
  return object == null ? [] : baseValues_default(object, keys_default2(object));
}
var values_default2 = values2;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value2, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default2(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length5 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length5 + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length5 && collection.indexOf(value2, fromIndex) > -1 : !!length5 && baseIndexOf_default(collection, value2, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf3(array, value2, fromIndex) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax11(length5 + index, 0);
  }
  return baseIndexOf_default(array, value2, index);
}
var indexOf_default = indexOf3;

// node_modules/lodash-es/initial.js
function initial(array) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? baseSlice_default(array, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length5 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee2) {
      array = arrayMap_default(array, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length5 >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length5 && result2.length < maxLength) {
      var value2 = array[index], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache3 = caches[othIndex];
          if (!(cache3 ? cacheHas_default(cache3, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value2) {
  return isArrayLikeObject_default(value2) ? value2 : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection2 = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection2;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value2, key, object2) {
    setter(accumulator, iteratee2(value2), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto25 = Object.prototype;
var nativeObjectToString3 = objectProto25.toString;
var invert3 = createInverter_default(function(result2, value2, key) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString3.call(value2);
  }
  result2[value2] = key;
}, constant_default3(identity_default3));
var invert_default = invert3;

// node_modules/lodash-es/invertBy.js
var objectProto26 = Object.prototype;
var hasOwnProperty24 = objectProto26.hasOwnProperty;
var nativeObjectToString4 = objectProto26.toString;
var invertBy = createInverter_default(function(result2, value2, key) {
  if (value2 != null && typeof value2.toString != "function") {
    value2 = nativeObjectToString4.call(value2);
  }
  if (hasOwnProperty24.call(result2, value2)) {
    result2[value2].push(key);
  } else {
    result2[value2] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value2) {
    result2[++index] = isFunc ? apply_default(path, value2, args) : baseInvoke_default(value2, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean2(value2) {
  return value2 === true || value2 === false || isObjectLike_default(value2) && baseGetTag_default(value2) == boolTag5;
}
var isBoolean_default = isBoolean2;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate2 = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate2;

// node_modules/lodash-es/isElement.js
function isElement2(value2) {
  return isObjectLike_default(value2) && value2.nodeType === 1 && !isPlainObject_default(value2);
}
var isElement_default = isElement2;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto27 = Object.prototype;
var hasOwnProperty25 = objectProto27.hasOwnProperty;
function isEmpty2(value2) {
  if (value2 == null) {
    return true;
  }
  if (isArrayLike_default(value2) && (isArray_default(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer_default(value2) || isTypedArray_default(value2) || isArguments_default(value2))) {
    return !value2.length;
  }
  var tag = getTag_default(value2);
  if (tag == mapTag8 || tag == setTag8) {
    return !value2.size;
  }
  if (isPrototype_default(value2)) {
    return !baseKeys_default(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty25.call(value2, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty2;

// node_modules/lodash-es/isEqual.js
function isEqual3(value2, other2) {
  return baseIsEqual_default(value2, other2);
}
var isEqual_default = isEqual3;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value2, other2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value2, other2) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value2, other2, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite2(value2) {
  return typeof value2 == "number" && nativeIsFinite2(value2);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger2(value2) {
  return typeof value2 == "number" && value2 == toInteger_default(value2);
}
var isInteger_default = isInteger2;

// node_modules/lodash-es/isMatch.js
function isMatch2(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch2;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber3(value2) {
  return typeof value2 == "number" || isObjectLike_default(value2) && baseGetTag_default(value2) == numberTag5;
}
var isNumber_default = isNumber3;

// node_modules/lodash-es/isNaN.js
function isNaN2(value2) {
  return isNumber_default(value2) && value2 != +value2;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value2) {
  if (isMaskable_default(value2)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value2);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil2(value2) {
  return value2 == null;
}
var isNil_default = isNil2;

// node_modules/lodash-es/isNull.js
function isNull2(value2) {
  return value2 === null;
}
var isNull_default = isNull2;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value2) {
  return isInteger_default(value2) && value2 >= -MAX_SAFE_INTEGER3 && value2 <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined2(value2) {
  return value2 === void 0;
}
var isUndefined_default = isUndefined2;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value2) {
  return isObjectLike_default(value2) && getTag_default(value2) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value2) {
  return isObjectLike_default(value2) && baseGetTag_default(value2) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array, separator) {
  return array == null ? "" : nativeJoin.call(array, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase2 = createCompounder_default(function(result2, word2, index) {
  return result2 + (index ? "-" : "") + word2.toLowerCase();
});
var kebabCase_default = kebabCase2;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value2, key) {
  baseAssignValue_default(result2, key, value2);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array, value2, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array[index] === value2) {
      return index;
    }
  }
  return index;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array, value2, fromIndex) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return -1;
  }
  var index = length5;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = index < 0 ? nativeMax12(length5 + index, 0) : nativeMin8(index, length5 - 1);
  }
  return value2 === value2 ? strictLastIndexOf_default(array, value2, index) : baseFindIndex_default(array, baseIsNaN_default, index, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase2 = createCompounder_default(function(result2, word2, index) {
  return result2 + (index ? " " : "") + word2.toLowerCase();
});
var lowerCase_default = lowerCase2;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value2, other2) {
  return value2 < other2;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value2, other2) {
  return value2 <= other2;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value2, key, object2) {
    baseAssignValue_default(result2, iteratee2(value2, key, object2), value2);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value2, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value2, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee2, comparator) {
  var index = -1, length5 = array.length;
  while (++index < length5) {
    var value2 = array[index], current = iteratee2(value2);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value2;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max3(array) {
  return array && array.length ? baseExtremum_default(array, identity_default3, baseGt_default) : void 0;
}
var max_default2 = max3;

// node_modules/lodash-es/maxBy.js
function maxBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee2) {
  var result2, index = -1, length5 = array.length;
  while (++index < length5) {
    var current = iteratee2(array[index]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array, iteratee2) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? baseSum_default(array, iteratee2) / length5 : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean(array) {
  return baseMean_default(array, identity_default3);
}
var mean_default = mean;

// node_modules/lodash-es/meanBy.js
function meanBy(array, iteratee2) {
  return baseMean_default(array, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min3(array) {
  return array && array.length ? baseExtremum_default(array, identity_default3, baseLt_default) : void 0;
}
var min_default2 = min3;

// node_modules/lodash-es/minBy.js
function minBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default2(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply4 = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply4;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate3(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate3;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data3, result2 = [];
  while (!(data3 = iterator.next()).done) {
    result2.push(data3.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value2) {
  if (!value2) {
    return [];
  }
  if (isArrayLike_default(value2)) {
    return isString_default(value2) ? stringToArray_default(value2) : copyArray_default(value2);
  }
  if (symIterator && value2[symIterator]) {
    return iteratorToArray_default(value2[symIterator]());
  }
  var tag = getTag_default(value2), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default2;
  return func(value2);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value2 = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value2 };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array, n) {
  var length5 = array.length;
  if (!length5) {
    return;
  }
  n += n < 0 ? length5 : 0;
  return isIndex_default(n, length5) ? array[n] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array, n) {
  return array && array.length ? baseNth_default(array, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value2) {
  return isPlainObject_default(value2) ? void 0 : value2;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit2 = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length5 = paths.length;
  while (length5--) {
    baseUnset_default(result2, paths[length5]);
  }
  return result2;
});
var omit_default2 = omit2;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value2, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length5 = path.length, lastIndex = length5 - 1, nested = object;
  while (nested != null && ++index < length5) {
    var key = toKey_default(path[index]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length5 = paths.length, result2 = {};
  while (++index < length5) {
    var path = paths[index], value2 = baseGet_default(object, path);
    if (predicate(value2, path)) {
      baseSet_default(result2, castPath_default(path, object), value2);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value2, path) {
    return predicate(value2, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length5 = array.length;
  array.sort(comparer);
  while (length5--) {
    array[length5] = array[length5].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value2, other2) {
  if (value2 !== other2) {
    var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol_default(value2);
    var othIsDefined = other2 !== void 0, othIsNull = other2 === null, othIsReflexive = other2 === other2, othIsSymbol = isSymbol_default(other2);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other2 || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other2 || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other2, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other2.criteria, length5 = objCriteria.length, ordersLength = orders.length;
  while (++index < length5) {
    var result2 = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result2) {
      if (index >= ordersLength) {
        return result2;
      }
      var order = orders[index];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other2.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value2) {
          return baseGet_default(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default3];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value2, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value2);
    });
    return { "criteria": criteria, "index": ++index, "value": value2 };
  });
  return baseSortBy_default(result2, function(object, other2) {
    return compareMultiple_default(object, other2, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index = -1, length5 = nativeMin9(args.length, funcsLength);
    while (++index < length5) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length5, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length5) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length5 / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length5).join("") : result2.slice(0, length5);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad2(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  if (!length5 || strLength >= length5) {
    return string;
  }
  var mid2 = (length5 - strLength) / 2;
  return createPadding_default(nativeFloor2(mid2), chars) + string + createPadding_default(nativeCeil3(mid2), chars);
}
var pad_default = pad2;

// node_modules/lodash-es/padEnd.js
function padEnd2(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  return length5 && strLength < length5 ? string + createPadding_default(length5 - strLength, chars) : string;
}
var padEnd_default = padEnd2;

// node_modules/lodash-es/padStart.js
function padStart(string, length5, chars) {
  string = toString_default(string);
  length5 = toInteger_default(length5);
  var strLength = length5 ? stringSize_default(string) : 0;
  return length5 && strLength < length5 ? createPadding_default(length5 - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition2 = createAggregator_default(function(result2, value2, key) {
  result2[key ? 0 : 1].push(value2);
}, function() {
  return [[], []];
});
var partition_default2 = partition2;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value2, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick2 = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default2 = pick2;

// node_modules/lodash-es/plant.js
function wrapperPlant(value2) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone7 = wrapperClone_default(parent2);
    clone7.__index__ = 0;
    clone7.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone7;
    } else {
      result2 = clone7;
    }
    var previous = clone7;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value2;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value2, fromIndex, comparator) {
  var index = fromIndex - 1, length5 = array.length;
  while (++index < length5) {
    if (comparator(array[index], value2)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice4 = arrayProto3.splice;
function basePullAll(array, values3, iteratee2, comparator) {
  var indexOf4 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length5 = values3.length, seen = array;
  if (array === values3) {
    values3 = copyArray_default(values3);
  }
  if (iteratee2) {
    seen = arrayMap_default(array, baseUnary_default(iteratee2));
  }
  while (++index < length5) {
    var fromIndex = 0, value2 = values3[index], computed = iteratee2 ? iteratee2(value2) : value2;
    while ((fromIndex = indexOf4(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice4.call(seen, fromIndex, 1);
      }
      splice4.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array, values3) {
  return array && array.length && values3 && values3.length ? basePullAll_default(array, values3) : array;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default2 = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array, values3, iteratee2) {
  return array && array.length && values3 && values3.length ? basePullAll_default(array, values3, baseIteratee_default(iteratee2, 2)) : array;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array, values3, comparator) {
  return array && array.length && values3 && values3.length ? basePullAll_default(array, values3, void 0, comparator) : array;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice5 = arrayProto4.splice;
function basePullAt(array, indexes) {
  var length5 = array ? indexes.length : 0, lastIndex = length5 - 1;
  while (length5--) {
    var index = indexes[length5];
    if (length5 == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex_default(index)) {
        splice5.call(array, index, 1);
      } else {
        baseUnset_default(array, index);
      }
    }
  }
  return array;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt3 = flatRest_default(function(array, indexes) {
  var length5 = array == null ? 0 : array.length, result2 = baseAt_default(array, indexes);
  basePullAt_default(array, arrayMap_default(indexes, function(index) {
    return isIndex_default(index, length5) ? +index : index;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt3;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random3(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random3;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index = -1, length5 = nativeMax13(nativeCeil4((end - start) / (step || 1)), 0), result2 = Array(length5);
  while (length5--) {
    result2[fromRight ? length5 : ++index] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value2, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value2) : iteratee2(accumulator, value2, index, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce2(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default2 = reduce2;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
  var length5 = array == null ? 0 : array.length;
  if (initAccum && length5) {
    accumulator = array[--length5];
  }
  while (length5--) {
    accumulator = iteratee2(accumulator, array[length5], length5, array);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove2(array, predicate) {
  var result2 = [];
  if (!(array && array.length)) {
    return result2;
  }
  var index = -1, indexes = [], length5 = array.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index < length5) {
    var value2 = array[index];
    if (predicate(value2, index, array)) {
      result2.push(value2);
      indexes.push(index);
    }
  }
  basePullAt_default(array, indexes);
  return result2;
}
var remove_default2 = remove2;

// node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index = -1, length5 = path.length;
  if (!length5) {
    length5 = 1;
    object = void 0;
  }
  while (++index < length5) {
    var value2 = object == null ? void 0 : object[toKey_default(path[index])];
    if (value2 === void 0) {
      index = length5;
      value2 = defaultValue;
    }
    object = isFunction_default(value2) ? value2.call(object) : value2;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}
var reverse_default = reverse;

// node_modules/lodash-es/round.js
var round4 = createRound_default("round");
var round_default3 = round4;

// node_modules/lodash-es/_arraySample.js
function arraySample(array) {
  var length5 = array.length;
  return length5 ? array[baseRandom_default(0, length5 - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default2(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size3) {
  var index = -1, length5 = array.length, lastIndex = length5 - 1;
  size3 = size3 === void 0 ? length5 : size3;
  while (++index < size3) {
    var rand = baseRandom_default(index, lastIndex), value2 = array[rand];
    array[rand] = array[index];
    array[index] = value2;
  }
  array.length = size3;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array, n) {
  return shuffleSelf_default(copyArray_default(array), baseClamp_default(n, 0, array.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array = values_default2(collection);
  return shuffleSelf_default(array, baseClamp_default(n, 0, array.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set5(object, path, value2) {
  return object == null ? object : baseSet_default(object, path, value2);
}
var set_default2 = set5;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value2, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value2, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default2(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle2(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle2;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size2(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default2 = size2;

// node_modules/lodash-es/slice.js
function slice(array, start, end) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array, start, end)) {
    start = 0;
    end = length5;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length5 : toInteger_default(end);
  }
  return baseSlice_default(array, start, end);
}
var slice_default2 = slice;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word2, index) {
  return result2 + (index ? "_" : "") + word2.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value2, index, collection2) {
    result2 = predicate(value2, index, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some2(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default2 = some2;

// node_modules/lodash-es/sortBy.js
var sortBy2 = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length5 = iteratees.length;
  if (length5 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length5 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy2;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array, value2, iteratee2, retHighest) {
  var low = 0, high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }
  value2 = iteratee2(value2);
  var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol_default(value2), valIsUndefined = value2 === void 0;
  while (low < high) {
    var mid2 = nativeFloor4((low + high) / 2), computed = iteratee2(array[mid2]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value2 : computed < value2;
    }
    if (setLow) {
      low = mid2 + 1;
    } else {
      high = mid2;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array, value2, retHighest) {
  var low = 0, high = array == null ? low : array.length;
  if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid2 = low + high >>> 1, computed = array[mid2];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value2 : computed < value2)) {
        low = mid2 + 1;
      } else {
        high = mid2;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array, value2, identity_default3, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array, value2) {
  return baseSortedIndex_default(array, value2);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array, value2, iteratee2) {
  return baseSortedIndexBy_default(array, value2, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array, value2) {
  var length5 = array == null ? 0 : array.length;
  if (length5) {
    var index = baseSortedIndex_default(array, value2);
    if (index < length5 && eq_default(array[index], value2)) {
      return index;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array, value2) {
  return baseSortedIndex_default(array, value2, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array, value2, iteratee2) {
  return baseSortedIndexBy_default(array, value2, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array, value2) {
  var length5 = array == null ? 0 : array.length;
  if (length5) {
    var index = baseSortedIndex_default(array, value2, true) - 1;
    if (eq_default(array[index], value2)) {
      return index;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array, iteratee2) {
  var index = -1, length5 = array.length, resIndex = 0, result2 = [];
  while (++index < length5) {
    var value2 = array[index], computed = iteratee2 ? iteratee2(value2) : value2;
    if (!index || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value2 === 0 ? 0 : value2;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq_default(array) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array, iteratee2) {
  return array && array.length ? baseSortedUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array) {
      arrayPush_default(otherArgs, array);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word2, index) {
  return result2 + (index ? " " : "") + upperFirst_default(word2);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract4 = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract4;

// node_modules/lodash-es/sum.js
function sum(array) {
  return array && array.length ? baseSum_default(array, identity_default3) : 0;
}
var sum_default2 = sum;

// node_modules/lodash-es/sumBy.js
function sumBy2(array, iteratee2) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy2;

// node_modules/lodash-es/tail.js
function tail(array) {
  var length5 = array == null ? 0 : array.length;
  return length5 ? baseSlice_default(array, 1, length5) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array, n, guard) {
  var length5 = array == null ? 0 : array.length;
  if (!length5) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length5 - n;
  return baseSlice_default(array, n < 0 ? 0 : n, length5);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value2, interceptor) {
  interceptor(value2);
  return value2;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto28 = Object.prototype;
var hasOwnProperty26 = objectProto28.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto28[key]) && !hasOwnProperty26.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto29 = Object.prototype;
var hasOwnProperty27 = objectProto29.hasOwnProperty;
function template2(string, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options, guard)) {
    options = void 0;
  }
  string = toString_default(string);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default2(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty27.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty27.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template2;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default2(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default2 = throttle;

// node_modules/lodash-es/thru.js
function thru(value2, interceptor) {
  return interceptor(value2);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH6, length5 = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length5, iteratee2);
  while (++index < n) {
    iteratee2(index);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value2, actions) {
  var result2 = value2;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value2) {
  return toString_default(value2).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value2) {
  if (isArray_default(value2)) {
    return arrayMap_default(value2, toKey_default);
  }
  return isSymbol_default(value2) ? [value2] : copyArray_default(stringToPath_default(toString_default(value2)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value2) {
  return value2 ? baseClamp_default(toInteger_default(value2), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value2 === 0 ? value2 : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value2) {
  return toString_default(value2).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform6(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value2, index, object2) {
    return iteratee2(accumulator, value2, index, object2);
  });
  return accumulator;
}
var transform_default = transform6;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1, length5 = strSymbols.length;
  while (++index < length5 && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options) {
  var length5 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length5 = "length" in options ? toInteger_default(options.length) : length5;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length5 >= strLength) {
    return string;
  }
  var end = length5 - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index = result2.lastIndexOf(separator);
    if (index > -1) {
      result2 = result2.slice(0, index);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default2 : function(values3) {
  return new Set_default(values3);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, length5 = array.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length5 >= LARGE_ARRAY_SIZE3) {
    var set6 = iteratee2 ? null : createSet_default(array);
    if (set6) {
      return setToArray_default(set6);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index < length5) {
      var value2 = array[index], computed = iteratee2 ? iteratee2(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value2);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value2);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default2 = union;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq4(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq4;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee2) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length5 = 0;
  array = arrayFilter_default(array, function(group2) {
    if (isArrayLikeObject_default(group2)) {
      length5 = nativeMax15(group2.length, length5);
      return true;
    }
  });
  return baseTimes_default(length5, function(index) {
    return arrayMap_default(array, baseProperty_default(index));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array, iteratee2) {
  if (!(array && array.length)) {
    return [];
  }
  var result2 = unzip_default(array);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group2) {
    return apply_default(iteratee2, void 0, group2);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update2(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update2;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word2, index) {
  return result2 + (index ? " " : "") + word2.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array, values3) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, values3) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value2, wrapper) {
  return partial_default(castFunction_default(wrapper), value2);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length5 = paths.length, start = length5 ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length5 > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value2 = value2.slice(start, +start + (length5 ? 1 : 0));
  value2.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value2, this.__chain__).thru(function(array) {
    if (length5 && !array.length) {
      array.push(void 0);
    }
    return array;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value2 = this.__wrapped__;
  if (value2 instanceof LazyWrapper_default) {
    var wrapped = value2;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length5 = arrays.length;
  if (length5 < 2) {
    return length5 ? baseUniq_default(arrays[0]) : [];
  }
  var index = -1, result2 = Array(length5);
  while (++index < length5) {
    var array = arrays[index], othIndex = -1;
    while (++othIndex < length5) {
      if (othIndex != index) {
        result2[index] = baseDifference_default(result2[index] || array, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values3, assignFunc) {
  var index = -1, length5 = props.length, valsLength = values3.length, result2 = {};
  while (++index < length5) {
    var value2 = index < valsLength ? values3[index] : void 0;
    assignFunc(result2, props[index], value2);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values3) {
  return baseZipObject_default(props || [], values3 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values3) {
  return baseZipObject_default(props || [], values3 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length5 = arrays.length, iteratee2 = length5 > 1 ? arrays[length5 - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default2,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default2,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default2,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default2,
  reverse: reverse_default,
  slice: slice_default2,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default2,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default2,
  filter: filter_default4,
  find: find_default3,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default2,
  orderBy: orderBy_default,
  partition: partition_default2,
  reduce: reduce_default2,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default2,
  some: some_default2,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default2,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default2,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default2,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default2,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default2,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default2,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default3,
  subtract: subtract_default,
  sum: sum_default2,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default2,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default2,
  has: has_default2,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default2,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default2,
  omitBy: omitBy_default,
  pick: pick_default2,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default2,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default2,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default3,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default3,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default2,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index = -1, length5 = transforms.length;
  while (++index < length5) {
    var data3 = transforms[index], size3 = data3.size;
    switch (data3.type) {
      case "drop":
        start += size3;
        break;
      case "dropRight":
        end -= size3;
        break;
      case "take":
        end = nativeMin13(end, start + size3);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size3);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length5 = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length5, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length5 && takeCount == length5) {
    return baseWrapperValue_default(array, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length5-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1, value2 = array[index];
      while (++iterIndex < iterLength) {
        var data3 = iteratees[iterIndex], iteratee2 = data3.iteratee, type = data3.type, computed = iteratee2(value2);
        if (type == LAZY_MAP_FLAG) {
          value2 = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value2;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION2 = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto30 = Object.prototype;
var hasOwnProperty28 = objectProto30.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default2(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default2;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default3;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty28.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION2;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index) {
  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index) {
  var takeName = "take" + (index ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index) {
  var dropName = "drop" + (index ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default3);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value2) {
    return baseInvoke_default(value2, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value2);
    var interceptor = function(value3) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value3], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value2 = onlyLazy ? value2 : new LazyWrapper_default(this);
      var result2 = func.apply(value2, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value2 = this.value();
      return func.apply(isArray_default(value2) ? value2 : [], args);
    }
    return this[chainName](function(value3) {
      return func.apply(isArray_default(value3) ? value3 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty28.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES3 = "	\n\v\f\r \u2028\u2029";
var PATH_COMMAND3 = new RegExp("([a-z])[" + SPACES3 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES3 + "]*,?[" + SPACES3 + "]*)+)", "ig");
var PATH_VALUES3 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES3 + "]*,?[" + SPACES3 + "]*", "ig");
function parsePathString3(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data3 = [];
  String(pathString).replace(PATH_COMMAND3, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES3, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data3.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data3.push([b, params[0]]);
    }
    if (name === "r") {
      data3.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data3.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data3;
}

// node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU2 = Math.PI * 2;

// node_modules/@antv/g2plot/esm/plots/venn/shape.js
function getFillAttrs2(cfg) {
  return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape("schema", "venn", {
  draw: function(cfg, container) {
    var data3 = cfg.data;
    var segments = parsePathString3(data3[PATH_FIELD]);
    var fillAttrs = getFillAttrs2(cfg);
    var group2 = container.addGroup({ name: "venn-shape" });
    group2.addShape("path", {
      attrs: __assign(__assign({}, fillAttrs), { path: segments }),
      name: "venn-path"
    });
    var _a6 = cfg.customInfo, offsetX = _a6.offsetX, offsetY = _a6.offsetY;
    var matrix = Util.transform(null, [["t", offsetX, offsetY]]);
    group2.setMatrix(matrix);
    return group2;
  },
  getMarker: function(markerCfg) {
    var color3 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        lineWidth: 0,
        stroke: color3,
        fill: color3,
        r: 4
      }
    };
  }
});

// node_modules/@antv/g2plot/esm/utils/color/blend.js
var each2 = function(f) {
  return function(c0, c1) {
    var out = [];
    out[0] = f(c0[0], c1[0]);
    out[1] = f(c0[1], c1[1]);
    out[2] = f(c0[2], c1[2]);
    return out;
  };
};
var blendObject = {
  normal: function(a) {
    return a;
  },
  multiply: function(a, b) {
    return a * b / 255;
  },
  screen: function(a, b) {
    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
  },
  overlay: function(a, b) {
    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
  },
  darken: function(a, b) {
    return a > b ? b : a;
  },
  lighten: function(a, b) {
    return a > b ? a : b;
  },
  dodge: function(a, b) {
    if (a === 255)
      return 255;
    a = 255 * (b / 255) / (1 - a / 255);
    return a > 255 ? 255 : a;
  },
  burn: function(a, b) {
    if (b === 255)
      return 255;
    else if (a === 0)
      return 0;
    else
      return 255 * (1 - Math.min(1, (1 - b / 255) / (a / 255)));
  }
};
var innerBlend = function(mode) {
  if (!blendObject[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blendObject[mode];
};
function blend(c0, c1, mode) {
  if (mode === void 0) {
    mode = "normal";
  }
  var blendRgbArr = each2(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
  var _a6 = colorToArr(c0), r0 = _a6[0], g0 = _a6[1], b02 = _a6[2], a0 = _a6[3];
  var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b12 = _b[2], a1 = _b[3];
  var a = Number((a0 + a1 * (1 - a0)).toFixed(2));
  var r = Math.round((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a * 255);
  var g = Math.round((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a * 255);
  var b = Math.round((a0 * (1 - a1) * (b02 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b12 / 255)) / a * 255);
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
function colorToArr(c) {
  var color3 = c.replace("/s+/g", "");
  var rgbaArr;
  if (typeof color3 === "string" && !color3.startsWith("rgba") && !color3.startsWith("#")) {
    return rgbaArr = esm_default2.rgb2arr(esm_default2.toRGB(color3)).concat([1]);
  }
  if (color3.startsWith("rgba"))
    rgbaArr = color3.replace("rgba(", "").replace(")", "").split(",");
  if (color3.startsWith("#"))
    rgbaArr = esm_default2.rgb2arr(color3).concat([1]);
  return rgbaArr.map(function(item, index) {
    return index === 3 ? Number(item) : item | 0;
  });
}

// node_modules/fmin/src/bisect.js
function bisect(f, a, b, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance3 = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a;
  if (fB === 0)
    return b;
  for (var i = 0; i < maxIterations; ++i) {
    delta /= 2;
    var mid2 = a + delta, fMid = f(mid2);
    if (fMid * fA >= 0) {
      a = mid2;
    }
    if (Math.abs(delta) < tolerance3 || fMid === 0) {
      return mid2;
    }
  }
  return a + delta;
}

// node_modules/fmin/src/blas1.js
function zeros(x) {
  var r = new Array(x);
  for (var i = 0; i < x; ++i) {
    r[i] = 0;
  }
  return r;
}
function zerosM(x, y) {
  return zeros(x).map(function() {
    return zeros(y);
  });
}
function dot6(a, b) {
  var ret = 0;
  for (var i = 0; i < a.length; ++i) {
    ret += a[i] * b[i];
  }
  return ret;
}
function norm2(a) {
  return Math.sqrt(dot6(a, a));
}
function scale7(ret, value2, c) {
  for (var i = 0; i < value2.length; ++i) {
    ret[i] = value2[i] * c;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/fmin/src/nelderMead.js
function nelderMead(f, x0, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N = x0.length, simplex = new Array(N + 1);
  simplex[0] = x0;
  simplex[0].fx = f(x0);
  simplex[0].id = 0;
  for (var i = 0; i < N; ++i) {
    var point2 = x0.slice();
    point2[i] = point2[i] ? point2[i] * nonZeroDelta : zeroDelta;
    simplex[i + 1] = point2;
    simplex[i + 1].fx = f(point2);
    simplex[i + 1].id = i + 1;
  }
  function updateSimplex(value2) {
    for (var i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  var sortOrder = function(a, b) {
    return a.fx - b.fx;
  };
  var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x) {
        var state2 = x.slice();
        state2.fx = x.fx;
        state2.id = x.id;
        return state2;
      });
      sortedSimplex.sort(function(a, b) {
        return a.id - b.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i = 0; i < N; ++i) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i = 0; i < N; ++i) {
      centroid[i] = 0;
      for (var j = 0; j < N; ++j) {
        centroid[i] += simplex[j][i];
      }
      centroid[i] /= N;
    }
    var worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (i = 1; i < simplex.length; ++i) {
          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
          simplex[i].fx = f(simplex[i]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}

// node_modules/fmin/src/linesearch.js
function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
  var phi0 = current.fx, phiPrime0 = dot6(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a = a || 1;
  c1 = c1 || 1e-6;
  c2 = c2 || 0.1;
  function zoom2(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a, pk);
      phi2 = next.fx = f(next.x, next.fxprime);
      phiPrime = dot6(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a * phiPrime0 || phi2 >= phi_lo) {
        a_high = a;
      } else {
        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
          return a;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a, pk);
    phi2 = next.fx = f(next.x, next.fxprime);
    phiPrime = dot6(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom2(a0, a, phi_old);
    }
    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
      return a;
    }
    if (phiPrime >= 0) {
      return zoom2(a, a0, phi2);
    }
    phi_old = phi2;
    a0 = a;
    a *= 2;
  }
  return a;
}

// node_modules/fmin/src/conjugateGradient.js
function conjugateGradient(f, initial2, params) {
  var current = { x: initial2.slice(), fx: 0, fxprime: initial2.slice() }, next = { x: initial2.slice(), fx: 0, fxprime: initial2.slice() }, yk = initial2.slice(), pk, temp, a = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial2.length * 20;
  current.fx = f(current.x, current.fxprime);
  pk = current.fxprime.slice();
  scale7(pk, current.fxprime, -1);
  for (var i = 0; i < maxIterations; ++i) {
    a = wolfeLineSearch(f, pk, current, next, a);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a
      });
    }
    if (!a) {
      scale7(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot6(current.fxprime, current.fxprime), beta_k = Math.max(0, dot6(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a
    });
  }
  return current;
}

// node_modules/@antv/g2plot/esm/plots/venn/layout/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  var intersectionPoints = getIntersectionPoints(circles);
  var innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  var arcArea = 0, polygonArea = 0, i;
  var arcs = [];
  if (innerPoints.length > 1) {
    var center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      var p = innerPoints[i];
      p.angle = Math.atan2(p.x - center2.x, p.y - center2.y);
    }
    innerPoints.sort(function(a3, b) {
      return b.angle - a3.angle;
    });
    var p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      var p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var arc2 = null;
      for (var j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          var circle2 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a2 = Math.atan2(p2.x - circle2.x, p2.y - circle2.y);
          var angleDiff = a2 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          var a = a2 - angleDiff / 2;
          var width = distance8(midPoint, {
            x: circle2.x + circle2.radius * Math.sin(a),
            y: circle2.y + circle2.radius * Math.cos(a)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc2 === null || arc2.width > width) {
            arc2 = { circle: circle2, width, p1, p2 };
          }
        }
      }
      if (arc2 !== null) {
        arcs.push(arc2);
        arcArea += circleArea(arc2.circle.radius, arc2.width);
        p2 = p1;
      }
    }
  } else {
    var smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    var disjoint = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance8(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = true;
        break;
      }
    }
    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point2, circles) {
  for (var i = 0; i < circles.length; ++i) {
    if (distance8(point2, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  var ret = [];
  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var intersect3 = circleCircleIntersection(circles[i], circles[j]);
      for (var k = 0; k < intersect3.length; ++k) {
        var p = intersect3[k];
        p.parentIndex = [i, j];
        ret.push(p);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance8(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d) {
  if (d >= r1 + r2) {
    return 0;
  }
  if (d <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  var d = distance8(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
    return [];
  }
  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
  return [
    { x: x0 + rx, y: y0 - ry },
    { x: x0 - rx, y: y0 + ry }
  ];
}
function getCenter(points2) {
  var center2 = { x: 0, y: 0 };
  for (var i = 0; i < points2.length; ++i) {
    center2.x += points2[i].x;
    center2.y += points2[i].y;
  }
  center2.x /= points2.length;
  center2.y /= points2.length;
  return center2;
}

// node_modules/@antv/g2plot/esm/plots/venn/layout/diagram.js
function circleMargin(current, interior, exterior) {
  var margin = interior[0].radius - distance8(interior[0], current), i, m;
  for (i = 1; i < interior.length; ++i) {
    m = interior[i].radius - distance8(interior[i], current);
    if (m <= margin) {
      margin = m;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    m = distance8(exterior[i], current) - exterior[i].radius;
    if (m <= margin) {
      margin = m;
    }
  }
  return margin;
}
function computeTextCentre(interior, exterior) {
  var points2 = [];
  var i;
  for (i = 0; i < interior.length; ++i) {
    var c = interior[i];
    points2.push({ x: c.x, y: c.y });
    points2.push({ x: c.x + c.radius / 2, y: c.y });
    points2.push({ x: c.x - c.radius / 2, y: c.y });
    points2.push({ x: c.x, y: c.y + c.radius / 2 });
    points2.push({ x: c.x, y: c.y - c.radius / 2 });
  }
  var initial2 = points2[0], margin = circleMargin(points2[0], interior, exterior);
  for (i = 1; i < points2.length; ++i) {
    var m = circleMargin(points2[i], interior, exterior);
    if (m >= margin) {
      initial2 = points2[i];
      margin = m;
    }
  }
  var solution = nelderMead(function(p) {
    return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);
  }, [initial2.x, initial2.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
  var ret = { x: solution[0], y: solution[1] };
  var valid = true;
  for (i = 0; i < interior.length; ++i) {
    if (distance8(ret, interior[i]) > interior[i].radius) {
      valid = false;
      break;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    if (distance8(ret, exterior[i]) < exterior[i].radius) {
      valid = false;
      break;
    }
  }
  if (!valid) {
    if (interior.length == 1) {
      ret = { x: interior[0].x, y: interior[0].y };
    } else {
      var areaStats = {};
      intersectionArea(interior, areaStats);
      if (areaStats.arcs.length === 0) {
        ret = { x: 0, y: -1e3, disjoint: true };
      } else if (areaStats.arcs.length == 1) {
        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
      } else if (exterior.length) {
        ret = computeTextCentre(interior, []);
      } else {
        ret = getCenter(areaStats.arcs.map(function(a) {
          return a.p1;
        }));
      }
    }
  }
  return ret;
}
function getOverlappingCircles(circles) {
  var ret = {}, circleids = [];
  for (var circleid in circles) {
    circleids.push(circleid);
    ret[circleid] = [];
  }
  for (var i = 0; i < circleids.length; i++) {
    var a = circles[circleids[i]];
    for (var j = i + 1; j < circleids.length; ++j) {
      var b = circles[circleids[j]], d = distance8(a, b);
      if (d + b.radius <= a.radius + 1e-10) {
        ret[circleids[j]].push(circleids[i]);
      } else if (d + a.radius <= b.radius + 1e-10) {
        ret[circleids[i]].push(circleids[j]);
      }
    }
  }
  return ret;
}
function computeTextCentres(circles, areas) {
  var ret = {}, overlapped = getOverlappingCircles(circles);
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i].sets, areaids = {}, exclude = {};
    for (var j = 0; j < area2.length; ++j) {
      areaids[area2[j]] = true;
      var overlaps = overlapped[area2[j]];
      for (var k = 0; k < overlaps.length; ++k) {
        exclude[overlaps[k]] = true;
      }
    }
    var interior = [], exterior = [];
    for (var setid in circles) {
      if (setid in areaids) {
        interior.push(circles[setid]);
      } else if (!(setid in exclude)) {
        exterior.push(circles[setid]);
      }
    }
    var centre = computeTextCentre(interior, exterior);
    ret[area2] = centre;
    if (centre.disjoint && areas[i].size > 0) {
      console.log("WARNING: area " + area2 + " not represented on screen");
    }
  }
  return ret;
}
function circlePath(x, y, r) {
  var ret = [];
  var x0 = x - r;
  var y0 = y;
  ret.push("M", x0, y0);
  ret.push("A", r, r, 0, 1, 0, x0 + 2 * r, y0);
  ret.push("A", r, r, 0, 1, 0, x0, y0);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  var stats = {};
  intersectionArea(circles, stats);
  var arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    var circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (var i = 0; i < arcs.length; ++i) {
      var arc2 = arcs[i], r = arc2.circle.radius, wide = arc2.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc2.p1.x, arc2.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2plot/esm/plots/venn/layout/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  var initialLayout = parameters.initialLayout || bestInitialLayout;
  var loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  var circles = initialLayout(areas, parameters);
  var initial2 = [], setids = [];
  var setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial2.push(circles[setid].x);
      initial2.push(circles[setid].y);
      setids.push(setid);
    }
  }
  var solution = nelderMead(function(values3) {
    var current = {};
    for (var i2 = 0; i2 < setids.length; ++i2) {
      var setid_1 = setids[i2];
      current[setid_1] = {
        x: values3[2 * i2],
        y: values3[2 * i2 + 1],
        radius: circles[setid_1].radius
        // size : circles[setid].size
      };
    }
    return loss(current, areas);
  }, initial2, parameters);
  var positions = solution.x;
  for (var i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap2) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap2 + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect(function(distance9) {
    return circleOverlap(r1, r2, distance9) - overlap2;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  var ids = [], pairs = {};
  var i, j, a, b;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a = area2.sets[0];
      b = area2.sets[1];
      pairs[[a, b]] = true;
      pairs[[b, a]] = true;
    }
  }
  ids.sort(function(a2, b10) {
    return a2 > b10 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a, b] in pairs)) {
        areas.push({ sets: [a, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x) {
    return x.sets.length == 2;
  }).map(function(current) {
    var left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance9 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance9;
    var c = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c = 1;
    } else if (current.size <= 1e-10) {
      c = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x, fxprime, distances, constraints) {
  var loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    var xi = x[2 * i], yi = x[2 * i + 1];
    for (var j = i + 1; j < distances.length; ++j) {
      var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      var squaredDistance3 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance_1 = Math.sqrt(squaredDistance3), delta = squaredDistance3 - dij * dij;
      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  var initial2 = greedyLayout(areas, params);
  var loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial2, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial2 = constrained;
    }
  }
  return initial2;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  var restarts = params.restarts || 10;
  var sets = [], setids = {};
  var i;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  var matrices = getDistanceMatrices(areas, sets, setids);
  var distances = matrices.distances;
  var constraints = matrices.constraints;
  var norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  var obj = function(x, fxprime) {
    return constrainedMDSGradient(x, fxprime, distances, constraints);
  };
  var best, current;
  for (i = 0; i < restarts; ++i) {
    var initial2 = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial2, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  var positions = best.x;
  var circles = {};
  for (i = 0; i < sets.length; ++i) {
    var set6 = sets[i];
    circles[set6.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set6.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale7(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  var circles = {}, setOverlaps = {};
  var set6;
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      set6 = area2.sets[0];
      circles[set6] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set6] = [];
    }
  }
  areas = areas.filter(function(a) {
    return a.sets.length == 2;
  });
  for (var i = 0; i < areas.length; ++i) {
    var current = areas[i];
    var weight = current.hasOwnProperty("weight") ? current.weight : 1;
    var left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight });
    setOverlaps[right2].push({ set: left2, size: current.size, weight });
  }
  var mostOverlapped = [];
  for (set6 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set6)) {
      var size3 = 0;
      for (var i = 0; i < setOverlaps[set6].length; ++i) {
        size3 += setOverlaps[set6][i].size * setOverlaps[set6][i].weight;
      }
      mostOverlapped.push({ set: set6, size: size3 });
    }
  }
  function sortOrder(a, b) {
    return b.size - a.size;
  }
  mostOverlapped.sort(sortOrder);
  var positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point2, index) {
    circles[index].x = point2.x;
    circles[index].y = point2.y;
    positioned[index] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (var i = 1; i < mostOverlapped.length; ++i) {
    var setIndex = mostOverlapped[i].set, overlap2 = setOverlaps[setIndex].filter(isPositioned);
    set6 = circles[setIndex];
    overlap2.sort(sortOrder);
    if (overlap2.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    var points2 = [];
    for (var j = 0; j < overlap2.length; ++j) {
      var p1 = circles[overlap2[j].set], d1 = distanceFromIntersectArea(set6.radius, p1.radius, overlap2[j].size);
      points2.push({ x: p1.x + d1, y: p1.y });
      points2.push({ x: p1.x - d1, y: p1.y });
      points2.push({ y: p1.y + d1, x: p1.x });
      points2.push({ y: p1.y - d1, x: p1.x });
      for (var k = j + 1; k < overlap2.length; ++k) {
        var p2 = circles[overlap2[k].set], d2 = distanceFromIntersectArea(set6.radius, p2.radius, overlap2[k].size);
        var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (var l = 0; l < extraPoints.length; ++l) {
          points2.push(extraPoints[l]);
        }
      }
    }
    var bestLoss = 1e50, bestPoint = points2[0];
    for (var j = 0; j < points2.length; ++j) {
      circles[setIndex].x = points2[j].x;
      circles[setIndex].y = points2[j].y;
      var localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points2[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  var output2 = 0;
  function getCircles(indices) {
    return indices.map(function(i2) {
      return sets[i2];
    });
  }
  for (var i = 0; i < overlaps.length; ++i) {
    var area2 = overlaps[i];
    var overlap2 = void 0;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      var left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap2 = circleOverlap(left2.radius, right2.radius, distance8(left2, right2));
    } else {
      overlap2 = intersectionArea(getCircles(area2.sets));
    }
    var weight = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output2 += weight * (overlap2 - area2.size) * (overlap2 - area2.size);
  }
  return output2;
}
function getBoundingBox(circles) {
  var minMax = function(d) {
    var hi = Math.max.apply(null, circles.map(function(c) {
      return c[d] + c.radius;
    })), lo = Math.min.apply(null, circles.map(function(c) {
      return c[d] - c.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding3) {
  var circles = [], setids = [];
  for (var setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding3;
  height -= 2 * padding3;
  var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  var scaled = {};
  for (var i = 0; i < circles.length; ++i) {
    var circle2 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle2.radius,
      x: padding3 + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding3 + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2plot/esm/plots/venn/utils.js
var getColorMap = memoize_default(function(colorPalette, data3, blendMode, setsField) {
  var colorMap2 = /* @__PURE__ */ new Map();
  var colorPaletteLen = colorPalette.length;
  data3.forEach(function(d, idx) {
    if (d[setsField].length === 1) {
      colorMap2.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
    } else {
      var colorArr = d[setsField].map(function(id) {
        return colorMap2.get(id);
      });
      colorMap2.set(d[ID_FIELD], colorArr.slice(1).reduce(function(a, b) {
        return blend(a, b, blendMode);
      }, colorArr[0]));
    }
  });
  return colorMap2;
}, function() {
  var params = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    params[_i] = arguments[_i];
  }
  return JSON.stringify(params);
});
function layoutVennData(options, width, height, padding3) {
  if (padding3 === void 0) {
    padding3 = 0;
  }
  var data3 = options.data, setsField = options.setsField, sizeField = options.sizeField;
  if (data3.length === 0) {
    log2(LEVEL.WARN, false, "warn: %s", "");
    return [];
  }
  var vennData = data3.map(function(d) {
    var _a6;
    return __assign(__assign({}, d), (_a6 = { sets: d[setsField] || [], size: d[sizeField] }, _a6[PATH_FIELD] = "", _a6[ID_FIELD] = "", _a6));
  });
  vennData.sort(function(a, b) {
    return a.sets.length - b.sets.length;
  });
  var solution = venn(vennData);
  var circles = scaleSolution(solution, width, height, padding3);
  var textCenters = computeTextCentres(circles, vennData);
  vennData.forEach(function(row) {
    var sets = row.sets;
    var id = sets.join(",");
    row[ID_FIELD] = id;
    var setCircles = sets.map(function(set6) {
      return circles[set6];
    });
    var path = intersectionAreaPath(setCircles);
    if (!/[zZ]$/.test(path)) {
      path += " Z";
    }
    row[PATH_FIELD] = path;
    var center2 = textCenters[id] || { x: 0, y: 0 };
    mix(row, center2);
  });
  return vennData;
}
function islegalSets(legalArr, testArr) {
  for (var i = 0; i < testArr.length; i++) {
    if (!legalArr.includes(testArr[i])) {
      return false;
    }
  }
  return true;
}

// node_modules/@antv/g2plot/esm/plots/venn/adaptor.js
var LEGEND_SPACE = 40;
function colorMap(params, data3, colorPalette) {
  var chart = params.chart, options = params.options;
  var blendMode = options.blendMode, setsField = options.setsField;
  var _a6 = chart.getTheme(), colors10 = _a6.colors10, colors20 = _a6.colors20;
  var palette = colorPalette;
  if (!is_array_default(palette)) {
    palette = data3.filter(function(d) {
      return d[setsField].length === 1;
    }).length <= 10 ? colors10 : colors20;
  }
  var map5 = getColorMap(palette, data3, blendMode, setsField);
  return function(id) {
    return map5.get(id) || palette[0];
  };
}
function transformColor(params, data3) {
  var options = params.options;
  var color3 = options.color;
  if (typeof color3 !== "function") {
    var colorPalette = typeof color3 === "string" ? [color3] : color3;
    var map_1 = colorMap(params, data3, colorPalette);
    return function(datum) {
      return map_1(datum[ID_FIELD]);
    };
  }
  return color3;
}
function padding2(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, appendPadding = options.appendPadding, padding3 = options.padding;
  var tempPadding = normalPadding(appendPadding);
  if (legend18 !== false) {
    tempPadding = getAdjustAppendPadding(appendPadding, get_default(legend18, "position"), LEGEND_SPACE);
  }
  chart.appendPadding = resolveAllPadding([tempPadding, padding3]);
  return params;
}
function data(params) {
  var options = params.options;
  var data3 = options["data"];
  if (!data3) {
    log2(LEVEL.WARN, false, "warn: %s", "");
    data3 = [];
  }
  var currSets = data3.filter(function(datum) {
    return datum.sets.length === 1;
  }).map(function(datum) {
    return datum.sets[0];
  });
  var filterSets = data3.filter(function(datum) {
    var sets = datum.sets;
    return islegalSets(currSets, sets);
  });
  if (!is_equal_default(filterSets, data3))
    log2(LEVEL.WARN, false, "warn: %s", ", ");
  return deep_mix_default({}, params, {
    options: {
      data: filterSets
    }
  });
}
function geometry32(params) {
  var chart = params.chart, options = params.options;
  var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
  var _a6 = normalPadding(chart.appendPadding), t = _a6[0], r = _a6[1], b = _a6[2], l = _a6[3];
  var customInfo = { offsetX: l, offsetY: t };
  var _b = chart.viewBBox, width = _b.width, height = _b.height;
  var vennData = layoutVennData(options, Math.max(width - (r + l), 0), Math.max(height - (t + b), 0), 0);
  chart.data(vennData);
  var ext = schema(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      sizeField,
      seriesField: ID_FIELD,
      rawFields: [setsField, sizeField],
      schema: {
        shape: "venn",
        style: pointStyle
      }
    }
  })).ext;
  var geometry35 = ext.geometry;
  geometry35.customInfo(customInfo);
  var colorOptions = transformColor(params, vennData);
  if (typeof colorOptions === "function") {
    geometry35.color(ID_FIELD, function(id) {
      var datum = vennData.find(function(d) {
        return d[ID_FIELD] === id;
      });
      var defaultColor = colorMap(params, vennData)(id);
      return colorOptions(datum, defaultColor);
    });
  }
  return params;
}
function label15(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label;
  var _a6 = normalPadding(chart.appendPadding), t = _a6[0], l = _a6[3];
  var customLabelInfo = { offsetX: l, offsetY: t };
  var geometry35 = findGeometry(chart, "schema");
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: ["id"],
      callback,
      cfg: deep_mix_default({}, transformLabel(cfg), {
        //  G2  label 
        type: "venn",
        customLabelInfo
      })
    });
  }
  return params;
}
function legend14(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, sizeField = options.sizeField;
  chart.legend(ID_FIELD, legend18);
  chart.legend(sizeField, false);
  return params;
}
function axis19(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function vennInteraction(params) {
  var options = params.options, chart = params.chart;
  var interactions = options.interactions;
  if (interactions) {
    var MAP_1 = {
      "legend-active": "venn-legend-active",
      "legend-highlight": "venn-legend-highlight"
    };
    interaction(deepAssign({}, params, {
      options: {
        interactions: interactions.map(function(i) {
          return __assign(__assign({}, i), { type: MAP_1[i.type] || i.type });
        })
      }
    }));
  }
  chart.removeInteraction("legend-active");
  chart.removeInteraction("legend-highlight");
  return params;
}
function adaptor32(params) {
  return flow(
    padding2,
    theme,
    data,
    geometry32,
    label15,
    scale5({}),
    legend14,
    axis19,
    tooltip,
    vennInteraction,
    animation
    // ...  adaptor flow
  )(params);
}

// node_modules/@antv/g2plot/esm/plots/venn/index.js
var Venn = (
  /** @class */
  function(_super) {
    __extends(Venn2, _super);
    function Venn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "venn";
      return _this;
    }
    Venn2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS32;
    };
    Venn2.prototype.getDefaultOptions = function() {
      return Venn2.getDefaultOptions();
    };
    Venn2.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    Venn2.prototype.triggerResize = function() {
      if (!this.chart.destroyed) {
        this.chart.forceFit();
        this.chart.clear();
        this.execAdaptor();
        this.chart.render(true);
      }
    };
    return Venn2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/violin/constant.js
var X_FIELD4 = "x";
var VIOLIN_Y_FIELD = "violinY";
var VIOLIN_SIZE_FIELD = "violinSize";
var MIN_MAX_FIELD = "minMax";
var QUANTILE_FIELD = "quantile";
var MEDIAN_FIELD = "median";
var VIOLIN_VIEW_ID = "violin_view";
var MIN_MAX_VIEW_ID = "min_max_view";
var QUANTILE_VIEW_ID = "quantile_view";
var MEDIAN_VIEW_ID = "median_view";
var DEFAULT_OPTIONS33 = deepAssign({}, Plot.getDefaultOptions(), {
  //  view  view padding 
  syncViewPadding: true,
  // 
  kde: {
    type: "triangular",
    sampleSize: 32,
    width: 3
  },
  // 
  violinStyle: {
    lineWidth: 1,
    fillOpacity: 0.3,
    strokeOpacity: 0.75
  },
  // 
  xAxis: {
    grid: {
      line: null
    },
    tickLine: {
      alignTick: false
    }
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineWidth: 0.5,
          lineDash: [4, 4]
        }
      }
    }
  },
  // 
  legend: {
    position: "top-left"
  },
  // Tooltip
  tooltip: {
    showMarkers: false
  }
  // 
  // interactions: [{ type: 'active-region' }],
});

// node_modules/@antv/g2plot/esm/plots/violin/utils.js
var import_pdfast = __toESM(require_src());

// node_modules/@antv/g2plot/esm/utils/transform/quantile.js
function quantileSorted2(x, p) {
  var idx = x.length * p;
  if (x.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p < 0 || p > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function swap2(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function quickselect(arr, k, left2, right2) {
  left2 = left2 || 0;
  right2 = right2 || arr.length - 1;
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      var n = right2 - left2 + 1;
      var m = k - left2 + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
      if (m - n / 2 < 0)
        sd *= -1;
      var newLeft = Math.max(left2, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right2, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight);
    }
    var t = arr[k];
    var i = left2;
    var j = right2;
    swap2(arr, left2, k);
    if (arr[right2] > t)
      swap2(arr, left2, right2);
    while (i < j) {
      swap2(arr, i, j);
      i++;
      j--;
      while (arr[i] < t)
        i++;
      while (arr[j] > t)
        j--;
    }
    if (arr[left2] === t)
      swap2(arr, left2, j);
    else {
      j++;
      swap2(arr, j, right2);
    }
    if (j <= k)
      left2 = j + 1;
    if (k <= j)
      right2 = j - 1;
  }
}
function quantile(x, p) {
  var copy6 = x.slice();
  if (Array.isArray(p)) {
    multiQuantileSelect(copy6, p);
    var results = [];
    for (var i = 0; i < p.length; i++) {
      results[i] = quantileSorted2(copy6, p[i]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy6.length, p);
    quantileSelect(copy6, idx, 0, copy6.length - 1);
    return quantileSorted2(copy6, p);
  }
}
function quantileSelect(arr, k, left2, right2) {
  if (k % 1 === 0) {
    quickselect(arr, k, left2, right2);
  } else {
    k = Math.floor(k);
    quickselect(arr, k, left2, right2);
    quickselect(arr, k + 1, k + 1, right2);
  }
}
function multiQuantileSelect(arr, p) {
  var indices = [0];
  for (var i = 0; i < p.length; i++) {
    indices.push(quantileIndex(arr.length, p[i]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack = [0, indices.length - 1];
  while (stack.length) {
    var r = Math.ceil(stack.pop());
    var l = Math.floor(stack.pop());
    if (r - l <= 1)
      continue;
    var m = Math.floor((l + r) / 2);
    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));
    stack.push(l, m, m, r);
  }
}
function compare(a, b) {
  return a - b;
}
function quantileIndex(len3, p) {
  var idx = len3 * p;
  if (p === 1) {
    return len3 - 1;
  } else if (p === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len3 % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}

// node_modules/@antv/g2plot/esm/plots/violin/utils.js
var toBoxValue = function(values3) {
  return {
    low: min_default(values3),
    high: max_default(values3),
    q1: quantile(values3, 0.25),
    q3: quantile(values3, 0.75),
    median: quantile(values3, [0.5]),
    minMax: [min_default(values3), max_default(values3)],
    quantile: [quantile(values3, 0.25), quantile(values3, 0.75)]
  };
};
var toViolinValue = function(values3, pdfOptions) {
  var pdfResults = import_pdfast.default.create(values3, pdfOptions);
  return {
    violinSize: pdfResults.map(function(result2) {
      return result2.y;
    }),
    violinY: pdfResults.map(function(result2) {
      return result2.x;
    })
  };
};
var transformViolinData = function(options) {
  var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data3 = options.data, kde = options.kde;
  var pdfOptions = {
    min: kde.min,
    max: kde.max,
    size: kde.sampleSize,
    width: kde.width
  };
  if (!seriesField) {
    var group_1 = group_by_default(data3, xField);
    return Object.keys(group_1).map(function(x) {
      var records = group_1[x];
      var values3 = records.map(function(record) {
        return record[yField];
      });
      return __assign(__assign({ x }, toViolinValue(values3, pdfOptions)), toBoxValue(values3));
    });
  }
  var resultList = [];
  var seriesGroup = group_by_default(data3, seriesField);
  Object.keys(seriesGroup).forEach(function(series) {
    var group2 = group_by_default(seriesGroup[series], xField);
    return Object.keys(group2).forEach(function(key) {
      var _a6;
      var records = group2[key];
      var values3 = records.map(function(record) {
        return record[yField];
      });
      resultList.push(__assign(__assign((_a6 = { x: key }, _a6[seriesField] = series, _a6), toViolinValue(values3, pdfOptions)), toBoxValue(values3)));
    });
  });
  return resultList;
};

// node_modules/@antv/g2plot/esm/plots/violin/adaptor.js
var TOOLTIP_FIELDS = ["low", "high", "q1", "q3", "median"];
var adjustCfg = [
  {
    type: "dodge",
    marginRatio: 1 / 32
  }
];
function data2(params) {
  var chart = params.chart, options = params.options;
  chart.data(transformViolinData(options));
  return params;
}
function violinView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color3 = options.color, _a6 = options.shape, shape = _a6 === void 0 ? "violin" : _a6, violinStyle = options.violinStyle, tooltip11 = options.tooltip, state2 = options.state;
  var view = chart.createView({ id: VIOLIN_VIEW_ID });
  violin({
    chart: view,
    options: {
      xField: X_FIELD4,
      yField: VIOLIN_Y_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD4,
      sizeField: VIOLIN_SIZE_FIELD,
      tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip11),
      violin: {
        style: violinStyle,
        color: color3,
        shape
      },
      state: state2
    }
  });
  view.geometries[0].adjust(adjustCfg);
  return params;
}
function boxView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color3 = options.color, tooltip11 = options.tooltip, box2 = options.box;
  if (box2 === false)
    return params;
  var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
  interval2({
    chart: minMaxView,
    options: {
      xField: X_FIELD4,
      yField: MIN_MAX_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD4,
      tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip11),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color3,
        size: 1,
        style: {
          lineWidth: 0
        }
      }
    }
  });
  minMaxView.geometries[0].adjust(adjustCfg);
  var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
  interval2({
    chart: quantileView,
    options: {
      xField: X_FIELD4,
      yField: QUANTILE_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD4,
      tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip11),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color3,
        size: 8,
        style: {
          fillOpacity: 1
        }
      }
    }
  });
  quantileView.geometries[0].adjust(adjustCfg);
  var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
  point({
    chart: medianView,
    options: {
      xField: X_FIELD4,
      yField: MEDIAN_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD4,
      tooltip: __assign({ fields: TOOLTIP_FIELDS }, tooltip11),
      state: typeof box2 === "object" ? box2.state : {},
      point: {
        color: color3,
        size: 1,
        style: {
          fill: "white",
          lineWidth: 0
        }
      }
    }
  });
  medianView.geometries[0].adjust(adjustCfg);
  quantileView.axis(false);
  minMaxView.axis(false);
  medianView.axis(false);
  medianView.legend(false);
  minMaxView.legend(false);
  quantileView.legend(false);
  return params;
}
function meta20(params) {
  var _a6;
  var chart = params.chart, options = params.options;
  var meta23 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
  var baseMeta = {};
  var scales = deepAssign(baseMeta, meta23, (_a6 = {}, _a6[X_FIELD4] = __assign(__assign({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), {
    // fix:  dodge is not support linear attribute, please use category attribute!
    //  x 
    type: "cat"
  }), _a6[VIOLIN_Y_FIELD] = __assign({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a6[MIN_MAX_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a6[QUANTILE_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a6[MEDIAN_FIELD] = __assign({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a6));
  chart.scale(scales);
  return params;
}
function axis20(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  var view = findViewById(chart, VIOLIN_VIEW_ID);
  if (xAxis === false) {
    view.axis(X_FIELD4, false);
  } else {
    view.axis(X_FIELD4, xAxis);
  }
  if (yAxis === false) {
    view.axis(VIOLIN_Y_FIELD, false);
  } else {
    view.axis(VIOLIN_Y_FIELD, yAxis);
  }
  chart.axis(false);
  return params;
}
function legend15(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, seriesField = options.seriesField, shape = options.shape;
  if (legend18 === false) {
    chart.legend(false);
  } else {
    var legendField_1 = seriesField ? seriesField : X_FIELD4;
    var legendOptions = omit_default(legend18, ["selected"]);
    if (!shape || !shape.startsWith("hollow")) {
      if (!get_default(legendOptions, ["marker", "style", "lineWidth"])) {
        set_default(legendOptions, ["marker", "style", "lineWidth"], 0);
      }
    }
    chart.legend(legendField_1, legendOptions);
    if (get_default(legend18, "selected")) {
      each_default(chart.views, function(view) {
        return view.legend(legendField_1, legend18);
      });
    }
  }
  return params;
}
function annotation3(params) {
  var chart = params.chart;
  var violinView2 = findViewById(chart, VIOLIN_VIEW_ID);
  annotation()(__assign(__assign({}, params), { chart: violinView2 }));
  return params;
}
function animation6(params) {
  var chart = params.chart, options = params.options;
  var animation7 = options.animation;
  each_default(chart.views, function(view) {
    addViewAnimation(view, animation7);
  });
  return params;
}
function adaptor33(params) {
  return flow(theme, data2, violinView, boxView, meta20, tooltip, axis20, legend15, interaction, annotation3, animation6)(params);
}

// node_modules/@antv/g2plot/esm/plots/violin/index.js
var Violin2 = (
  /** @class */
  function(_super) {
    __extends(Violin3, _super);
    function Violin3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      return _this;
    }
    Violin3.getDefaultOptions = function() {
      return DEFAULT_OPTIONS33;
    };
    Violin3.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      this.chart.changeData(transformViolinData(this.options));
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor33;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/waterfall/constant.js
var Y_FIELD5 = "$$yField$$";
var DIFF_FIELD = "$$diffField$$";
var ABSOLUTE_FIELD = "$$absoluteField$$";
var IS_TOTAL = "$$isTotal$$";
var DEFAULT_OPTIONS34 = {
  /** default: show label */
  label: {},
  /** default: show leaderLine */
  leaderLine: {
    style: {
      lineWidth: 1,
      stroke: "#8c8c8c",
      lineDash: [4, 2]
    }
  },
  /** default: show total */
  total: {
    style: {
      fill: "rgba(0, 0, 0, 0.25)"
    }
  },
  interactions: [{ type: "element-active" }],
  risingFill: "#f4664a",
  fallingFill: "#30bf78",
  waterfallStyle: {
    fill: "rgba(0, 0, 0, 0.25)"
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};

// node_modules/@antv/g2plot/esm/plots/waterfall/shape.js
function getRectPath2(points2) {
  var path = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  path.push(["L", first.x, first.y]);
  path.push(["z"]);
  return path;
}
function getFillAttrs3(cfg) {
  return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape("interval", "waterfall", {
  draw: function(cfg, container) {
    var customInfo = cfg.customInfo, points2 = cfg.points, nextPoints = cfg.nextPoints;
    var group2 = container.addGroup();
    var rectPath4 = this.parsePath(getRectPath2(points2));
    var fillAttrs = getFillAttrs3(cfg);
    group2.addShape("path", {
      attrs: __assign(__assign({}, fillAttrs), { path: rectPath4 })
    });
    var leaderLineCfg = get_default(customInfo, "leaderLine");
    if (leaderLineCfg && nextPoints) {
      var linkPath = [
        ["M", points2[2].x, points2[2].y],
        ["L", nextPoints[0].x, nextPoints[0].y]
      ];
      if (points2[2].y === nextPoints[1].y) {
        linkPath[1] = ["L", nextPoints[1].x, nextPoints[1].y];
      }
      linkPath = this.parsePath(linkPath);
      group2.addShape("path", {
        attrs: __assign({ path: linkPath }, leaderLineCfg.style || {})
      });
    }
    return group2;
  }
});

// node_modules/@antv/g2plot/esm/plots/waterfall/utils.js
function processData(data3, xField, yField, newYField, total) {
  var _a6;
  var newData = [];
  reduce_default(data3, function(r, d) {
    var _a7;
    log2(LEVEL.WARN, is_number_default(d[yField]), "".concat(d[yField], " is not a valid number"));
    var value2 = is_undefined_default(d[yField]) ? null : d[yField];
    newData.push(__assign(__assign({}, d), (_a7 = {}, _a7[newYField] = [r, r + value2], _a7)));
    return r + value2;
  }, 0);
  if (newData.length && total) {
    var sum2 = get_default(newData, [[data3.length - 1], newYField, [1]]);
    newData.push((_a6 = {}, _a6[xField] = total.label, _a6[yField] = sum2, _a6[newYField] = [0, sum2], _a6));
  }
  return newData;
}
function transformData9(data3, xField, yField, total) {
  var processed = processData(data3, xField, yField, Y_FIELD5, total);
  return processed.map(function(d, dIdx) {
    var _a6;
    if (!is_object_default(d)) {
      return d;
    }
    return __assign(__assign({}, d), (_a6 = {}, _a6[ABSOLUTE_FIELD] = d[Y_FIELD5][1], _a6[DIFF_FIELD] = d[Y_FIELD5][1] - d[Y_FIELD5][0], _a6[IS_TOTAL] = dIdx === data3.length, _a6));
  });
}

// node_modules/@antv/g2plot/esm/plots/waterfall/adaptor.js
function defaultOptions7(params) {
  var _a6 = params.options, locale = _a6.locale, total = _a6.total;
  var localeTotalLabel = getLocale(locale).get(["waterfall", "total"]);
  if (total && typeof total.label !== "string" && localeTotalLabel) {
    params.options.total.label = localeTotalLabel;
  }
  return params;
}
function geometry33(params) {
  var chart = params.chart, options = params.options;
  var data3 = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color3 = options.color, shape = options.shape, customInfo = options.customInfo;
  chart.data(transformData9(data3, xField, yField, total));
  var colorMapping = color3 || function(datum) {
    if (get_default(datum, [IS_TOTAL])) {
      return get_default(total, ["style", "fill"], "");
    }
    return get_default(datum, [Y_FIELD5, 1]) - get_default(datum, [Y_FIELD5, 0]) > 0 ? risingFill : fallingFill;
  };
  var p = deepAssign({}, params, {
    options: {
      xField,
      yField: Y_FIELD5,
      seriesField: xField,
      rawFields: [yField, DIFF_FIELD, IS_TOTAL, Y_FIELD5],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        // 
        shape: shape || "waterfall",
        color: colorMapping
      }
    }
  });
  var ext = interval2(p).ext;
  var geometry35 = ext.geometry;
  geometry35.customInfo(__assign(__assign({}, customInfo), { leaderLine }));
  return params;
}
function meta21(params) {
  var _a6, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta23 = options.meta;
  var Y_FIELD_META = deepAssign({}, { alias: yField }, get_default(meta23, yField));
  return flow(scale5((_a6 = {}, _a6[xField] = xAxis, _a6[yField] = yAxis, _a6[Y_FIELD5] = yAxis, _a6), deepAssign({}, meta23, (_b = {}, _b[Y_FIELD5] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
function axis21(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(Y_FIELD5, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(Y_FIELD5, yAxis);
  }
  return params;
}
function legend16(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale = options.locale;
  var i18n = getLocale(locale);
  if (legend18 === false) {
    chart.legend(false);
  } else {
    var items = [
      {
        name: i18n.get(["general", "increase"]),
        value: "increase",
        marker: { symbol: "square", style: { r: 5, fill: risingFill } }
      },
      {
        name: i18n.get(["general", "decrease"]),
        value: "decrease",
        marker: { symbol: "square", style: { r: 5, fill: fallingFill } }
      }
    ];
    if (total) {
      items.push({
        name: total.label || "",
        value: "total",
        marker: {
          symbol: "square",
          style: deepAssign({}, { r: 5 }, get_default(total, "style"))
        }
      });
    }
    chart.legend(deepAssign({}, {
      custom: true,
      position: "top",
      items
    }, legend18));
    chart.removeInteraction("legend-filter");
  }
  return params;
}
function label16(params) {
  var chart = params.chart, options = params.options;
  var label17 = options.label, labelMode = options.labelMode, xField = options.xField;
  var geometry35 = findGeometry(chart, "interval");
  if (!label17) {
    geometry35.label(false);
  } else {
    var callback = label17.callback, cfg = __rest(label17, ["callback"]);
    geometry35.label({
      fields: labelMode === "absolute" ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function tooltip10(params) {
  var chart = params.chart, options = params.options;
  var tooltip11 = options.tooltip, xField = options.xField, yField = options.yField;
  if (tooltip11 !== false) {
    chart.tooltip(__assign({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      // tooltip  y 
      fields: [yField]
    }, tooltip11));
    var geometry_1 = chart.geometries[0];
    (tooltip11 === null || tooltip11 === void 0 ? void 0 : tooltip11.formatter) ? geometry_1.tooltip("".concat(xField, "*").concat(yField), tooltip11.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function adaptor34(params) {
  return flow(defaultOptions7, theme, geometry33, meta21, axis21, legend16, tooltip10, label16, state, interaction, animation, annotation())(params);
}

// node_modules/@antv/g2plot/esm/plots/waterfall/index.js
var Waterfall = (
  /** @class */
  function(_super) {
    __extends(Waterfall2, _super);
    function Waterfall2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "waterfall";
      return _this;
    }
    Waterfall2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS34;
    };
    Waterfall2.prototype.changeData = function(data3) {
      var _a6 = this.options, xField = _a6.xField, yField = _a6.yField, total = _a6.total;
      this.updateOption({ data: data3 });
      this.chart.changeData(transformData9(data3, xField, yField, total));
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor34;
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plots/word-cloud/constant.js
var WORD_CLOUD_COLOR_FIELD = "color";
var DEFAULT_OPTIONS35 = deepAssign({}, Plot.getDefaultOptions(), {
  timeInterval: 2e3,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ["text", "value", WORD_CLOUD_COLOR_FIELD],
    formatter: function(datum) {
      return { name: datum.text, value: datum.value };
    }
  },
  wordStyle: {
    fontFamily: "Verdana",
    fontWeight: "normal",
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});

// node_modules/@antv/g2plot/esm/utils/transform/word-cloud.js
var DEFAULT_OPTIONS36 = {
  font: function() {
    return "serif";
  },
  padding: 1,
  size: [500, 500],
  spiral: "archimedean",
  // timeInterval: Infinity // max execute time
  timeInterval: 3e3
  // max execute time
  // imageMask: '', // instance of Image, must be loaded
};
function wordCloud(words2, options) {
  options = mix({}, DEFAULT_OPTIONS36, options);
  return transform7(words2, options);
}
function transform7(words2, options) {
  var layout2 = tagCloud();
  ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval", "random"].forEach(function(key) {
    if (!is_nil_default(options[key])) {
      layout2[key](options[key]);
    }
  });
  layout2.words(words2);
  if (options.imageMask) {
    layout2.createMask(options.imageMask);
  }
  var result2 = layout2.start();
  var tags = result2._tags;
  tags.forEach(function(tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a6 = options.size, w = _a6[0], h = _a6[1];
  tags.push({
    text: "",
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags.push({
    text: "",
    value: 0,
    x: w,
    y: h,
    opacity: 0
  });
  return tags;
}
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d) {
  return d.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d) {
  return d.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0, y = 0, maxh = 0;
  var n = data3.length;
  --di;
  while (++di < n) {
    d = data3[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }
    if (y + h >= ch)
      break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText)
      continue;
    var w = d.width, w32 = w >> 5;
    var h = d.y1 - d.y0;
    for (var i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x = d.xoff;
    if (x == null)
      return;
    y = d.yoff;
    var seen = 0, seenRow = -1;
    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  var x = (tag.y + tag.y0) * sw + (lx >> 5), last3;
  for (var j = 0; j < h; j++) {
    last3 = 0;
    for (var i = 0; i <= w; i++) {
      if ((last3 << msx | (i < w ? (last3 = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
        return true;
    }
    x += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b02 = bounds[0], b12 = bounds[1];
  if (d.x + d.x0 < b02.x)
    b02.x = d.x + d.x0;
  if (d.y + d.y0 < b02.y)
    b02.y = d.y + d.y0;
  if (d.x + d.x1 > b12.x)
    b12.x = d.x + d.x1;
  if (d.y + d.y1 > b12.y)
    b12.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size3) {
  var e = size3[0] / size3[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size3) {
  var dy = 4, dx = dy * size3[0] / size3[1];
  var x = 0, y = 0;
  return function(t) {
    var sign = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;
      case 1:
        y += dy;
        break;
      case 2:
        x -= dx;
        break;
      default:
        y -= dy;
        break;
    }
    return [x, y];
  };
}
function zeroArray(n) {
  var a = [];
  var i = -1;
  while (++i < n)
    a[i] = 0;
  return a;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d) {
  return is_function_default(d) ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  var size3 = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate5 = cloudRotate, padding3 = cloudPadding, spiral = archimedeanSpiral, random4 = Math.random, words2 = [], timeInterval = Infinity;
  var text = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};
  cloud.start = function() {
    var width = size3[0], height = size3[1];
    var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size3[0] >> 5) * size3[1]), n = words2.length, tags = [], data3 = words2.map(function(d, i2, data4) {
      d.text = text.call(this, d, i2, data4);
      d.font = font.call(this, d, i2, data4);
      d.style = fontStyle.call(this, d, i2, data4);
      d.weight = fontWeight.call(this, d, i2, data4);
      d.rotate = rotate5.call(this, d, i2, data4);
      d.size = ~~fontSize.call(this, d, i2, data4);
      d.padding = padding3.call(this, d, i2, data4);
      return d;
    }).sort(function(a, b) {
      return b.size - a.size;
    });
    var i = -1, bounds = !cloud.board ? null : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    step();
    function step() {
      var start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        var d = data3[i];
        d.x = width * (random4() + 0.5) >> 1;
        d.y = height * (random4() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data3, i);
        if (d.hasText && place2(board, d, bounds)) {
          tags.push(d);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d);
            }
          } else {
            bounds = [
              { x: d.x + d.x0, y: d.y + d.y0 },
              { x: d.x + d.x1, y: d.y + d.y1 }
            ];
          }
          d.x -= size3[0] >> 1;
          d.y -= size3[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    var ratio = Math.sqrt(canvas2.getContext("2d", { willReadFrequently: true }).getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    var context = canvas2.getContext("2d", { willReadFrequently: true });
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size3[0] * size3[0] + size3[1] * size3[1]), s = spiral(size3), dt = random4() < 0.5 ? 1 : -1;
    var dxdy, t = -dt, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size3[0] || tag.y + tag.y1 > size3[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size3[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite, w = tag.width >> 5, sw = size3[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          var last3 = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
          for (var j = 0; j < h; j++) {
            last3 = 0;
            for (var i = 0; i <= w; i++) {
              board[x + i] |= last3 << msx | (i < w ? (last3 = sprite[j * w + i]) >>> sx : 0);
            }
            x += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = function(img) {
    var can = document.createElement("canvas");
    var width = size3[0], height = size3[1];
    if (!width || !height) {
      return;
    }
    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++) {
        var k = w32 * j + (i >> 5);
        var tmp = j * width + i << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m = flag ? 1 << 31 - i % 32 : 0;
        board[k] |= m;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_) {
    timeInterval = _ == null ? Infinity : _;
  };
  cloud.words = function(_) {
    words2 = _;
  };
  cloud.size = function(_) {
    size3 = [+_[0], +_[1]];
  };
  cloud.font = function(_) {
    font = functor(_);
  };
  cloud.fontWeight = function(_) {
    fontWeight = functor(_);
  };
  cloud.rotate = function(_) {
    rotate5 = functor(_);
  };
  cloud.spiral = function(_) {
    spiral = spirals[_] || _;
  };
  cloud.fontSize = function(_) {
    fontSize = functor(_);
  };
  cloud.padding = function(_) {
    padding3 = functor(_);
  };
  cloud.random = function(_) {
    random4 = functor(_);
  };
  return cloud;
}

// node_modules/@antv/g2plot/esm/plots/word-cloud/utils.js
function transform8(params) {
  var rawOptions = params.options, chart = params.chart;
  var _a6 = chart, width = _a6.width, height = _a6.height, chartPadding = _a6.padding, appendPadding = _a6.appendPadding, ele = _a6.ele;
  var data3 = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random4 = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
  if (!data3 || !data3.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding3 = wordStyle.padding, fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data3, weightField);
  var range2 = [min4(arr), max4(arr)];
  var words2 = data3.map(function(datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum
    };
  });
  var options = {
    imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range2),
    fontWeight,
    //  padding 
    size: getSize({
      width,
      height,
      padding: chartPadding,
      appendPadding,
      autoFit,
      container: ele
    }),
    padding: padding3,
    timeInterval,
    random: random4,
    spiral,
    rotate: getRotate(rawOptions)
  };
  if (is_function_default(placementStrategy)) {
    var result2 = words2.map(function(word2, index, words3) {
      return __assign(__assign(__assign({}, word2), { hasText: !!word2.text, font: functor(options.font)(word2, index, words3), weight: functor(options.fontWeight)(word2, index, words3), rotate: functor(options.rotate)(word2, index, words3), size: functor(options.fontSize)(word2, index, words3), style: "normal" }), placementStrategy.call(chart, word2, index, words3));
    });
    result2.push({
      text: "",
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result2.push({
      text: "",
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result2;
  }
  return wordCloud(words2, options);
}
function getSize(options) {
  var width = options.width, height = options.height;
  var container = options.container, autoFit = options.autoFit, padding3 = options.padding, appendPadding = options.appendPadding;
  if (autoFit) {
    var containerSize = getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  width = width || 400;
  height = height || 400;
  var _a6 = resolvePadding({ padding: padding3, appendPadding }), top = _a6[0], right2 = _a6[1], bottom = _a6[2], left2 = _a6[3];
  var result2 = [width - (left2 + right2), height - (top + bottom)];
  return result2;
}
function resolvePadding(options) {
  var padding3 = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding3[0] + appendPadding[0];
  var right2 = padding3[1] + appendPadding[1];
  var bottom = padding3[2] + appendPadding[2];
  var left2 = padding3[3] + appendPadding[3];
  return [top, right2, bottom, left2];
}
function processImageMask(img) {
  return new Promise(function(res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (is_string_default(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = "anonymous";
      image_1.src = img;
      image_1.onload = function() {
        res(image_1);
      };
      image_1.onerror = function() {
        log2(LEVEL.ERROR, false, "image %s load failed !!!", img);
        rej();
      };
      return;
    }
    log2(LEVEL.WARN, img === void 0, "The type of imageMask option must be String or HTMLImageElement.");
    rej();
  });
}
function getFontSizeMapping(fontSize, range2) {
  if (is_function_default(fontSize)) {
    return fontSize;
  }
  if (is_array_default(fontSize)) {
    var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
    if (!range2) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range2[0], max_1 = range2[1];
    if (max_1 === min_1) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize2(_a6) {
      var value2 = _a6.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value2 - min_1) + fMin_1;
    };
  }
  return function() {
    return fontSize;
  };
}
function getSingleKeyValues(data3, key) {
  return data3.map(function(v) {
    return v[key];
  }).filter(function(v) {
    if (typeof v === "number" && !isNaN(v))
      return true;
    return false;
  });
}
function getRotate(options) {
  var _a6 = resolveRotate(options), rotation = _a6.rotation, rotationSteps = _a6.rotationSteps;
  if (!is_array_default(rotation))
    return rotation;
  var min5 = rotation[0];
  var max5 = rotation[1];
  var perSize = rotationSteps === 1 ? 0 : (max5 - min5) / (rotationSteps - 1);
  return function rotate5() {
    if (max5 === min5)
      return max5;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    log2(LEVEL.WARN, false, "The rotationSteps option must be greater than or equal to 1.");
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps
  };
}
function min4(numbers) {
  return Math.min.apply(Math, numbers);
}
function max4(numbers) {
  return Math.max.apply(Math, numbers);
}

// node_modules/@antv/g2plot/esm/plots/word-cloud/adaptor.js
function geometry34(params) {
  var chart = params.chart, options = params.options;
  var colorField = options.colorField, color3 = options.color;
  var data3 = transform8(params);
  chart.data(data3);
  var p = deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
      rawFields: is_function_default(color3) && __spreadArray(__spreadArray([], get_default(options, "rawFields", []), true), ["datum"], false),
      point: {
        color: color3,
        shape: "word-cloud"
      }
    }
  });
  var ext = point(p).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect("y");
  chart.axis(false);
  return params;
}
function meta22(params) {
  return flow(scale5({
    x: { nice: false },
    y: { nice: false }
  }))(params);
}
function legend17(params) {
  var chart = params.chart, options = params.options;
  var legend18 = options.legend, colorField = options.colorField;
  if (legend18 === false) {
    chart.legend(false);
  } else if (colorField) {
    chart.legend(WORD_CLOUD_COLOR_FIELD, legend18);
  }
  return params;
}
function adaptor35(params) {
  flow(geometry34, meta22, tooltip, legend17, interaction, animation, theme, state)(params);
}

// node_modules/@antv/g2plot/esm/plots/word-cloud/shapes/word-cloud.js
registerShape("point", "word-cloud", {
  draw: function(cfg, group2) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group2.addShape("text", {
      attrs: __assign(__assign({}, getTextAttrs(cfg)), { x: cx, y: cy })
    });
    var rotate5 = cfg.data.rotate;
    if (typeof rotate5 === "number") {
      Util.rotate(shape, rotate5 * Math.PI / 180);
    }
    return shape;
  }
});
function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: "center",
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: "alphabetic"
  };
}

// node_modules/@antv/g2plot/esm/plots/word-cloud/index.js
var WordCloud = (
  /** @class */
  function(_super) {
    __extends(WordCloud2, _super);
    function WordCloud2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "word-cloud";
      return _this;
    }
    WordCloud2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS35;
    };
    WordCloud2.prototype.changeData = function(data3) {
      this.updateOption({ data: data3 });
      if (this.options.imageMask) {
        this.render();
      } else {
        this.chart.changeData(transform8({ chart: this.chart, options: this.options }));
      }
    };
    WordCloud2.prototype.getDefaultOptions = function() {
      return WordCloud2.getDefaultOptions();
    };
    WordCloud2.prototype.render = function() {
      var _this = this;
      return new Promise(function(res) {
        var imageMask = _this.options.imageMask;
        if (!imageMask) {
          _super.prototype.render.call(_this);
          res();
          return;
        }
        var handler = function(img) {
          _this.options = __assign(__assign({}, _this.options), { imageMask: img || null });
          _super.prototype.render.call(_this);
          res();
        };
        processImageMask(imageMask).then(handler).catch(handler);
      });
    };
    WordCloud2.prototype.getSchemaAdaptor = function() {
      return adaptor35;
    };
    WordCloud2.prototype.triggerResize = function() {
      var _this = this;
      if (!this.chart.destroyed) {
        this.execAdaptor();
        window.setTimeout(function() {
          _super.prototype.triggerResize.call(_this);
        });
      }
    };
    return WordCloud2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/plugin/index.js
var P = (
  /** @class */
  function(_super) {
    __extends(P2, _super);
    function P2(container, options, adaptor36, defaultOptions8) {
      var _this = _super.call(this, container, deepAssign({}, defaultOptions8, options)) || this;
      _this.type = "g2-plot";
      _this.defaultOptions = defaultOptions8;
      _this.adaptor = adaptor36;
      return _this;
    }
    P2.prototype.getDefaultOptions = function() {
      return this.defaultOptions;
    };
    P2.prototype.getSchemaAdaptor = function() {
      return this.adaptor;
    };
    return P2;
  }(Plot)
);

// node_modules/@antv/g2plot/esm/index.js
var version3 = "2.4.31";
registerLocale("en-US", EN_US_LOCALE);
registerLocale("zh-CN", ZH_CN_LOCALE);
var adaptors = { scale: scale5, legend, tooltip, annotation, interaction, theme, animation };
export {
  Area2 as Area,
  Bar,
  BidirectionalBar,
  Box,
  Bullet,
  Chord,
  CirclePacking,
  Column,
  DualAxes,
  FUNNEL_CONVERSATION as FUNNEL_CONVERSATION_FIELD,
  Facet2 as Facet,
  Funnel,
  esm_exports4 as G2,
  Gauge,
  Heatmap2 as Heatmap,
  Histogram,
  Lab2 as Lab,
  Line6 as Line,
  Liquid,
  Mix,
  Mix as MultiView,
  P,
  Pie,
  Plot,
  Progress,
  Radar,
  RadialBar,
  RingProgress,
  Rose,
  Sankey2 as Sankey,
  Scatter,
  Stock,
  Sunburst,
  TinyArea,
  TinyColumn,
  TinyLine,
  Treemap,
  Venn,
  Violin2 as Violin,
  Waterfall,
  WordCloud,
  adaptors,
  addWaterWave,
  area,
  flow,
  getCanvasPattern,
  interval2 as interval,
  line,
  measureTextWidth2 as measureTextWidth,
  point,
  polygon,
  registerLocale,
  schema,
  setGlobal,
  version3 as version
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

lodash-es/lodash.default.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@antv_g2plot.js.map
